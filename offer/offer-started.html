<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?87d678935e4b33455c0390543e7a759d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><title>java基础 | 怨种学java</title><meta name="description" content="「流水不争先 争的是滔滔不绝」">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/offer/assets/style-1e9048c3.css" as="style"><link rel="stylesheet" href="/offer/assets/style-1e9048c3.css">
    <link rel="modulepreload" href="/offer/assets/app-fdefc158.js"><link rel="modulepreload" href="/offer/assets/framework-8edddef6.js"><link rel="modulepreload" href="/offer/assets/offer-started.html-e24da2b5.js"><link rel="modulepreload" href="/offer/assets/offer-started.html-86292eef.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/offer/" class="brand"><img class="logo" src="/offer/logo.png" alt="怨种学java"><!----><span class="site-name hide-in-pad">怨种学java</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/offer/source-code/nacos/clusterSync.html" class="nav-link" aria-label="笔记"><span class="font-icon icon iconfont icon-activity" style=""></span>笔记<!----></a></div><div class="nav-item hide-in-mobile"><a aria-current="page" href="/offer/offer/offer-started.html" class="router-link-active router-link-exact-active nav-link active" aria-label="八股"><span class="font-icon icon iconfont icon-shell" style=""></span>八股<!----></a></div><div class="nav-item hide-in-mobile"><a href="/offer/link.html" class="nav-link" aria-label="外部链接"><span class="font-icon icon iconfont icon-share" style=""></span>外部链接<!----></a></div><div class="nav-item hide-in-mobile"><a href="/offer/about.html" class="nav-link" aria-label="关于作者"><span class="font-icon icon iconfont icon-alias" style=""></span>关于作者<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/springboot4" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-software" style=""></span><span class="title">nacos</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/offer/source-code/nacos/clusterSync.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos集群同步"><!---->nacos集群同步<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/nacos/config.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos配置中心"><!---->nacos配置中心<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/nacos/discoverAndSubscribe.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务发现和订阅机制"><!---->nacos服务发现和订阅机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/nacos/healthCheck.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos健康检查机制"><!---->nacos健康检查机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/nacos/register.html" class="nav-link sidebar-link sidebar-page" aria-label="nacos服务注册"><!---->nacos服务注册<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-alias" style=""></span><span class="title">spring</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/offer/source-code/spring/SpingInject.html" class="nav-link sidebar-link sidebar-page" aria-label="sping依赖注入"><!---->sping依赖注入<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/spring/Spring@Async.html" class="nav-link sidebar-link sidebar-page" aria-label="spring异步@Async"><!---->spring异步@Async<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/spring/SpringAop.html" class="nav-link sidebar-link sidebar-page" aria-label="spring aop"><!---->spring aop<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/spring/SpringBeanLIfeCycle.html" class="nav-link sidebar-link sidebar-page" aria-label="spring bean的生命周期"><!---->spring bean的生命周期<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/spring/SpringConfig.html" class="nav-link sidebar-link sidebar-page" aria-label="spring配置文件"><!---->spring配置文件<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/spring/SpringTransaction.html" class="nav-link sidebar-link sidebar-page" aria-label="spring事务"><!---->spring事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-template" style=""></span><span class="title">spring boot</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/offer/source-code/SpringBoot/config.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot配置加载"><!---->spring boot配置加载<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/SpringBoot/start.html" class="nav-link sidebar-link sidebar-page" aria-label="spring boot启动流程"><!---->spring boot启动流程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-module" style=""></span><span class="title">spring cloud</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/offer/source-code/SpringCloudCommon/configRefresh.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud配置动态刷新"><!---->spring cloud配置动态刷新<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/SpringCloudCommon/loadBalancing.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud loadBalanced"><!---->spring cloud loadBalanced<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/offer/source-code/SpringCloudCommon/registerAndDiscover.html" class="nav-link sidebar-link sidebar-page" aria-label="spring cloud服务注册和发现"><!---->spring cloud服务注册和发现<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->java基础</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://fxzcloud.gitee.io/offer/" target="_blank" rel="noopener noreferrer">fxz</a></span><span property="author" content="fxz"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-02-29T07:03:48.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 1056 分钟</span><meta property="timeRequired" content="PT1056M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-java语言的特点" class="router-link-active router-link-exact-active toc-link level3">1. java语言的特点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-解释一下jvm、jdk、jre。" class="router-link-active router-link-exact-active toc-link level3">2. 解释一下jvm、jdk、jre。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-什么是字节码-采用字节码的好处是什么" class="router-link-active router-link-exact-active toc-link level3">3.什么是字节码?采用字节码的好处是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-为什么java是解释与编译共存" class="router-link-active router-link-exact-active toc-link level3">4.为什么java是解释与编译共存？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-了解oracle-jdk-和-openjdk的区别吗" class="router-link-active router-link-exact-active toc-link level3">5.了解Oracle JDK 和 OpenJDK的区别吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-java和c-的区别了解吗" class="router-link-active router-link-exact-active toc-link level3">6.java和c++的区别了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-字符型常量和字符串常量的区别" class="router-link-active router-link-exact-active toc-link level3">7.字符型常量和字符串常量的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-java注释有哪几种" class="router-link-active router-link-exact-active toc-link level3">8.java注释有哪几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-标识符和关键字的区别是什么" class="router-link-active router-link-exact-active toc-link level3">9.标识符和关键字的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-java中的关键字有哪些" class="router-link-active router-link-exact-active toc-link level3">10.java中的关键字有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-continue、break-和-return-的区别是什么" class="router-link-active router-link-exact-active toc-link level3">11.continue、break 和 return 的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-静态方法为什么不能调用非静态成员" class="router-link-active router-link-exact-active toc-link level3">12.静态方法为什么不能调用非静态成员?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-静态方法和实例方法有何不同" class="router-link-active router-link-exact-active toc-link level3">13.静态方法和实例方法有何不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-重载和重写的区别" class="router-link-active router-link-exact-active toc-link level3">14.重载和重写的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-什么是可变长度参数" class="router-link-active router-link-exact-active toc-link level3">15.什么是可变长度参数？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-java-中的几种基本数据类型了解么" class="router-link-active router-link-exact-active toc-link level3">16.Java 中的几种基本数据类型了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-基本类型和包装类型的区别" class="router-link-active router-link-exact-active toc-link level3">17.基本类型和包装类型的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-包装类型的缓存机制了解么" class="router-link-active router-link-exact-active toc-link level3">18.包装类型的缓存机制了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-自动装箱与拆箱了解吗-原理是什么" class="router-link-active router-link-exact-active toc-link level3">19.自动装箱与拆箱了解吗？原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-面向对象和面向过程的区别" class="router-link-active router-link-exact-active toc-link level3">20.面向对象和面向过程的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-成员变量与局部变量的区别" class="router-link-active router-link-exact-active toc-link level3">21.成员变量与局部变量的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="router-link-active router-link-exact-active toc-link level3">22.创建一个对象用什么运算符?对象实体与对象引用有何不同?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-对象的相等和引用相等的区别" class="router-link-active router-link-exact-active toc-link level3">23.对象的相等和引用相等的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-类的构造方法的作用是什么-如果一个类没有声明构造方法-该程序能正确执行吗" class="router-link-active router-link-exact-active toc-link level3">24.类的构造方法的作用是什么?如果一个类没有声明构造方法，该程序能正确执行吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-构造方法有哪些特点-是否可被-override" class="router-link-active router-link-exact-active toc-link level3">25.构造方法有哪些特点？是否可被 override?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-面向对象三大特征了解吗" class="router-link-active router-link-exact-active toc-link level3">26.面向对象三大特征了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-接口和抽象类有什么共同点和区别" class="router-link-active router-link-exact-active toc-link level3">27.接口和抽象类有什么共同点和区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" class="router-link-active router-link-exact-active toc-link level3">28.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-和-equals-的区别" class="router-link-active router-link-exact-active toc-link level3">29.== 和 equals() 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-hashcode-有什么用" class="router-link-active router-link-exact-active toc-link level3">30.hashCode() 有什么用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-为什么要有-hashcode" class="router-link-active router-link-exact-active toc-link level3">31.为什么要有 hashCode？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_32-为什么重写-equals-时必须重写-hashcode-方法" class="router-link-active router-link-exact-active toc-link level3">32.为什么重写 equals() 时必须重写 hashCode() 方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_33-string、stringbuffer、stringbuilder-的区别" class="router-link-active router-link-exact-active toc-link level3">33.String、StringBuffer、StringBuilder 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_34-string-为什么是不可变的" class="router-link-active router-link-exact-active toc-link level3">34.String 为什么是不可变的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_35-字符串拼接用-还是-stringbuilder" class="router-link-active router-link-exact-active toc-link level3">35.字符串拼接用“+” 还是 StringBuilder?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_36-string-equals-和-object-equals-有何区别" class="router-link-active router-link-exact-active toc-link level3">36.String#equals() 和 Object#equals() 有何区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_37-字符串常量池的作用了解吗" class="router-link-active router-link-exact-active toc-link level3">37.字符串常量池的作用了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_38-string-s1-new-string-abc-这句话创建了几个字符串对象" class="router-link-active router-link-exact-active toc-link level3">38.String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_39-intern-方法有什么作用" class="router-link-active router-link-exact-active toc-link level3">39.intern 方法有什么作用?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_40-exception-和-error-有什么区别" class="router-link-active router-link-exact-active toc-link level3">40.Exception 和 Error 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_41-checked-exception-和-unchecked-exception-有什么区别" class="router-link-active router-link-exact-active toc-link level3">41.Checked Exception 和 Unchecked Exception 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_42-throwable-类常用方法有哪些" class="router-link-active router-link-exact-active toc-link level3">42.Throwable 类常用方法有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_43-try-catch-finally-如何使用" class="router-link-active router-link-exact-active toc-link level3">43.try-catch-finally 如何使用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_44-finally-中的代码一定会执行吗" class="router-link-active router-link-exact-active toc-link level3">44.finally 中的代码一定会执行吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_45-如何使用-try-with-resources-代替try-catch-finally" class="router-link-active router-link-exact-active toc-link level3">45.如何使用 try-with-resources 代替try-catch-finally？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_46-什么是泛型-有什么作用" class="router-link-active router-link-exact-active toc-link level3">46.什么是泛型？有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_47-泛型的使用方式有哪几种" class="router-link-active router-link-exact-active toc-link level3">47.泛型的使用方式有哪几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_48-何为反射-反射机制优缺点" class="router-link-active router-link-exact-active toc-link level3">48.何为反射？反射机制优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_49-反射的有哪些应用场景" class="router-link-active router-link-exact-active toc-link level3">49.反射的有哪些应用场景？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_50-什么是注解" class="router-link-active router-link-exact-active toc-link level3">50.什么是注解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_51-什么是序列化-什么是反序列化" class="router-link-active router-link-exact-active toc-link level3">51.什么是序列化?什么是反序列化?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_52-java-序列化中如果有些字段不想进行序列化-怎么办" class="router-link-active router-link-exact-active toc-link level3">52.Java 序列化中如果有些字段不想进行序列化，怎么办？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_53-java-中-io-流分为几种" class="router-link-active router-link-exact-active toc-link level3">53.Java 中 IO 流分为几种?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_54-既然有了字节流-为什么还要有字符流" class="router-link-active router-link-exact-active toc-link level3">54.既然有了字节流,为什么还要有字符流?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_55-java-中只有值传递" class="router-link-active router-link-exact-active toc-link level3">55.Java 中只有值传递？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_56-序列化协议对应于-tcp-ip-4-层模型的哪一层" class="router-link-active router-link-exact-active toc-link level3">56.序列化协议对应于 TCP/IP 4 层模型的哪一层？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_57-什么是泛型擦除" class="router-link-active router-link-exact-active toc-link level3">57.什么是泛型擦除？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_58-jdk-动态代理和-cglib-动态代理对比" class="router-link-active router-link-exact-active toc-link level3">58.JDK 动态代理和 CGLIB 动态代理对比？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_59-静态代理和动态代理的对比" class="router-link-active router-link-exact-active toc-link level3">59.静态代理和动态代理的对比？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_60-有哪些常见的-io-模型" class="router-link-active router-link-exact-active toc-link level3">60.有哪些常见的 IO 模型?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_61-讲讲java中常见的三种io模型" class="router-link-active router-link-exact-active toc-link level3">61.讲讲java中常见的三种IO模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_62-java创建对象有几种方式" class="router-link-active router-link-exact-active toc-link level3">62.java创建对象有几种方式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_63-final有哪些用法" class="router-link-active router-link-exact-active toc-link level3">63.final有哪些用法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_64-oom遇到过哪些情况-sof呢" class="router-link-active router-link-exact-active toc-link level3">64.OOM遇到过哪些情况，SOF呢?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_65-说明一下public-static-void-main-string-args-这段声明里每个关键字的作用" class="router-link-active router-link-exact-active toc-link level3">65.说明一下public static void main(String args[])这段声明里每个关键字的作用?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_66-public-private-protected的区别-继承方法与访问权限" class="router-link-active router-link-exact-active toc-link level3">66.public，private，protected的区别，继承方法与访问权限</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_67-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="router-link-active router-link-exact-active toc-link level3">67.short s1 = 1; s1 = s1 + 1;有错吗？short s1 = 1; s1 += 1;有错吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_68-static的独特之处" class="router-link-active router-link-exact-active toc-link level3">68.static的独特之处?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_69-程序初始化的顺序" class="router-link-active router-link-exact-active toc-link level3">69.程序初始化的顺序</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_70-clone方法的保护机制" class="router-link-active router-link-exact-active toc-link level3">70.clone方法的保护机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_71-java中由substring方法是否会引起内存泄漏" class="router-link-active router-link-exact-active toc-link level3">71.Java中由SubString方法是否会引起内存泄漏?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_72-java中提供了哪两种用于多态的机制" class="router-link-active router-link-exact-active toc-link level3">72.Java中提供了哪两种用于多态的机制?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_73-在java中哪个数据类型可以用来表示money" class="router-link-active router-link-exact-active toc-link level3">73.在Java中哪个数据类型可以用来表示Money?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_74-javaio流的实现机制" class="router-link-active router-link-exact-active toc-link level3">74.JavaIO流的实现机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_75-管理文件和目录的类" class="router-link-active router-link-exact-active toc-link level3">75.管理文件和目录的类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_76-javasocket" class="router-link-active router-link-exact-active toc-link level3">76.JavaSoCket？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_77-内部类的分类及其特点" class="router-link-active router-link-exact-active toc-link level3">77.内部类的分类及其特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-说说-list-set-queue-map-四者的区别" class="router-link-active router-link-exact-active toc-link level3">1.说说 List, Set, Queue, Map 四者的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-介绍一下集合框架底层数据结构" class="router-link-active router-link-exact-active toc-link level3">2.介绍一下集合框架底层数据结构？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-为什么要使用集合" class="router-link-active router-link-exact-active toc-link level3">3.为什么要使用集合？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-arraylist-和-vector-的区别" class="router-link-active router-link-exact-active toc-link level3">4.ArrayList 和 Vector 的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-arraylist-与-linkedlist-区别" class="router-link-active router-link-exact-active toc-link level3">5.ArrayList 与 LinkedList 区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-聊一聊arraylist的扩容机制" class="router-link-active router-link-exact-active toc-link level3">6.聊一聊ArrayList的扩容机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-comparable-和-comparator-有什么区别" class="router-link-active router-link-exact-active toc-link level3">7.comparable 和 Comparator 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-比较-hashset、linkedhashset-和-treeset-三者的异同" class="router-link-active router-link-exact-active toc-link level3">8.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-queue-与-deque-的区别" class="router-link-active router-link-exact-active toc-link level3">9.Queue 与 Deque 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-arraydeque-与-linkedlist-的区别" class="router-link-active router-link-exact-active toc-link level3">10.ArrayDeque 与 LinkedList 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-说一说-priorityqueue" class="router-link-active router-link-exact-active toc-link level3">11.说一说 PriorityQueue？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-hashmap-和-hashtable-的区别" class="router-link-active router-link-exact-active toc-link level3">12.HashMap 和 Hashtable 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-hashmap-和-hashset-区别" class="router-link-active router-link-exact-active toc-link level3">13.HashMap 和 HashSet 区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-hashmap-和-treemap-区别" class="router-link-active router-link-exact-active toc-link level3">14.HashMap 和 TreeMap 区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-说说hashmap-的底层实现" class="router-link-active router-link-exact-active toc-link level3">15.说说HashMap 的底层实现？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-hashmap-的长度为什么是-2-的幂次方" class="router-link-active router-link-exact-active toc-link level3">16.HashMap 的长度为什么是 2 的幂次方？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-concurrenthashmap-和-hashtable-的区别" class="router-link-active router-link-exact-active toc-link level3">17.ConcurrentHashMap 和 Hashtable 的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-concurrenthashmap底层数据结构分析" class="router-link-active router-link-exact-active toc-link level3">18.ConcurrentHashMap底层数据结构分析？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-谈谈concurrenthashmap的扩容机制" class="router-link-active router-link-exact-active toc-link level3">19.谈谈ConcurrentHashMap的扩容机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-jdk1-7到jdk1-8-hashmap-发生了什么变化-底层" class="router-link-active router-link-exact-active toc-link level3">20.Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-说一下hashmap的put方法" class="router-link-active router-link-exact-active toc-link level3">21.说⼀下HashMap的Put⽅法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-hashmap的扩容机制原理" class="router-link-active router-link-exact-active toc-link level3">22.HashMap的扩容机制原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-copyonwritearraylist的底层原理是怎样的" class="router-link-active router-link-exact-active toc-link level3">23.CopyOnWriteArrayList的底层原理是怎样的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-fail-safe-机制与-fail-fast-机制分别有什-么作用" class="router-link-active router-link-exact-active toc-link level3">24.fail-safe 机制与 fail-fast 机制分别有什 么作用?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-什么叫做阻塞队列的有界和无界" class="router-link-active router-link-exact-active toc-link level3">25.什么叫做阻塞队列的有界和无界</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-concurrenthashmap-底层具体实现知-道吗-实现原理是什么" class="router-link-active router-link-exact-active toc-link level3">26.ConcurrentHashMap 底层具体实现知 道吗？实现原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-基于数组的阻塞队列-arrayblockingqueue-原理" class="router-link-active router-link-exact-active toc-link level3">27.基于数组的阻塞队列 ArrayBlockingQueue 原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-什么是线程和进程" class="router-link-active router-link-exact-active toc-link level3">1.什么是线程和进程?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-请简要描述线程与进程的关系-区别及优缺点" class="router-link-active router-link-exact-active toc-link level3">2.请简要描述线程与进程的关系,区别及优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-程序计数器为什么是私有的" class="router-link-active router-link-exact-active toc-link level3">3.程序计数器为什么是私有的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-虚拟机栈和本地方法栈为什么是私有的" class="router-link-active router-link-exact-active toc-link level3">4.虚拟机栈和本地方法栈为什么是私有的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-一句话简单介绍堆和方法区" class="router-link-active router-link-exact-active toc-link level3">5.一句话简单介绍堆和方法区？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-说说并发与并行的区别" class="router-link-active router-link-exact-active toc-link level3">6.说说并发与并行的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-为什么要使用多线程呢" class="router-link-active router-link-exact-active toc-link level3">7.为什么要使用多线程呢?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-使用多线程可能带来什么问题" class="router-link-active router-link-exact-active toc-link level3">8.使用多线程可能带来什么问题?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-说说线程的生命周期和状态" class="router-link-active router-link-exact-active toc-link level3">9.说说线程的生命周期和状态?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-什么是上下文切换" class="router-link-active router-link-exact-active toc-link level3">10.什么是上下文切换?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-什么是线程死锁-如何避免死锁" class="router-link-active router-link-exact-active toc-link level3">11.什么是线程死锁?如何避免死锁?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-说说-sleep-方法和-wait-方法区别和共同点" class="router-link-active router-link-exact-active toc-link level3">12.说说 sleep() 方法和 wait() 方法区别和共同点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" class="router-link-active router-link-exact-active toc-link level3">13.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-说一说自己对于-synchronized-关键字的了解" class="router-link-active router-link-exact-active toc-link level3">14.说一说自己对于 synchronized 关键字的了解?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-说说自己是怎么使用-synchronized-关键字" class="router-link-active router-link-exact-active toc-link level3">15.说说自己是怎么使用 synchronized 关键字?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-构造方法可以使用-synchronized-关键字修饰么" class="router-link-active router-link-exact-active toc-link level3">16.构造方法可以使用 synchronized 关键字修饰么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-讲一下-synchronized-关键字的底层原理" class="router-link-active router-link-exact-active toc-link level3">17.讲一下 synchronized 关键字的底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" class="router-link-active router-link-exact-active toc-link level3">18.说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-谈谈-synchronized-和-reentrantlock-的区别" class="router-link-active router-link-exact-active toc-link level3">19.谈谈 synchronized 和 ReentrantLock 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-讲讲cpu-缓存模型" class="router-link-active router-link-exact-active toc-link level3">20.讲讲CPU 缓存模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-讲一下-jmm-java-内存模型" class="router-link-active router-link-exact-active toc-link level3">21.讲一下 JMM(Java 内存模型)？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-并发编程的三个重要特性" class="router-link-active router-link-exact-active toc-link level3">22.并发编程的三个重要特性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-说说-synchronized-关键字和-volatile-关键字的区别" class="router-link-active router-link-exact-active toc-link level3">23.说说 synchronized 关键字和 volatile 关键字的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-threadlocal-原理" class="router-link-active router-link-exact-active toc-link level3">24.ThreadLocal 原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-为什么要用线程池" class="router-link-active router-link-exact-active toc-link level3">25.为什么要用线程池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-实现-runnable-接口和-callable-接口的区别" class="router-link-active router-link-exact-active toc-link level3">26.实现 Runnable 接口和 Callable 接口的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-执行-execute-方法和-submit-方法的区别是什么呢" class="router-link-active router-link-exact-active toc-link level3">27.执行 execute()方法和 submit()方法的区别是什么呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-如何创建线程池" class="router-link-active router-link-exact-active toc-link level3">28.如何创建线程池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-threadpoolexecutor构造函数重要参数分析" class="router-link-active router-link-exact-active toc-link level3">29.ThreadPoolExecutor构造函数重要参数分析？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-juc-包中的原子类是哪-4-类" class="router-link-active router-link-exact-active toc-link level3">30.JUC 包中的原子类是哪 4 类?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-能不能给我简单介绍一下-atomicinteger-类的原理" class="router-link-active router-link-exact-active toc-link level3">31.能不能给我简单介绍一下 AtomicInteger 类的原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_32-介绍一下aqs" class="router-link-active router-link-exact-active toc-link level3">32.介绍一下AQS?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_33-shutdown-和shutdownnow-的区别" class="router-link-active router-link-exact-active toc-link level3">33.shutdown()和shutdownNow()的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_34-isterminated-和isshutdown-的区别" class="router-link-active router-link-exact-active toc-link level3">34.isTerminated()和isShutdown()的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_35-说一下线程之间是如何通信的" class="router-link-active router-link-exact-active toc-link level3">35.说一下线程之间是如何通信的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_36-cas的原理以及缺点" class="router-link-active router-link-exact-active toc-link level3">36.CAS的原理以及缺点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_37-引用类型有哪些-有什么区别" class="router-link-active router-link-exact-active toc-link level3">37.引用类型有哪些？有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_38-happen-before规则" class="router-link-active router-link-exact-active toc-link level3">38.happen-before规则？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_39-线程的sleep、wait、join、yield如何使用" class="router-link-active router-link-exact-active toc-link level3">39.线程的sleep、wait、join、yield如何使用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_40-threadlocal的原理是什么-使用场景有哪些" class="router-link-active router-link-exact-active toc-link level3">40.ThreadLocal的原理是什么，使用场景有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_41-threadlocal有哪些内存泄露问题-如何避免" class="router-link-active router-link-exact-active toc-link level3">41.ThreadLocal有哪些内存泄露问题，如何避免？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_42-volatile的可见性和禁止指令重排序怎么实现的" class="router-link-active router-link-exact-active toc-link level3">42.volatile的可见性和禁止指令重排序怎么实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_43-concurrenthashmap底层原理是什么" class="router-link-active router-link-exact-active toc-link level3">43.ConcurrentHashMap底层原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_44-线程池中阻塞队列的作用-为什么是先添加队列而不是先创建最大线程" class="router-link-active router-link-exact-active toc-link level3">44.线程池中阻塞队列的作⽤？为什么是先添加队列⽽不是先创建最⼤线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_45-reentrantlock中的公平锁和非公平锁的底层实现" class="router-link-active router-link-exact-active toc-link level3">45.ReentrantLock中的公平锁和⾮公平锁的底层实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_46-reentrantlock中trylock-和lock-方法的区别" class="router-link-active router-link-exact-active toc-link level3">46.ReentrantLock中tryLock()和lock()⽅法的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_47-countdownlatch和semaphore的区别和底层原理" class="router-link-active router-link-exact-active toc-link level3">47.CountDownLatch和Semaphore的区别和底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_48-线程池如何知道一个线程的任务已经执行完成" class="router-link-active router-link-exact-active toc-link level3">48.线程池如何知道一个线程的任务已经执行完成</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_49-wait-和-notify-这个为什么要在-synchronized-代码块中" class="router-link-active router-link-exact-active toc-link level3">49.wait 和 notify 这个为什么要在 synchronized 代码块中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_50-java中interrupted-和-isinterruptedd方法的区别" class="router-link-active router-link-exact-active toc-link level3">50.Java中interrupted 和 isInterruptedd方法的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_51-synchronizedmap和concurrenthashmap有什么区别" class="router-link-active router-link-exact-active toc-link level3">51.SynchronizedMap和ConcurrentHashMap有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_52-线程池核心线程数怎么设置呢" class="router-link-active router-link-exact-active toc-link level3">52.线程池核心线程数怎么设置呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_53-java线程池中队列常用类型有哪些" class="router-link-active router-link-exact-active toc-link level3">53.Java线程池中队列常用类型有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_54-说说cyclicbarrier和countdownlatch的区别" class="router-link-active router-link-exact-active toc-link level3">54.说说CyclicBarrier和CountDownLatch的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_55-线程类的构造方法、静态块是被哪个线程调用的" class="router-link-active router-link-exact-active toc-link level3">55.线程类的构造⽅法、静态块是被哪个线程调⽤的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_56-死锁与活锁的区别-死锁与锁饥饿的区别" class="router-link-active router-link-exact-active toc-link level3">56.死锁与活锁的区别，死锁与锁饥饿的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_57-volatile实现可见性的原理" class="router-link-active router-link-exact-active toc-link level3">57.volatile实现可见性的原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_58-是否可以把一个数组修饰为volatile" class="router-link-active router-link-exact-active toc-link level3">58.是否可以把一个数组修饰为volatile?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_59-线上cpu飙高" class="router-link-active router-link-exact-active toc-link level3">59.线上CPU飙高</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-介绍下-java-内存区域-运行时数据区" class="router-link-active router-link-exact-active toc-link level3">1.介绍下 Java 内存区域（运行时数据区）?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-程序计数器" class="router-link-active router-link-exact-active toc-link level3">2.程序计数器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-java-虚拟机栈" class="router-link-active router-link-exact-active toc-link level3">3.Java 虚拟机栈？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-本地方法栈" class="router-link-active router-link-exact-active toc-link level3">4.本地方法栈？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-堆" class="router-link-active router-link-exact-active toc-link level3">5.堆？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-方法区" class="router-link-active router-link-exact-active toc-link level3">6.方法区？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-运行时常量池" class="router-link-active router-link-exact-active toc-link level3">7.运行时常量池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-字符串常量池" class="router-link-active router-link-exact-active toc-link level3">8.字符串常量池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-直接内存" class="router-link-active router-link-exact-active toc-link level3">9.直接内存？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-java-对象的创建过程" class="router-link-active router-link-exact-active toc-link level3">10.Java 对象的创建过程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-对象的内存布局" class="router-link-active router-link-exact-active toc-link level3">11.对象的内存布局？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-对象的访问定位" class="router-link-active router-link-exact-active toc-link level3">12.对象的访问定位？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-内存分配原则" class="router-link-active router-link-exact-active toc-link level3">13.内存分配原则?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-主要进行-gc-的区域" class="router-link-active router-link-exact-active toc-link level3">14.主要进行 gc 的区域？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-空间分配担保" class="router-link-active router-link-exact-active toc-link level3">15.空间分配担保？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-死亡对象判断方法" class="router-link-active router-link-exact-active toc-link level3">16.死亡对象判断方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-引用类型总结" class="router-link-active router-link-exact-active toc-link level3">17.引用类型总结？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-如何判断一个常量是废弃常量" class="router-link-active router-link-exact-active toc-link level3">18.如何判断一个常量是废弃常量？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-如何判断一个类是无用的类" class="router-link-active router-link-exact-active toc-link level3">19.如何判断一个类是无用的类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-垃圾收集算法" class="router-link-active router-link-exact-active toc-link level3">20.垃圾收集算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-垃圾收集器" class="router-link-active router-link-exact-active toc-link level3">21.垃圾收集器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-类加载过程" class="router-link-active router-link-exact-active toc-link level3">22.类加载过程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-类加载器总结" class="router-link-active router-link-exact-active toc-link level3">23.类加载器总结？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-双亲委派模型介绍" class="router-link-active router-link-exact-active toc-link level3">24.双亲委派模型介绍？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-双亲委派模型的好处" class="router-link-active router-link-exact-active toc-link level3">25.双亲委派模型的好处？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-如果我们不想用双亲委派模型怎么办" class="router-link-active router-link-exact-active toc-link level3">26.如果我们不想用双亲委派模型怎么办</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-什么是字节码" class="router-link-active router-link-exact-active toc-link level3">27.什么是字节码？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-一个对象从加载到jvm-再到被gc清除-都经历了什么过程" class="router-link-active router-link-exact-active toc-link level3">28.⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-什么是三色标记" class="router-link-active router-link-exact-active toc-link level3">29.什么是三⾊标记？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-一条-sql-语句在-mysql-内部是如何执行的" class="router-link-active router-link-exact-active toc-link level3">1.一条 SQL 语句在 MySQL 内部是如何执行的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-mysql-支持哪些存储引擎-默认使用哪个" class="router-link-active router-link-exact-active toc-link level3">2.MySQL 支持哪些存储引擎？默认使用哪个？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-mysql-存储引擎架构了解吗" class="router-link-active router-link-exact-active toc-link level3">3.MySQL 存储引擎架构了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-myisam-和-innodb-的区别是什么" class="router-link-active router-link-exact-active toc-link level3">4.MyISAM 和 InnoDB 的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-mysql-查询缓存" class="router-link-active router-link-exact-active toc-link level3">5.MySQL 查询缓存?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-何谓数据库事务" class="router-link-active router-link-exact-active toc-link level3">6.何谓数据库事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-并发事务带来了哪些问题" class="router-link-active router-link-exact-active toc-link level3">7.并发事务带来了哪些问题?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-不可重复读和幻读有什么区别呢" class="router-link-active router-link-exact-active toc-link level3">8.不可重复读和幻读有什么区别呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-sql-标准定义了哪些事务隔离级别" class="router-link-active router-link-exact-active toc-link level3">9.SQL 标准定义了哪些事务隔离级别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-mysql-的隔离级别是基于锁实现的吗" class="router-link-active router-link-exact-active toc-link level3">10.MySQL 的隔离级别是基于锁实现的吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-mysql-的默认隔离级别是什么" class="router-link-active router-link-exact-active toc-link level3">11.MySQL 的默认隔离级别是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-表级锁和行级锁了解吗-有什么区别" class="router-link-active router-link-exact-active toc-link level3">12.表级锁和行级锁了解吗？有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-共享锁和排他锁呢" class="router-link-active router-link-exact-active toc-link level3">13.共享锁和排他锁呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-innodb-有哪几类行锁" class="router-link-active router-link-exact-active toc-link level3">14.InnoDB 有哪几类行锁？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-何为索引-有什么作用" class="router-link-active router-link-exact-active toc-link level3">15.何为索引？有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-索引的优缺点" class="router-link-active router-link-exact-active toc-link level3">16.索引的优缺点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-为什么mysql-没有使用hash作为索引的数据结构呢" class="router-link-active router-link-exact-active toc-link level3">17.为什么MySQL 没有使用Hash作为索引的数据结构呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-b-树-b-树" class="router-link-active router-link-exact-active toc-link level3">18.B 树&amp; B+树?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-b-树-b-树两者有何异同呢" class="router-link-active router-link-exact-active toc-link level3">19.B 树&amp; B+树两者有何异同呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-索引类型" class="router-link-active router-link-exact-active toc-link level3">20.索引类型?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-聚集索引与非聚集索引以及优缺点" class="router-link-active router-link-exact-active toc-link level3">21.聚集索引与非聚集索引以及优缺点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-非聚集索引一定回表查询吗-覆盖索引" class="router-link-active router-link-exact-active toc-link level3">22.非聚集索引一定回表查询吗(覆盖索引)?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-覆盖索引" class="router-link-active router-link-exact-active toc-link level3">23.覆盖索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-联合索引" class="router-link-active router-link-exact-active toc-link level3">24.联合索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-最左前缀匹配原则" class="router-link-active router-link-exact-active toc-link level3">25.最左前缀匹配原则</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-创建索引的注意事项" class="router-link-active router-link-exact-active toc-link level3">26.创建索引的注意事项？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-使用索引的一些建议" class="router-link-active router-link-exact-active toc-link level3">27.使用索引的一些建议？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-redo-log是什么-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">28.redo log是什么？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-redo-log刷盘时机-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">29.redo log刷盘时机？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-为什么不直接刷盘修改后的数据-而是刷盘redo-log-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">30.为什么不直接刷盘修改后的数据，而是刷盘redo log?Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-什么是binlog-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">31.什么是binlog？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_32-binlog记录格式-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">32.binlog记录格式？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_33-binlog的写入机制-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">33.binlog的写入机制？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_34-undo-log-mysql为什么不丢数据" class="router-link-active router-link-exact-active toc-link level3">34.undo log？Mysql为什么不丢数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_35-mysql的事务隔离级别有哪几种-默认的是哪一种" class="router-link-active router-link-exact-active toc-link level3">35.mysql的事务隔离级别有哪几种？默认的是哪一种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_36-解决幻读的方法" class="router-link-active router-link-exact-active toc-link level3">36.解决幻读的方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_37-一致性非锁定读和锁定读" class="router-link-active router-link-exact-active toc-link level3">37.一致性非锁定读和锁定读?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_38-sql注入问题" class="router-link-active router-link-exact-active toc-link level3">38.sql注入问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_39-什么是3nf-范式" class="router-link-active router-link-exact-active toc-link level3">39.什么是3NF（范式）?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_40-null和空串判断" class="router-link-active router-link-exact-active toc-link level3">40.NULL和空串判断?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_41-like走索引吗" class="router-link-active router-link-exact-active toc-link level3">41.like走索引吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_42-主键和唯一索引区别" class="router-link-active router-link-exact-active toc-link level3">42.主键和唯一索引区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_43-索引不生效的情况" class="router-link-active router-link-exact-active toc-link level3">43.索引不生效的情况？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_44-mvvc" class="router-link-active router-link-exact-active toc-link level3">44.MVVC？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_45-varchar-10-和int-10-代表什么含义" class="router-link-active router-link-exact-active toc-link level3">45.varchar(10)和int(10)代表什么含义？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_46-count-在不同引擎的实现方式" class="router-link-active router-link-exact-active toc-link level3">46.count(*)在不同引擎的实现方式?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_47-锁的类型有哪些呢" class="router-link-active router-link-exact-active toc-link level3">47.锁的类型有哪些呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_48-那-acid-靠什么保证的呢" class="router-link-active router-link-exact-active toc-link level3">48.那 ACID 靠什么保证的呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_49-说说-mysql-主从同步怎么做的吧" class="router-link-active router-link-exact-active toc-link level3">49.说说 mysql 主从同步怎么做的吧？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_50-解释mysql外连接、内连接与自连接的区别" class="router-link-active router-link-exact-active toc-link level3">50.解释MySQL外连接、内连接与自连接的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_51-sql语言包括哪几部分-每部分都有哪些操作关键字" class="router-link-active router-link-exact-active toc-link level3">51.SQL语言包括哪几部分？每部分都有哪些操作关键字？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_52-数据库的三范式是什么" class="router-link-active router-link-exact-active toc-link level3">52.数据库的三范式是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_53-sql优化手段有哪些" class="router-link-active router-link-exact-active toc-link level3">53.SQL优化手段有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_54-简单说一说drop、delete与truncate的区别" class="router-link-active router-link-exact-active toc-link level3">54.简单说一说drop、delete与truncate的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_55-大表如何优化" class="router-link-active router-link-exact-active toc-link level3">55.大表如何优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_56-为什么-select-count-from-table-在-innodb-比-myisam-慢" class="router-link-active router-link-exact-active toc-link level3">56.为什么 SELECT COUNT() FROM table 在 InnoDB 比 MyISAM 慢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_57-主键与索引有什么区别" class="router-link-active router-link-exact-active toc-link level3">57.主键与索引有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_58-可以使用多少列创建索引" class="router-link-active router-link-exact-active toc-link level3">58.可以使用多少列创建索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_59-mysql锁的类型有哪些" class="router-link-active router-link-exact-active toc-link level3">59.mysql锁的类型有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_60-怎么处理mysql的慢查询" class="router-link-active router-link-exact-active toc-link level3">60.怎么处理MySQL的慢查询？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_61-什么是mysql的主从复制" class="router-link-active router-link-exact-active toc-link level3">61.什么是mysql的主从复制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_62-mysql为什么需要主从同步" class="router-link-active router-link-exact-active toc-link level3">62.mysql为什么需要主从同步？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_63-innodb是如何实现事务的" class="router-link-active router-link-exact-active toc-link level3">63.Innodb是如何实现事务的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_64-b-树和-b-树的理解" class="router-link-active router-link-exact-active toc-link level3">64.b 树和 b+树的理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_65-for-update的作用和用法" class="router-link-active router-link-exact-active toc-link level3">65.for update的作用和用法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_66-如何保证-repeatable-read-级别绝对不产生幻读" class="router-link-active router-link-exact-active toc-link level3">66.如何保证 REPEATABLE READ 级别绝对不产⽣幻读？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_67-mysql的update的加锁情况" class="router-link-active router-link-exact-active toc-link level3">67.mysql的update的加锁情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_68-mysql的数据存在磁盘上到底长什么样" class="router-link-active router-link-exact-active toc-link level3">68.MySQL的数据存在磁盘上到底长什么样</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_69-为什么用了索引-sql查询还是慢" class="router-link-active router-link-exact-active toc-link level3">69.为什么用了索引，SQL查询还是慢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_70-什么是三星索引" class="router-link-active router-link-exact-active toc-link level3">70.什么是三星索引？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_71-count-1-和count-哪个效率高" class="router-link-active router-link-exact-active toc-link level3">71.count(1)和count(*) 哪个效率高？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_72-《阿里巴巴java开发手册》里面写超过三张表禁止join-这是为什么-这样的话那sql要怎么写" class="router-link-active router-link-exact-active toc-link level3">72.《阿里巴巴JAVA开发手册》里面写超过三张表禁止join 这是为什么？这样的话那sql要怎么写？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_73-什么是mysql的索引下推" class="router-link-active router-link-exact-active toc-link level3">73.什么是mysql的索引下推</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_74-mysql为什么不丢数据-mysql七种日志" class="router-link-active router-link-exact-active toc-link level3">74.mysql为什么不丢数据(mysql七种日志)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_75-百亿级数据分表后怎么分页查呢" class="router-link-active router-link-exact-active toc-link level3">75.百亿级数据分表后怎么分页查呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_76-为什么一条sql执行会慢" class="router-link-active router-link-exact-active toc-link level3">76.为什么一条sql执行会慢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_77-mysql中的锁" class="router-link-active router-link-exact-active toc-link level3">77.mysql中的锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-简单介绍一下-redis" class="router-link-active router-link-exact-active toc-link level3">1.简单介绍一下 Redis?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-redis-可以做消息队列么" class="router-link-active router-link-exact-active toc-link level3">2.Redis 可以做消息队列么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-redis-单线程模型了解吗" class="router-link-active router-link-exact-active toc-link level3">3.Redis 单线程模型了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-redis6-0-之前为什么不使用多线程" class="router-link-active router-link-exact-active toc-link level3">4.Redis6.0 之前为什么不使用多线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-redis6-0-之后为何引入了多线程" class="router-link-active router-link-exact-active toc-link level3">5.Redis6.0 之后为何引入了多线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-redis-是如何判断数据是否过期的呢" class="router-link-active router-link-exact-active toc-link level3">6.Redis 是如何判断数据是否过期的呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-过期的数据的删除策略了解么" class="router-link-active router-link-exact-active toc-link level3">7.过期的数据的删除策略了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-redis-内存淘汰机制了解么" class="router-link-active router-link-exact-active toc-link level3">8.Redis 内存淘汰机制了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-怎么保证-redis-挂掉之后再重启数据可以进行恢复" class="router-link-active router-link-exact-active toc-link level3">9.怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-什么是-rdb-持久化" class="router-link-active router-link-exact-active toc-link level3">10.什么是 RDB 持久化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-什么是-aof-持久化" class="router-link-active router-link-exact-active toc-link level3">11.什么是 AOF 持久化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-aof-重写了解吗" class="router-link-active router-link-exact-active toc-link level3">12.AOF 重写了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-redis-4-0-对于持久化机制做了什么优化" class="router-link-active router-link-exact-active toc-link level3">13.Redis 4.0 对于持久化机制做了什么优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-如何使用-redis-事务" class="router-link-active router-link-exact-active toc-link level3">14.如何使用 Redis 事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-redis-支持原子性吗" class="router-link-active router-link-exact-active toc-link level3">15.Redis 支持原子性吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-如何解决-redis-事务的缺陷" class="router-link-active router-link-exact-active toc-link level3">16.如何解决 Redis 事务的缺陷？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-什么是-bigkey" class="router-link-active router-link-exact-active toc-link level3">17.什么是 bigkey？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-bigkey-有什么危害" class="router-link-active router-link-exact-active toc-link level3">18.bigkey 有什么危害？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-大量-key-集中过期问题" class="router-link-active router-link-exact-active toc-link level3">19.大量 key 集中过期问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-什么是缓存穿透" class="router-link-active router-link-exact-active toc-link level3">20.什么是缓存穿透？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-什么是缓存雪崩" class="router-link-active router-link-exact-active toc-link level3">21.什么是缓存雪崩？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-3种常用的缓存读写策略" class="router-link-active router-link-exact-active toc-link level3">22.3种常用的缓存读写策略？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-什么是内存碎片" class="router-link-active router-link-exact-active toc-link level3">24.什么是内存碎片?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-为什么会有-redis-内存碎片" class="router-link-active router-link-exact-active toc-link level3">25.为什么会有 Redis 内存碎片?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-redis的有几种数据类型" class="router-link-active router-link-exact-active toc-link level3">26.Redis的有几种数据类型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-redis为什么快-单线程" class="router-link-active router-link-exact-active toc-link level3">27.redis为什么快？单线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-redis默认分多少个数据库" class="router-link-active router-link-exact-active toc-link level3">28.redis默认分多少个数据库？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-redis持久化的几种方式" class="router-link-active router-link-exact-active toc-link level3">29.redis持久化的几种方式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-rdb的优点" class="router-link-active router-link-exact-active toc-link level3">30.RDB的优点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-rdb的缺点" class="router-link-active router-link-exact-active toc-link level3">31.RDB的缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_32-aof持久化" class="router-link-active router-link-exact-active toc-link level3">32.AOF持久化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_33-aof工作流程" class="router-link-active router-link-exact-active toc-link level3">33.AOF工作流程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_34-为什么aof要先把命令追加到缓存区-aof-buf-中" class="router-link-active router-link-exact-active toc-link level3">34.为什么AOF要先把命令追加到缓存区(aof_buf)中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_35-aof优点" class="router-link-active router-link-exact-active toc-link level3">35.AOF优点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_36-aof缺点" class="router-link-active router-link-exact-active toc-link level3">36.AOF缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_37-混合持久化-优缺点" class="router-link-active router-link-exact-active toc-link level3">37.混合持久化？优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_38-redis-cluster槽范围" class="router-link-active router-link-exact-active toc-link level3">38.Redis Cluster槽范围？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_39-什么是缓存预热" class="router-link-active router-link-exact-active toc-link level3">39.什么是缓存预热？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_40-redis-的同步机制了解是什么" class="router-link-active router-link-exact-active toc-link level3">40.Redis 的同步机制了解是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_41-怎么使用redis实现消息队列" class="router-link-active router-link-exact-active toc-link level3">41.怎么使用Redis实现消息队列？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_42-是否使用过redis-cluster集群-集群的原理是什么" class="router-link-active router-link-exact-active toc-link level3">42.是否使用过Redis Cluster集群，集群的原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_43-redis-集群架构模式有哪几种" class="router-link-active router-link-exact-active toc-link level3">43.Redis 集群架构模式有哪几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_44-说说-redis-哈希槽的概念" class="router-link-active router-link-exact-active toc-link level3">44.说说 Redis 哈希槽的概念？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_45-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某-个固定的已知的前缀开头的-如果将它们全部找出来" class="router-link-active router-link-exact-active toc-link level3">45.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_46-redis-主从复制的核心原理" class="router-link-active router-link-exact-active toc-link level3">46.Redis 主从复制的核⼼原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-什么是-spring-框架" class="router-link-active router-link-exact-active toc-link level3">1.什么是 Spring 框架?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-列举一些重要的-spring-模块" class="router-link-active router-link-exact-active toc-link level3">2.列举一些重要的 Spring 模块？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-spring-spring-mvc-spring-boot-之间什么关系" class="router-link-active router-link-exact-active toc-link level3">3.Spring,Spring MVC,Spring Boot 之间什么关系?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-谈谈自己对于-spring-ioc-的了解" class="router-link-active router-link-exact-active toc-link level3">4.谈谈自己对于 Spring IoC 的了解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-谈谈自己对于-aop-的了解" class="router-link-active router-link-exact-active toc-link level3">5.谈谈自己对于 AOP 的了解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-spring-aop-和-aspectj-aop-有什么区别" class="router-link-active router-link-exact-active toc-link level3">6.Spring AOP 和 AspectJ AOP 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-什么是-spring-bean" class="router-link-active router-link-exact-active toc-link level3">7.什么是 Spring Bean？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-将一个类声明为-bean-的注解有哪些" class="router-link-active router-link-exact-active toc-link level3">8.将一个类声明为 Bean 的注解有哪些?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-component-和-bean-的区别是什么" class="router-link-active router-link-exact-active toc-link level3">9.@Component 和 @Bean 的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-注入-bean-的注解有哪些" class="router-link-active router-link-exact-active toc-link level3">10.注入 Bean 的注解有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-bean-的作用域有哪些" class="router-link-active router-link-exact-active toc-link level3">11.Bean 的作用域有哪些?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-单例-bean-的线程安全问题了解吗" class="router-link-active router-link-exact-active toc-link level3">12.单例 Bean 的线程安全问题了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-bean-的生命周期了解么" class="router-link-active router-link-exact-active toc-link level3">13.Bean 的生命周期了解么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-说说自己对于-spring-mvc-了解" class="router-link-active router-link-exact-active toc-link level3">14.说说自己对于 Spring MVC 了解?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-springmvc-工作原理了解吗" class="router-link-active router-link-exact-active toc-link level3">15.SpringMVC 工作原理了解吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-spring-框架中用到了哪些设计模式" class="router-link-active router-link-exact-active toc-link level3">16.Spring 框架中用到了哪些设计模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-spring-管理事务的方式有几种" class="router-link-active router-link-exact-active toc-link level3">17.Spring 管理事务的方式有几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-spring-事务中哪几种事务传播行为" class="router-link-active router-link-exact-active toc-link level3">18.Spring 事务中哪几种事务传播行为?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-spring-事务中的隔离级别有哪几种" class="router-link-active router-link-exact-active toc-link level3">19.Spring 事务中的隔离级别有哪几种?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-transactional-rollbackfor-exception-class-注解了解吗" class="router-link-active router-link-exact-active toc-link level3">20.@Transactional(rollbackFor = Exception.class)注解了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-springboot的优缺点" class="router-link-active router-link-exact-active toc-link level3">21.springboot的优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-简单介绍一下-springbootapplication注解" class="router-link-active router-link-exact-active toc-link level3">22.简单介绍一下@SpringbootApplication注解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-springboot自动装配原理" class="router-link-active router-link-exact-active toc-link level3">23.springboot自动装配原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-transactional-的使用注意事项总结" class="router-link-active router-link-exact-active toc-link level3">24.@Transactional 的使用注意事项总结？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-spring-框架中用到了哪些设计模式" class="router-link-active router-link-exact-active toc-link level3">25.Spring 框架中用到了哪些设计模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-ioc注入哪几种方式" class="router-link-active router-link-exact-active toc-link level3">26.IOC注入哪几种方式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-什么是aop-面向切面编程" class="router-link-active router-link-exact-active toc-link level3">27.什么是AOP(面向切面编程)？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-切面有几种类型的通知-分别是" class="router-link-active router-link-exact-active toc-link level3">28.切面有几种类型的通知？分别是？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-什么是连接点-join-point" class="router-link-active router-link-exact-active toc-link level3">29.什么是连接点 （Join point)?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-什么是切点-pointcut" class="router-link-active router-link-exact-active toc-link level3">30.什么是切点（Pointcut)?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-什么是切面-aspect" class="router-link-active router-link-exact-active toc-link level3">31.什么是切面(Aspect)?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_32-织入-weaving" class="router-link-active router-link-exact-active toc-link level3">32.织入(Weaving)?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_33-在目标对象的生命周期里有多个点可以进行织入" class="router-link-active router-link-exact-active toc-link level3">33.在目标对象的生命周期里有多个点可以进行织入？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_34-aop动态代理策略" class="router-link-active router-link-exact-active toc-link level3">34.AOP动态代理策略？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_35-springmvc的几个组件" class="router-link-active router-link-exact-active toc-link level3">35.SpringMVC的几个组件？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_36-beanfactory-和-applicationcontext区别" class="router-link-active router-link-exact-active toc-link level3">36.BeanFactory 和 ApplicationContext区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_37-qualifier注解" class="router-link-active router-link-exact-active toc-link level3">37.@Qualifier注解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_38-application-properties和application-yml文件可放位置-优先级" class="router-link-active router-link-exact-active toc-link level3">38.application.properties和application.yml文件可放位置?优先级?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_39-bootstrap-yml-和application-yml" class="router-link-active router-link-exact-active toc-link level3">39.bootstrap.yml 和application.yml?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_40-在spring-aop-中-关注点和横切关注的区别是什么" class="router-link-active router-link-exact-active toc-link level3">40.在Spring AOP 中，关注点和横切关注的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_41-spring-是怎么解决循环依赖的" class="router-link-active router-link-exact-active toc-link level3">41.Spring 是怎么解决循环依赖的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_42-事务三要素是什么" class="router-link-active router-link-exact-active toc-link level3">42.事务三要素是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_43-事务注解的本质是什么" class="router-link-active router-link-exact-active toc-link level3">43.事务注解的本质是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_44-如何在spring-boot启动的时候运行一些特定的代码" class="router-link-active router-link-exact-active toc-link level3">44.如何在Spring Boot启动的时候运行一些特定的代码？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_45-如何实现一个ioc容器" class="router-link-active router-link-exact-active toc-link level3">45.如何实现一个IOC容器?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_46-什么的是bean的自动装配" class="router-link-active router-link-exact-active toc-link level3">46.什么的是bean的自动装配</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_47-springboot自动配置原理是什么" class="router-link-active router-link-exact-active toc-link level3">47.springboot自动配置原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_48-什么是嵌入式服务器-为什么使用嵌入式服务器" class="router-link-active router-link-exact-active toc-link level3">48.什么是嵌入式服务器，为什么使用嵌入式服务器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_49-spring中的事务是如何实现的" class="router-link-active router-link-exact-active toc-link level3">49.Spring中的事务是如何实现的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_50-spring启动流程" class="router-link-active router-link-exact-active toc-link level3">50.Spring启动流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_51-spring-boot中配置文件的加载顺序是怎样的" class="router-link-active router-link-exact-active toc-link level3">51.Spring Boot中配置⽂件的加载顺序是怎样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_52-延迟加载" class="router-link-active router-link-exact-active toc-link level3">52.延迟加载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_53-restcontroller-和-controller-有什么区别" class="router-link-active router-link-exact-active toc-link level3">53.@RestController 和 @Controller 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_54-requestmapping-注解有什么用" class="router-link-active router-link-exact-active toc-link level3">54.@RequestMapping 注解有什么用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_55-requestmapping-和-getmapping-注解的不同之处在哪里" class="router-link-active router-link-exact-active toc-link level3">55.@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_56-spring-中有哪些方式可以把-bean-注入-到-ioc-容器" class="router-link-active router-link-exact-active toc-link level3">56.Spring 中有哪些方式可以把 Bean 注入 到 IOC 容器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_57-spring-中-beanfactory-和-factorybean-的区别" class="router-link-active router-link-exact-active toc-link level3">57.Spring 中 BeanFactory 和 FactoryBean 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_58-介绍下-spring-ioc-的工作流程" class="router-link-active router-link-exact-active toc-link level3">58.介绍下 Spring IoC 的工作流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_59-过滤器、拦截器、aop的区别" class="router-link-active router-link-exact-active toc-link level3">59.过滤器、拦截器、AOP的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_60-什么情况下会导致-async异步方法会失效" class="router-link-active router-link-exact-active toc-link level3">60.什么情况下会导致@Async异步方法会失效？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_61-spring与springboot默认aop采用" class="router-link-active router-link-exact-active toc-link level3">61.spring与springboot默认aop采用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_62-介绍下spring的初始化过程" class="router-link-active router-link-exact-active toc-link level3">62.介绍下Spring的初始化过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_63-配置文件的加载解析" class="router-link-active router-link-exact-active toc-link level3">63.配置文件的加载解析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_64-介绍下spring中常用的注解" class="router-link-active router-link-exact-active toc-link level3">64.介绍下Spring中常用的注解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_65-springboot-的自动装配原理" class="router-link-active router-link-exact-active toc-link level3">65.SpringBoot 的自动装配原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_66-介绍下springboot的启动流程" class="router-link-active router-link-exact-active toc-link level3">66.介绍下SpringBoot的启动流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_67-spring-只处理单例模式下得循环依赖" class="router-link-active router-link-exact-active toc-link level3">67.Spring 只处理单例模式下得循环依赖?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_68-last-modified缓存机制" class="router-link-active router-link-exact-active toc-link level3">68.Last-Modified缓存机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-为什么要用消息队列" class="router-link-active router-link-exact-active toc-link level3">1.为什么要用消息队列？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-使用消息队列带来的一些问题" class="router-link-active router-link-exact-active toc-link level3">2.使用消息队列带来的一些问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-什么是jms" class="router-link-active router-link-exact-active toc-link level3">3.什么是JMS ？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-jms-两种消息模型" class="router-link-active router-link-exact-active toc-link level3">4.JMS 两种消息模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-jms-五种不同的消息正文格式" class="router-link-active router-link-exact-active toc-link level3">5.JMS 五种不同的消息正文格式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-什么是amqp" class="router-link-active router-link-exact-active toc-link level3">6.什么是AMQP？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-jms-vs-amqp" class="router-link-active router-link-exact-active toc-link level3">7.JMS vs AMQP</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-什么是producer、consumer、broker、topic、partition" class="router-link-active router-link-exact-active toc-link level3">8.什么是Producer、Consumer、Broker、Topic、Partition？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-kafka-的多副本机制了解吗-带来了什么好处" class="router-link-active router-link-exact-active toc-link level3">9.Kafka 的多副本机制了解吗？带来了什么好处？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-kafka-如何保证消息的消费顺序" class="router-link-active router-link-exact-active toc-link level3">10.Kafka 如何保证消息的消费顺序？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-kafka-如何保证消息不丢失" class="router-link-active router-link-exact-active toc-link level3">11.Kafka 如何保证消息不丢失？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-kafka-如何保证消息不重复消费" class="router-link-active router-link-exact-active toc-link level3">12.Kafka 如何保证消息不重复消费？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-rabbitmq-核心概念" class="router-link-active router-link-exact-active toc-link level3">13.RabbitMQ 核心概念？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-rocketmq事务消息流程" class="router-link-active router-link-exact-active toc-link level3">14.RocketMq事务消息流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-rabbitmq如何确保消息发送和消息接收" class="router-link-active router-link-exact-active toc-link level3">15.RabbitMQ如何确保消息发送和消息接收</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-rabbitmq死信队列、延时队列分别是什么" class="router-link-active router-link-exact-active toc-link level3">16.RabbitMQ死信队列、延时队列分别是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-简述kafka架构设计是什么样" class="router-link-active router-link-exact-active toc-link level3">17.简述kafka架构设计是什么样？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-kafka消息丢失的场景有哪些" class="router-link-active router-link-exact-active toc-link level3">18.Kafka消息丢失的场景有哪些</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-kafka的ack机制" class="router-link-active router-link-exact-active toc-link level3">19.kafka的ACK机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-offset机制" class="router-link-active router-link-exact-active toc-link level3">20.Offset机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-kafka是pull-push-以及优劣势分析" class="router-link-active router-link-exact-active toc-link level3">21.Kafka是pull？push？以及优劣势分析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-kafka的rebalance机制是什么" class="router-link-active router-link-exact-active toc-link level3">22.kafka的rebalance机制是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-kafka的消费者如何消费数据" class="router-link-active router-link-exact-active toc-link level3">23.Kafka的消费者如何消费数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-rocketmq的实现原理" class="router-link-active router-link-exact-active toc-link level3">24.RocketMQ的实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-rocketmq为什么速度快" class="router-link-active router-link-exact-active toc-link level3">25.RocketMQ为什么速度快</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-消息队列如何保证消息可靠传输" class="router-link-active router-link-exact-active toc-link level3">26.消息队列如何保证消息可靠传输</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-消息队列有哪些作用" class="router-link-active router-link-exact-active toc-link level3">27.消息队列有哪些作⽤</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-如何保证消息的高效读写" class="router-link-active router-link-exact-active toc-link level3">28.如何保证消息的⾼效读写？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-如何确保消息不丢失" class="router-link-active router-link-exact-active toc-link level3">29.如何确保消息不丢失</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-如何检测消息丢失" class="router-link-active router-link-exact-active toc-link level3">30.如何检测消息丢失</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-mq怎么解决重复消费的问题" class="router-link-active router-link-exact-active toc-link level3">31.MQ怎么解决重复消费的问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_32-mq消息积压怎么解决" class="router-link-active router-link-exact-active toc-link level3">32.MQ消息积压怎么解决</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_33-rocketmq如何保证顺序消费" class="router-link-active router-link-exact-active toc-link level3">33.rocketMq如何保证顺序消费</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_34-rocketmq如何保证消息不丢失" class="router-link-active router-link-exact-active toc-link level3">34.rocketMq如何保证消息不丢失</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_35-partition的数据文件-offffset-messagesize-data" class="router-link-active router-link-exact-active toc-link level3">35.partition的数据文件（offffset，MessageSize，data）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_36-kafka-中的isr-insyncrepli-、osr-outsyncrepli-、ar-allrepli-代表什么" class="router-link-active router-link-exact-active toc-link level3">36.Kafka 中的ISR(InSyncRepli)、OSR(OutSyncRepli)、AR(AllRepli)代表什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_37-kafka的那些设计让它有如此高的性能" class="router-link-active router-link-exact-active toc-link level3">37.Kafka的那些设计让它有如此高的性能?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_38-rocketmq如何保证高可用" class="router-link-active router-link-exact-active toc-link level3">38.rocketMq如何保证高可用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_39-rocketmq消费者消费模式有几种" class="router-link-active router-link-exact-active toc-link level3">39.RocketMq消费者消费模式有几种</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_40-rocketmq延迟消息-如何实现的" class="router-link-active router-link-exact-active toc-link level3">40.RocketMq延迟消息？如何实现的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_41-rocketmq是推模型还是拉模型" class="router-link-active router-link-exact-active toc-link level3">41.RocketMq是推模型还是拉模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_42-kafka-的零拷贝原理" class="router-link-active router-link-exact-active toc-link level3">42.kafka 的零拷贝原理?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-为什需要websocket" class="router-link-active router-link-exact-active toc-link level3">1. 为什需要websocket</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-什么是websocket" class="router-link-active router-link-exact-active toc-link level3">2.什么是websocket</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-websocket如何从http协议转化为websocket协议" class="router-link-active router-link-exact-active toc-link level3">3.WebSocket如何从HTTP协议转化为WebSocket协议？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-websocket为什么依赖于http连接" class="router-link-active router-link-exact-active toc-link level3">4.WebSocket为什么依赖于HTTP连接</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-如何保证消息一定送达给用户" class="router-link-active router-link-exact-active toc-link level3">5.如何保证消息一定送达给用户</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-bio-是什么" class="router-link-active router-link-exact-active toc-link level3">6.BIO 是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-nio-是什么" class="router-link-active router-link-exact-active toc-link level3">7.NIO 是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-bio、nio-有什么区别" class="router-link-active router-link-exact-active toc-link level3">8.BIO、NIO 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-aio-是什么" class="router-link-active router-link-exact-active toc-link level3">9.AIO 是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-direct-buffer-和-non-direct-buffer-的区别" class="router-link-active router-link-exact-active toc-link level3">10.Direct Buffer 和 Non-Direct Buffer 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-elasticsearch-的倒排索引是什么" class="router-link-active router-link-exact-active toc-link level3">1.elasticsearch 的倒排索引是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-elasticsearch-的-master-选举流程" class="router-link-active router-link-exact-active toc-link level3">2.Elasticsearch 的 master 选举流程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-为什么要使用-elasticsearch" class="router-link-active router-link-exact-active toc-link level3">3.为什么要使用 Elasticsearch?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-elasticsearch-集群脑裂问题" class="router-link-active router-link-exact-active toc-link level3">4.Elasticsearch 集群脑裂问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-elasticsearch-索引文档的流程" class="router-link-active router-link-exact-active toc-link level3">5.Elasticsearch 索引文档的流程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-elasticsearch-更新和删除文档的流程" class="router-link-active router-link-exact-active toc-link level3">6.Elasticsearch 更新和删除文档的流程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-elasticsearch-搜索的流程" class="router-link-active router-link-exact-active toc-link level3">7.Elasticsearch 搜索的流程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-在并发情况下-elasticsearch-如果保证读写一致" class="router-link-active router-link-exact-active toc-link level3">8.在并发情况下，Elasticsearch 如果保证读写一致？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-elasticsearch-中的集群、节点、索引、文档、类型是什么" class="router-link-active router-link-exact-active toc-link level3">9.Elasticsearch 中的集群、节点、索引、文档、类型是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-说说分段存储的思想" class="router-link-active router-link-exact-active toc-link level3">10.说说分段存储的思想</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-谈谈你对段合并的策略思想的认识" class="router-link-active router-link-exact-active toc-link level3">11.谈谈你对段合并的策略思想的认识</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-熟悉elasticsearch-性能优化" class="router-link-active router-link-exact-active toc-link level3">12.熟悉ElasticSearch 性能优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-node一般设置几个分片" class="router-link-active router-link-exact-active toc-link level3">13.node一般设置几个分片？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-什么是mongodb" class="router-link-active router-link-exact-active toc-link level3">1.什么是MongoDB</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-mongodb的优势有哪些" class="router-link-active router-link-exact-active toc-link level3">2.MongoDB的优势有哪些</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-什么是集合-表" class="router-link-active router-link-exact-active toc-link level3">3.什么是集合(表)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-什么是文档-记录" class="router-link-active router-link-exact-active toc-link level3">4.什么是文档(记录)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-什么是非关系型数据库" class="router-link-active router-link-exact-active toc-link level3">5.什么是非关系型数据库</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-为什么用mongodb" class="router-link-active router-link-exact-active toc-link level3">6.为什么用MongoDB</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-在哪些场景使用mongodb" class="router-link-active router-link-exact-active toc-link level3">7.在哪些场景使用MongoDB</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-mongodb中的命名空间是什么意思" class="router-link-active router-link-exact-active toc-link level3">8.MongoDB中的命名空间是什么意思?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-monogodb-中的分片什么意思" class="router-link-active router-link-exact-active toc-link level3">9.monogodb 中的分片什么意思</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-为什么要在mongodb中使用分析器" class="router-link-active router-link-exact-active toc-link level3">10.为什么要在MongoDB中使用分析器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-mongodb支持主键外键关系吗" class="router-link-active router-link-exact-active toc-link level3">11.MongoDB支持主键外键关系吗</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-mongodb支持哪些数据类型" class="router-link-active router-link-exact-active toc-link level3">12.MongoDB支持哪些数据类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-在mongodb中什么是副本集" class="router-link-active router-link-exact-active toc-link level3">13.在MongoDB中什么是副本集</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-何为-rpc" class="router-link-active router-link-exact-active toc-link level3">1.何为 RPC?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-rpc-的原理是什么" class="router-link-active router-link-exact-active toc-link level3">2.RPC 的原理是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-有哪些常见的-rpc-框架" class="router-link-active router-link-exact-active toc-link level3">3.有哪些常见的 RPC 框架？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-什么是-dubbo" class="router-link-active router-link-exact-active toc-link level3">4.什么是 Dubbo?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-为什么要用-dubbo" class="router-link-active router-link-exact-active toc-link level3">5.为什么要用 Dubbo?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-什么是分布式" class="router-link-active router-link-exact-active toc-link level3">6.什么是分布式?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-dubbo-架构中的核心角色有哪些" class="router-link-active router-link-exact-active toc-link level3">7.Dubbo 架构中的核心角色有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-dubbo-中的-invoker-概念了解么" class="router-link-active router-link-exact-active toc-link level3">8.Dubbo 中的 Invoker 概念了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-dubbo-的工作原理了解么" class="router-link-active router-link-exact-active toc-link level3">9.Dubbo 的工作原理了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-dubbo-的-spi-机制了解么-如何扩展-dubbo-中的默认实现" class="router-link-active router-link-exact-active toc-link level3">10.Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-dubbo-的微内核架构了解吗" class="router-link-active router-link-exact-active toc-link level3">11.Dubbo 的微内核架构了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-dubbo-提供的负载均衡策略有哪些" class="router-link-active router-link-exact-active toc-link level3">12.Dubbo 提供的负载均衡策略有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-说一下dubbo服务注册流程" class="router-link-active router-link-exact-active toc-link level3">13.说一下Dubbo服务注册流程?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-怎么实现动态感知服务下线的呢" class="router-link-active router-link-exact-active toc-link level3">14.怎么实现动态感知服务下线的呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-dubbo-容错策略" class="router-link-active router-link-exact-active toc-link level3">15.Dubbo 容错策略?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-dubbo-框架源码最重要的设计原则是什么" class="router-link-active router-link-exact-active toc-link level3">16.Dubbo 框架源码最重要的设计原则是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-dubbo-官方给出了四大组件的概念-请谈一下你对它们的认识。" class="router-link-active router-link-exact-active toc-link level3">17.Dubbo 官方给出了四大组件的概念，请谈一下你对它们的认识。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-什么是-spi-请简单描述一下-spi-要解决的问题。" class="router-link-active router-link-exact-active toc-link level3">18.什么是 SPI？请简单描述一下 SPI 要解决的问题。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-jdk-的-spi-机制存在什么问题" class="router-link-active router-link-exact-active toc-link level3">19.JDK 的 SPI 机制存在什么问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-dubbo-框架的-adaptive-类都有哪些-adaptive-类与-adaptive-方法的区别是什么-或者说-各自的应用场景有什么不同" class="router-link-active router-link-exact-active toc-link level3">20.Dubbo 框架的 Adaptive 类都有哪些？Adaptive 类与 Adaptive 方法的区别是什么？ 或者说，各自的应用场景有什么不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-简述-dubbo-的-wrapper-机制" class="router-link-active router-link-exact-active toc-link level3">21.简述 Dubbo 的 Wrapper 机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-dubbo-的-wrapper-类是否属于扩展类" class="router-link-active router-link-exact-active toc-link level3">22.Dubbo 的 Wrapper 类是否属于扩展类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-简述-dubbo-的-active-机制" class="router-link-active router-link-exact-active toc-link level3">23.简述 Dubbo 的 Active 机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-dubbo-的-activate-类是否属于扩展类" class="router-link-active router-link-exact-active toc-link level3">24.Dubbo 的 Activate 类是否属于扩展类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-请对-dubbo-的普通扩展类、adaptive-类、wrapper-类-及-activate-类的实现方式、-个数-及是否属于扩展类等进行一个总结。" class="router-link-active router-link-exact-active toc-link level3">25.请对 Dubbo 的普通扩展类、Adaptive 类、Wrapper 类，及 Activate 类的实现方式、 个数，及是否属于扩展类等进行一个总结。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-简述-dubbo-的-extensionloader-实例的组成。" class="router-link-active router-link-exact-active toc-link level3">26.简述 Dubbo 的 ExtensionLoader 实例的组成。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-dubbo-在查找指定扩展类时-其会查找哪些目录中的扩展类配置文件-对于这些目录中的配置文件-其是查找了所有这些目录-在一个目录中找到了就不再找其它目录了-其是仅加载了这一个扩展类还是加载了全部该-spi-的所有扩展类" class="router-link-active router-link-exact-active toc-link level3">27.Dubbo 在查找指定扩展类时，其会查找哪些目录中的扩展类配置文件？对于这些目录中的配置文件，其是查找了所有这些目录，在一个目录中找到了就不再找其它目录了？ 其是仅加载了这一个扩展类还是加载了全部该 SPI 的所有扩展类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-dubbo-源码中是如何判断一个类是否是-wrapper-类的" class="router-link-active router-link-exact-active toc-link level3">28.Dubbo 源码中是如何判断一个类是否是 Wrapper 类的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-从-dubbo-源码中可以看出-一个-spi-接口的实现类有什么要求" class="router-link-active router-link-exact-active toc-link level3">29.从 Dubbo 源码中可以看出，一个 SPI 接口的实现类有什么要求？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-extensionloader-实例中包含一个-extensionfactory-实例-objectfactory-该实例用于-创建指定扩展名的扩展类实例-简述-objectfactory-创建扩展类实例的过程。" class="router-link-active router-link-exact-active toc-link level3">30.ExtensionLoader 实例中包含一个 ExtensionFactory 实例 objectFactory，该实例用于 创建指定扩展名的扩展类实例，简述 objectFactory 创建扩展类实例的过程。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-请简述一个指定功能性扩展名的扩展类实例的创建、setter-及-wrapper-的顺序与过-程" class="router-link-active router-link-exact-active toc-link level3">31.请简述一个指定功能性扩展名的扩展类实例的创建、setter 及 wrapper 的顺序与过 程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-seata-at模式原理流程" class="router-link-active router-link-exact-active toc-link level3">1.Seata AT模式原理流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-什么是sentinel" class="router-link-active router-link-exact-active toc-link level3">1.什么是sentinel？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-sentinel和hystrix有何区别" class="router-link-active router-link-exact-active toc-link level3">2.sentinel和Hystrix有何区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-流量控制如何配置" class="router-link-active router-link-exact-active toc-link level3">3.流量控制如何配置？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-三种流控效果" class="router-link-active router-link-exact-active toc-link level3">4.三种流控效果</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-三种流控模式" class="router-link-active router-link-exact-active toc-link level3">5. 三种流控模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-两种统计类型" class="router-link-active router-link-exact-active toc-link level3">6.两种统计类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-降级规则如何配置" class="router-link-active router-link-exact-active toc-link level3">7.降级规则如何配置？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-三种熔断策略" class="router-link-active router-link-exact-active toc-link level3">8.三种熔断策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-热点参数如何限流" class="router-link-active router-link-exact-active toc-link level3">9.热点参数如何限流？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-系统自适应如何限流" class="router-link-active router-link-exact-active toc-link level3">10.系统自适应如何限流？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-eureka-server-数据存储" class="router-link-active router-link-exact-active toc-link level3">1.Eureka Server 数据存储</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-什么是cap理论" class="router-link-active router-link-exact-active toc-link level3">1.什么是CAP理论？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-什么是网络分区" class="router-link-active router-link-exact-active toc-link level3">2.什么是网络分区？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-不是所谓的-3-选-2" class="router-link-active router-link-exact-active toc-link level3">3.不是所谓的“3 选 2”？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-base-理论" class="router-link-active router-link-exact-active toc-link level3">4.BASE 理论？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-base-理论三要素" class="router-link-active router-link-exact-active toc-link level3">5.BASE 理论三要素？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-paxos算法" class="router-link-active router-link-exact-active toc-link level3">6.Paxos算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-分布式幂等性如何设计" class="router-link-active router-link-exact-active toc-link level3">6.分布式幂等性如何设计？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-简单一次完整的-http-请求所经历的步骤" class="router-link-active router-link-exact-active toc-link level3">7.简单一次完整的 HTTP 请求所经历的步骤？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-你知道哪些分布式事务解决方案" class="router-link-active router-link-exact-active toc-link level3">8.你知道哪些分布式事务解决方案？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-什么是二阶段提交" class="router-link-active router-link-exact-active toc-link level3">9.什么是二阶段提交？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-什么是三阶段提交" class="router-link-active router-link-exact-active toc-link level3">10.什么是三阶段提交？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-什么是补偿事务" class="router-link-active router-link-exact-active toc-link level3">11.什么是补偿事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-消息队列是怎么实现事务的" class="router-link-active router-link-exact-active toc-link level3">12.消息队列是怎么实现事务的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-你知道哪些限流算法" class="router-link-active router-link-exact-active toc-link level3">13.你知道哪些限流算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-说说什么是计数器-固定窗口-算法" class="router-link-active router-link-exact-active toc-link level3">14.说说什么是计数器（固定窗口）算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-说说什么是滑动窗口算法" class="router-link-active router-link-exact-active toc-link level3">15.说说什么是滑动窗口算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-说说什么是漏桶算法" class="router-link-active router-link-exact-active toc-link level3">16.说说什么是漏桶算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-说说什么是令牌桶算法" class="router-link-active router-link-exact-active toc-link level3">17.说说什么是令牌桶算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-分布式id生成方案有哪些" class="router-link-active router-link-exact-active toc-link level3">18.分布式id生成方案有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_19-雪花算法生成的id由哪些部分组成" class="router-link-active router-link-exact-active toc-link level3">19.雪花算法生成的ID由哪些部分组成?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_20-分布锁有哪些解决方案" class="router-link-active router-link-exact-active toc-link level3">20.分布锁有哪些解决方案？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_21-redis做分布式锁用什么命令" class="router-link-active router-link-exact-active toc-link level3">21.Redis做分布式锁用什么命令？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_22-redis做分布式锁死锁有哪些情况-如何解决" class="router-link-active router-link-exact-active toc-link level3">22.Redis做分布式锁死锁有哪些情况，如何解决？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_23-你设计微服务时遵循什么原则" class="router-link-active router-link-exact-active toc-link level3">23.你设计微服务时遵循什么原则？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_24-cookie-和-session-有什么区别-如何使用session进行身份验证" class="router-link-active router-link-exact-active toc-link level3">24.Cookie 和 Session 有什么区别？如何使用Session进行身份验证？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_25-为什么cookie-无法防止csrf攻击-而token可以" class="router-link-active router-link-exact-active toc-link level3">25.为什么Cookie 无法防止CSRF攻击，而token可以？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_26-什么是-token-什么是-jwt-如何基于token进行身份验证" class="router-link-active router-link-exact-active toc-link level3">26.什么是 Token?什么是 JWT?如何基于Token进行身份验证？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_27-springcloud核心组件有哪些" class="router-link-active router-link-exact-active toc-link level3">27.springcloud核心组件有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_28-分布式锁的使用场景是什么-有哪些实现方案" class="router-link-active router-link-exact-active toc-link level3">28.分布式锁的使⽤场景是什么？有哪些实现⽅案？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_29-如果没有cookie-session还能进行身份验证吗" class="router-link-active router-link-exact-active toc-link level3">29.如果没有Cookie,Session还能进⾏身份验证吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_30-什么是oauth2-0协议-有哪几种认证方式" class="router-link-active router-link-exact-active toc-link level3">30.什么是OAuth2.0协议？有哪⼏种认证⽅式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_31-什么是sso-与oauth2-0有什么关系" class="router-link-active router-link-exact-active toc-link level3">31.什么是SSO？与OAuth2.0有什么关系？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_32-epoll和poll的区别" class="router-link-active router-link-exact-active toc-link level3">32.epoll和poll的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_33-谈谈你对seata的理解" class="router-link-active router-link-exact-active toc-link level3">33.谈谈你对seata的理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_34-什么是数据一致性" class="router-link-active router-link-exact-active toc-link level3">34.什么是数据⼀致性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-面向对象编程中-都有哪些设计原则" class="router-link-active router-link-exact-active toc-link level3">1.面向对象编程中，都有哪些设计原则</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-设计模式的分类" class="router-link-active router-link-exact-active toc-link level3">2.设计模式的分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-你知道哪些设计模式" class="router-link-active router-link-exact-active toc-link level3">3.你知道哪些设计模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-什么是nginx" class="router-link-active router-link-exact-active toc-link level3">1.什么是Nginx？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-nginx-有哪些优点" class="router-link-active router-link-exact-active toc-link level3">2.Nginx 有哪些优点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-nginx应用场景" class="router-link-active router-link-exact-active toc-link level3">3.Nginx应用场景？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-nginx怎么处理请求的" class="router-link-active router-link-exact-active toc-link level3">4.Nginx怎么处理请求的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-什么是正向代理" class="router-link-active router-link-exact-active toc-link level3">5.什么是正向代理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-什么是反向代理" class="router-link-active router-link-exact-active toc-link level3">6.什么是反向代理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-反向代理服务器的优点是什么" class="router-link-active router-link-exact-active toc-link level3">7.反向代理服务器的优点是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-nginx负载均衡的算法怎么实现的-策略有哪些" class="router-link-active router-link-exact-active toc-link level3">8.Nginx负载均衡的算法怎么实现的?策略有哪些?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-限流怎么做的" class="router-link-active router-link-exact-active toc-link level3">9.限流怎么做的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-生产中如何设置worker进程的数量呢" class="router-link-active router-link-exact-active toc-link level3">10.生产中如何设置worker进程的数量呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-nginx-如何开启压缩" class="router-link-active router-link-exact-active toc-link level3">11.Nginx 如何开启压缩？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-请解释nginx服务器上的master和worker进程分别是什么" class="router-link-active router-link-exact-active toc-link level3">12.请解释Nginx服务器上的Master和Worker进程分别是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-应用层有哪些常见的协议" class="router-link-active router-link-exact-active toc-link level3">1.应用层有哪些常见的协议？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-tcp-三次握手和四次挥手" class="router-link-active router-link-exact-active toc-link level3">2.TCP 三次握手和四次挥手？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-tcp-udp-协议的区别" class="router-link-active router-link-exact-active toc-link level3">3.TCP, UDP 协议的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-tcp-如何保证可靠性" class="router-link-active router-link-exact-active toc-link level3">4.TCP 如何保证可靠性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-osi-七层模型" class="router-link-active router-link-exact-active toc-link level3">5.OSI 七层模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-tcp-ip-四层模型" class="router-link-active router-link-exact-active toc-link level3">6.TCP/IP 四层模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-为什么网络要分层" class="router-link-active router-link-exact-active toc-link level3">7.为什么网络要分层？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-http-协议介绍" class="router-link-active router-link-exact-active toc-link level3">8.HTTP 协议介绍?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-http-协议通信过程" class="router-link-active router-link-exact-active toc-link level3">9.HTTP 协议通信过程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-http-协议优点" class="router-link-active router-link-exact-active toc-link level3">10.HTTP 协议优点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-https-协议介绍" class="router-link-active router-link-exact-active toc-link level3">11.HTTPS 协议介绍？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-https-协议优点" class="router-link-active router-link-exact-active toc-link level3">12.HTTPS 协议优点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-ssl-tls-的工作原理" class="router-link-active router-link-exact-active toc-link level3">13.SSL/TLS 的工作原理?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-http与https区别" class="router-link-active router-link-exact-active toc-link level3">14.HTTP与HTTPS区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-forward-和-redirect-的区别" class="router-link-active router-link-exact-active toc-link level3">15.Forward 和 Redirect 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-说一下http的长连接与短连接的区别" class="router-link-active router-link-exact-active toc-link level3">16.说一下HTTP的长连接与短连接的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-什么是操作系统" class="router-link-active router-link-exact-active toc-link level3">1.什么是操作系统？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-什么是系统调用呢" class="router-link-active router-link-exact-active toc-link level3">2.什么是系统调用呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-操作系统的内存管理主要是做什么" class="router-link-active router-link-exact-active toc-link level3">3.操作系统的内存管理主要是做什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-操作系统的内存管理机制了解吗-内存管理有哪几种方式" class="router-link-active router-link-exact-active toc-link level3">4.操作系统的内存管理机制了解吗？内存管理有哪几种方式?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_1-和-的区别是什么" class="router-link-active router-link-exact-active toc-link level3">1.#{}和${}的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签" class="router-link-active router-link-exact-active toc-link level3">2.Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" class="router-link-active router-link-exact-active toc-link level3">3.通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_4-mybatis-是如何进行分页的-分页插件的原理是什么" class="router-link-active router-link-exact-active toc-link level3">4.MyBatis 是如何进行分页的？分页插件的原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_5-说说mybatis的缓存机制" class="router-link-active router-link-exact-active toc-link level3">5.说说Mybatis的缓存机制:</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_6-什么是-mybatis" class="router-link-active router-link-exact-active toc-link level3">6.什么是 Mybatis？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_7-mybatis-编程步骤" class="router-link-active router-link-exact-active toc-link level3">7.MyBatis 编程步骤</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_8-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理吗" class="router-link-active router-link-exact-active toc-link level3">8.Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_9-通常一个-xml-映射文件-都会写一个-mapper-接口与之对应。请问-这个-mapper-接口的工作原理是什么-mapper-接口里的方法-参数不同时-方法能重载吗" class="router-link-active router-link-exact-active toc-link level3">9.通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_10-mybatis-都有哪些-executor-执行器-它们之间的区别是什么" class="router-link-active router-link-exact-active toc-link level3">10.Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_11-mybatis-如何执行批量插入" class="router-link-active router-link-exact-active toc-link level3">11.MyBatis 如何执行批量插入?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_12-mybatis-映射文件中-如果-a-标签通过-include-引用了b标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在a标签的前面" class="router-link-active router-link-exact-active toc-link level3">12.Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_13-mybatis缓存模块" class="router-link-active router-link-exact-active toc-link level3">13.mybatis缓存模块</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_14-mybatis-sql执行整体过程" class="router-link-active router-link-exact-active toc-link level3">14.mybatis sql执行整体过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_15-mybatis连接池添加连接与获取连接" class="router-link-active router-link-exact-active toc-link level3">15.mybatis连接池添加连接与获取连接</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_16-什么是mybatis一级缓存、二级缓存" class="router-link-active router-link-exact-active toc-link level3">16.什么是mybatis一级缓存、二级缓存</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_17-batchexecutor" class="router-link-active router-link-exact-active toc-link level3">17.BatchExecutor</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/offer/offer/offer-started.html#_18-jdbc编程步骤" class="router-link-active router-link-exact-active toc-link level3">18.jdbc编程步骤</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础" aria-hidden="true">#</a> java基础</h1><h3 id="_1-java语言的特点" tabindex="-1"><a class="header-anchor" href="#_1-java语言的特点" aria-hidden="true">#</a> 1. java语言的特点？</h3><ul><li>面向对象（继承、封装、多态）</li><li>支持多线程</li><li>跨平台</li><li>强大的生态</li><li>简单易学</li><li>编译和解释并存</li></ul><h3 id="_2-解释一下jvm、jdk、jre。" tabindex="-1"><a class="header-anchor" href="#_2-解释一下jvm、jdk、jre。" aria-hidden="true">#</a> 2. 解释一下jvm、jdk、jre。</h3><ul><li>jvm是java虚拟机，是运行java字节码的虚拟机。jvm针对不同的系统有不同的实现，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</li><li>jre是java运行时环境，他是运行java已编译程序的集合，拥有jvm、java命令、java类库和一些基础构件。他不能创建新程序。如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。</li><li>jdk是java功能齐全的sdk。拥有jre的所有功能，同时还具有编译器、工具。它能够创建和编译程序。</li></ul><h3 id="_3-什么是字节码-采用字节码的好处是什么" tabindex="-1"><a class="header-anchor" href="#_3-什么是字节码-采用字节码的好处是什么" aria-hidden="true">#</a> 3.什么是字节码?采用字节码的好处是什么?</h3><p>​ 在java中，字节码指的是虚拟机可以理解的代码(.class文件)。他不面向任何特定的处理器，只面向虚拟机。java语言通过字节码文件，在一定程度上解决了解释性语言执行效率低的问题，但是也保存了解释性语言可移植的特点。由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>​ 下图是java源代码到运行的过程:</p><figure><img src="https://minio.pigx.top/oss/2022/07/2B1i2F.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ 我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器， JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。机器码的运行效率高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><h3 id="_4-为什么java是解释与编译共存" tabindex="-1"><a class="header-anchor" href="#_4-为什么java是解释与编译共存" aria-hidden="true">#</a> 4.为什么java是解释与编译共存？</h3><p>​ 我们可以将高级编程语言按照程序的执行方式分为两种：</p><ul><li><strong>编译型</strong> ：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li><li><strong>解释型</strong> ：解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/ICpppM.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><pre><code>	Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。
</code></pre><p>​ 我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器， JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。机器码的运行效率高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><h3 id="_5-了解oracle-jdk-和-openjdk的区别吗" tabindex="-1"><a class="header-anchor" href="#_5-了解oracle-jdk-和-openjdk的区别吗" aria-hidden="true">#</a> 5.了解Oracle JDK 和 OpenJDK的区别吗?</h3><ol><li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。</li><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同。</li><li>在响应性和 JVM 性能方面，Oracle JDK 比 OpenJDK 提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持。</li></ol><h3 id="_6-java和c-的区别了解吗" tabindex="-1"><a class="header-anchor" href="#_6-java和c-的区别了解吗" aria-hidden="true">#</a> 6.java和c++的区别了解吗？</h3><ol><li>Java 不提供指针来直接访问内存，程序内存更加安全。</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ol><h3 id="_7-字符型常量和字符串常量的区别" tabindex="-1"><a class="header-anchor" href="#_7-字符型常量和字符串常量的区别" aria-hidden="true">#</a> 7.字符型常量和字符串常量的区别?</h3><ol><li>形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li>含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li>占内存大小 ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ol><h3 id="_8-java注释有哪几种" tabindex="-1"><a class="header-anchor" href="#_8-java注释有哪几种" aria-hidden="true">#</a> 8.java注释有哪几种？</h3><ol><li>单行注释。</li><li>多行注释。</li><li>文档注释。</li></ol><h3 id="_9-标识符和关键字的区别是什么" tabindex="-1"><a class="header-anchor" href="#_9-标识符和关键字的区别是什么" aria-hidden="true">#</a> 9.标识符和关键字的区别是什么？</h3><p>​ 在我们编写程序的时候，需要为类、变量、方法等取的名字叫做标识符。标识符就是一个名字。</p><p>​ 有的标识符被java赋予了特殊的含义，这些叫做关键字。关键字是被赋予了特殊含义的标识符。</p><h3 id="_10-java中的关键字有哪些" tabindex="-1"><a class="header-anchor" href="#_10-java中的关键字有哪些" aria-hidden="true">#</a> 10.java中的关键字有哪些？</h3><table><thead><tr><th style="text-align:left;"></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left;">分类</td><td>关键字</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left;">访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left;">类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td style="text-align:left;"></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td style="text-align:left;">程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td style="text-align:left;"></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td style="text-align:left;">错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td style="text-align:left;">包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left;">基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td style="text-align:left;"></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left;">变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left;">保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul><h3 id="_11-continue、break-和-return-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_11-continue、break-和-return-的区别是什么" aria-hidden="true">#</a> 11.continue、break 和 return 的区别是什么？</h3><ol><li>continue ：指跳出当前的这一次循环，继续下一次循环。</li><li>break ：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p>return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li>return ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li>return value ：return 一个特定值，用于有返回值函数的方法。</li></ol><h3 id="_12-静态方法为什么不能调用非静态成员" tabindex="-1"><a class="header-anchor" href="#_12-静态方法为什么不能调用非静态成员" aria-hidden="true">#</a> 12.静态方法为什么不能调用非静态成员?</h3><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过<strong>类的实例对象</strong>去访问。</li><li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在<strong>内存中还不存在</strong>的非静态成员，属于非法操作。</li></ol><h3 id="_13-静态方法和实例方法有何不同" tabindex="-1"><a class="header-anchor" href="#_13-静态方法和实例方法有何不同" aria-hidden="true">#</a> 13.静态方法和实例方法有何不同？</h3><ol><li>调用方式</li></ol><p>​ 在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>​ 不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>​ 因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><ol start="2"><li>访问类成员是否存在限制</li></ol><p>​ 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h3 id="_14-重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#_14-重载和重写的区别" aria-hidden="true">#</a> 14.重载和重写的区别?</h3><ol><li><p>重载</p><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p></li><li><p>重写</p></li></ol><p>​ 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p>​ 1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p><p>​ <strong>2. 如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</strong></p><p>​ 3. 构造方法无法被重写。</p><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><p><strong>方法的重写要遵循“两同两小一大”</strong></p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><h3 id="_15-什么是可变长度参数" tabindex="-1"><a class="header-anchor" href="#_15-什么是可变长度参数" aria-hidden="true">#</a> 15.什么是可变长度参数？</h3><p>​ 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。方法就可以接受 0 个或者多个参数。</p><p>​ 可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p><p>​ java 的可变参数编译后实际会被转换成一个数组。</p><h3 id="_16-java-中的几种基本数据类型了解么" tabindex="-1"><a class="header-anchor" href="#_16-java-中的几种基本数据类型了解么" aria-hidden="true">#</a> 16.Java 中的几种基本数据类型了解么？</h3><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型： <ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th style="text-align:left;">基本类型</th><th style="text-align:left;">位数</th><th style="text-align:left;">字节</th><th style="text-align:left;">默认值</th><th>取值范围</th></tr></thead><tbody><tr><td style="text-align:left;"><code>byte</code></td><td style="text-align:left;">8</td><td style="text-align:left;">1</td><td style="text-align:left;">0</td><td>-128 ~ 127</td></tr><tr><td style="text-align:left;"><code>short</code></td><td style="text-align:left;">16</td><td style="text-align:left;">2</td><td style="text-align:left;">0</td><td>-32768 ~ 32767</td></tr><tr><td style="text-align:left;"><code>int</code></td><td style="text-align:left;">32</td><td style="text-align:left;">4</td><td style="text-align:left;">0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td style="text-align:left;"><code>long</code></td><td style="text-align:left;">64</td><td style="text-align:left;">8</td><td style="text-align:left;">0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td style="text-align:left;"><code>char</code></td><td style="text-align:left;">16</td><td style="text-align:left;">2</td><td style="text-align:left;">&#39;u0000&#39;</td><td>0 ~ 65535</td></tr><tr><td style="text-align:left;"><code>float</code></td><td style="text-align:left;">32</td><td style="text-align:left;">4</td><td style="text-align:left;">0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td style="text-align:left;"><code>double</code></td><td style="text-align:left;">64</td><td style="text-align:left;">8</td><td style="text-align:left;">0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td style="text-align:left;"><code>boolean</code></td><td style="text-align:left;">1</td><td style="text-align:left;"></td><td style="text-align:left;">false</td><td>true、false</td></tr></tbody></table><p>Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p><p><strong>注意：</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><h3 id="_17-基本类型和包装类型的区别" tabindex="-1"><a class="header-anchor" href="#_17-基本类型和包装类型的区别" aria-hidden="true">#</a> 17.基本类型和包装类型的区别？</h3><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p>⚠注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><h3 id="_18-包装类型的缓存机制了解么" tabindex="-1"><a class="header-anchor" href="#_18-包装类型的缓存机制了解么" aria-hidden="true">#</a> 18.包装类型的缓存机制了解么？</h3><p>​ Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p>​ <code> Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>​ 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>​ 两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p>​ <strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><figure><img src="https://minio.pigx.top/oss/2022/07/LOqSz3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_19-自动装箱与拆箱了解吗-原理是什么" tabindex="-1"><a class="header-anchor" href="#_19-自动装箱与拆箱了解吗-原理是什么" aria-hidden="true">#</a> 19.自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</strong>。</p><h3 id="_20-面向对象和面向过程的区别" tabindex="-1"><a class="header-anchor" href="#_20-面向对象和面向过程的区别" aria-hidden="true">#</a> 20.面向对象和面向过程的区别？</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h3 id="_21-成员变量与局部变量的区别" tabindex="-1"><a class="header-anchor" href="#_21-成员变量与局部变量的区别" aria-hidden="true">#</a> 21.成员变量与局部变量的区别？</h3><ul><li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h3 id="_22-创建一个对象用什么运算符-对象实体与对象引用有何不同" tabindex="-1"><a class="header-anchor" href="#_22-创建一个对象用什么运算符-对象实体与对象引用有何不同" aria-hidden="true">#</a> 22.创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>​ new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><p>​ 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h3 id="_23-对象的相等和引用相等的区别" tabindex="-1"><a class="header-anchor" href="#_23-对象的相等和引用相等的区别" aria-hidden="true">#</a> 23.对象的相等和引用相等的区别？</h3><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h3 id="_24-类的构造方法的作用是什么-如果一个类没有声明构造方法-该程序能正确执行吗" tabindex="-1"><a class="header-anchor" href="#_24-类的构造方法的作用是什么-如果一个类没有声明构造方法-该程序能正确执行吗" aria-hidden="true">#</a> 24.类的构造方法的作用是什么?如果一个类没有声明构造方法，该程序能正确执行吗?</h3><p>​ 构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p><p>​ 如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了。</p><h3 id="_25-构造方法有哪些特点-是否可被-override" tabindex="-1"><a class="header-anchor" href="#_25-构造方法有哪些特点-是否可被-override" aria-hidden="true">#</a> 25.构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时<strong>自动执行</strong>，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h3 id="_26-面向对象三大特征了解吗" tabindex="-1"><a class="header-anchor" href="#_26-面向对象三大特征了解吗" aria-hidden="true">#</a> 26.面向对象三大特征了解吗？</h3><ol><li>封装</li></ol><p>​ 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。如果属性不想被外界访问，我们大可不必提供方法给外界访问。</p><ol start="2"><li>继承</li></ol><p>​ 不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。</p><p>​ 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p><p>​ 通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><pre><code>- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
</code></pre><ol start="3"><li>多态</li></ol><p>​ 多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="_27-接口和抽象类有什么共同点和区别" tabindex="-1"><a class="header-anchor" href="#_27-接口和抽象类有什么共同点和区别" aria-hidden="true">#</a> 27.接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong> ：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。抽象方法，修饰符必须是两个固定的关键字:public abstract。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong> ：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h3 id="_28-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" tabindex="-1"><a class="header-anchor" href="#_28-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" aria-hidden="true">#</a> 28.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><p><strong>浅拷贝</strong></p><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token comment">// 省略构造函数、Getter&amp;Setter方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Address</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Address</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Address</span> address<span class="token punctuation">;</span>
    <span class="token comment">// 省略构造函数、Getter&amp;Setter方法</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> person<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试 ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">&quot;武汉&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> person1Copy <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> person1Copy<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p><p><strong>深拷贝</strong></p><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        person<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> person<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试 ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token string">&quot;武汉&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> person1Copy <span class="token operator">=</span> person1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> person1Copy<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出结构就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><figure><img src="https://minio.pigx.top/oss/2022/07/dOXDaA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_29-和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#_29-和-equals-的区别" aria-hidden="true">#</a> 29.== 和 equals() 的区别？</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a 为一个引用</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b为另一个引用,对象的内容一样</span>
<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 放在常量池中</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 从常量池中查找</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><h3 id="_30-hashcode-有什么用" tabindex="-1"><a class="header-anchor" href="#_30-hashcode-有什么用" aria-hidden="true">#</a> 30.hashCode() 有什么用？</h3><p>​ <code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p>​ <code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。</p><p>​ 散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><h3 id="_31-为什么要有-hashcode" tabindex="-1"><a class="header-anchor" href="#_31-为什么要有-hashcode" aria-hidden="true">#</a> 31.为什么要有 hashCode？</h3><p>​ 其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><p>​ <strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>​ 这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>​ 我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><p>​ <strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p><p>​ 这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><p>​ <strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p><p>​ 因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是 ：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h3 id="_32-为什么重写-equals-时必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#_32-为什么重写-equals-时必须重写-hashcode-方法" aria-hidden="true">#</a> 32.为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>​ 因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>​ 如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>总结</strong> ：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><h3 id="_33-string、stringbuffer、stringbuilder-的区别" tabindex="-1"><a class="header-anchor" href="#_33-string、stringbuffer、stringbuilder-的区别" aria-hidden="true">#</a> 33.String、StringBuffer、StringBuilder 的区别？</h3><p><strong>可变性</strong></p><p>​ <code>String</code> 是不可变的。</p><p>​ <code> StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><p><strong>线程安全性</strong></p><p>​ <code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>​ 每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h3 id="_34-string-为什么是不可变的" tabindex="-1"><a class="header-anchor" href="#_34-string-为什么是不可变的" aria-hidden="true">#</a> 34.String 为什么是不可变的?</h3><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><h3 id="_35-字符串拼接用-还是-stringbuilder" tabindex="-1"><a class="header-anchor" href="#_35-字符串拼接用-还是-stringbuilder" aria-hidden="true">#</a> 35.字符串拼接用“+” 还是 StringBuilder?</h3><p>​ Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><p>​ 字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><h3 id="_36-string-equals-和-object-equals-有何区别" tabindex="-1"><a class="header-anchor" href="#_36-string-equals-和-object-equals-有何区别" aria-hidden="true">#</a> 36.String#equals() 和 Object#equals() 有何区别？</h3><p>​ <code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h3 id="_37-字符串常量池的作用了解吗" tabindex="-1"><a class="header-anchor" href="#_37-字符串常量池的作用了解吗" aria-hidden="true">#</a> 37.字符串常量池的作用了解吗？</h3><p>​ <strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><h3 id="_38-string-s1-new-string-abc-这句话创建了几个字符串对象" tabindex="-1"><a class="header-anchor" href="#_38-string-s1-new-string-abc-这句话创建了几个字符串对象" aria-hidden="true">#</a> 38.String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</h3><p>​ 会创建 1 或 2 个字符串对象。</p><p>​ 1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。</p><p>​ 2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><h3 id="_39-intern-方法有什么作用" tabindex="-1"><a class="header-anchor" href="#_39-intern-方法有什么作用" aria-hidden="true">#</a> 39.intern 方法有什么作用?</h3><p>​ <code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><h3 id="_40-exception-和-error-有什么区别" tabindex="-1"><a class="header-anchor" href="#_40-exception-和-error-有什么区别" aria-hidden="true">#</a> 40.Exception 和 Error 有什么区别？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/6P6T4z.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="_41-checked-exception-和-unchecked-exception-有什么区别" tabindex="-1"><a class="header-anchor" href="#_41-checked-exception-和-unchecked-exception-有什么区别" aria-hidden="true">#</a> 41.Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>...。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li></ul><h3 id="_42-throwable-类常用方法有哪些" tabindex="-1"><a class="header-anchor" href="#_42-throwable-类常用方法有哪些" aria-hidden="true">#</a> 42.Throwable 类常用方法有哪些？</h3><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="_43-try-catch-finally-如何使用" tabindex="-1"><a class="header-anchor" href="#_43-try-catch-finally-如何使用" aria-hidden="true">#</a> 43.try-catch-finally 如何使用？</h3><ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><h3 id="_44-finally-中的代码一定会执行吗" tabindex="-1"><a class="header-anchor" href="#_44-finally-中的代码一定会执行吗" aria-hidden="true">#</a> 44.finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><h3 id="_45-如何使用-try-with-resources-代替try-catch-finally" tabindex="-1"><a class="header-anchor" href="#_45-如何使用-try-with-resources-代替try-catch-finally" aria-hidden="true">#</a> 45.如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3><ol><li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><p>《Effective Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//读取文本文件的内容</span>
<span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">&quot;D://read.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scanner <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        scanner<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">&quot;test.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> fnfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fnfe<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">BufferedInputStream</span> bin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">&quot;test.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">BufferedOutputStream</span> bout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">&quot;out.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> bin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_46-什么是泛型-有什么作用" tabindex="-1"><a class="header-anchor" href="#_46-什么是泛型-有什么作用" aria-hidden="true">#</a> 46.什么是泛型？有什么作用？</h3><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。</p><p>比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><h3 id="_47-泛型的使用方式有哪几种" tabindex="-1"><a class="header-anchor" href="#_47-泛型的使用方式有哪几种" aria-hidden="true">#</a> 47.泛型的使用方式有哪几种？</h3><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><strong>1.泛型类</strong>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span>
<span class="token comment">//在实例化泛型类时，必须指定T的具体类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">T</span> key<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Generic</span><span class="token punctuation">(</span><span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何实例化泛型类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> genericInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2.泛型接口</strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现泛型接口，不指定类型：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GeneratorImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现泛型接口，指定类型：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GeneratorImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.泛型方法</strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">E</span> <span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray <span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token class-name">E</span> element <span class="token operator">:</span> inputArray <span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> element <span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 创建不同类型数组： Integer, Double 和 Character</span>
<span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stringArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span> intArray  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span> stringArray  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的。</p></blockquote><h3 id="_48-何为反射-反射机制优缺点" tabindex="-1"><a class="header-anchor" href="#_48-何为反射-反射机制优缺点" aria-hidden="true">#</a> 48.何为反射？反射机制优缺点？</h3><p>​ 它赋予了我们在<strong>运行时分析类以及执行类中方法的能力</strong>。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><ul><li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li><li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h3 id="_49-反射的有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#_49-反射的有哪些应用场景" aria-hidden="true">#</a> 49.反射的有哪些应用场景？</h3><p>​ 像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p>​ <strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><p>​ 使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><h3 id="_50-什么是注解" tabindex="-1"><a class="header-anchor" href="#_50-什么是注解" aria-hidden="true">#</a> 50.什么是注解？</h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h3 id="_51-什么是序列化-什么是反序列化" tabindex="-1"><a class="header-anchor" href="#_51-什么是序列化-什么是反序列化" aria-hidden="true">#</a> 51.什么是序列化?什么是反序列化?</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程。</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)。</p><h3 id="_52-java-序列化中如果有些字段不想进行序列化-怎么办" tabindex="-1"><a class="header-anchor" href="#_52-java-序列化中如果有些字段不想进行序列化-怎么办" aria-hidden="true">#</a> 52.Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="_53-java-中-io-流分为几种" tabindex="-1"><a class="header-anchor" href="#_53-java-中-io-流分为几种" aria-hidden="true">#</a> 53.Java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><h3 id="_54-既然有了字节流-为什么还要有字符流" tabindex="-1"><a class="header-anchor" href="#_54-既然有了字节流-为什么还要有字符流" aria-hidden="true">#</a> 54.既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h3 id="_55-java-中只有值传递" tabindex="-1"><a class="header-anchor" href="#_55-java-中只有值传递" aria-hidden="true">#</a> 55.Java 中只有值传递？</h3><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h3 id="_56-序列化协议对应于-tcp-ip-4-层模型的哪一层" tabindex="-1"><a class="header-anchor" href="#_56-序列化协议对应于-tcp-ip-4-层模型的哪一层" aria-hidden="true">#</a> 56.序列化协议对应于 TCP/IP 4 层模型的哪一层？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/VMFAGt.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p><p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。</p><h3 id="_57-什么是泛型擦除" tabindex="-1"><a class="header-anchor" href="#_57-什么是泛型擦除" aria-hidden="true">#</a> 57.什么是泛型擦除？</h3><p>​ java泛型是伪泛型，在java编译期间，所有泛型信息会进行擦除。</p><p>​ 编译器在编译期间，会将动态将T擦除为Object或者将T extends xxxxx 擦除为其限定类型 xxxxx。</p><p>​ 泛型本质上是编译器行为，为了减少编译器开销，将泛型擦除为一般类。</p><h3 id="_58-jdk-动态代理和-cglib-动态代理对比" tabindex="-1"><a class="header-anchor" href="#_58-jdk-动态代理和-cglib-动态代理对比" aria-hidden="true">#</a> 58.JDK 动态代理和 CGLIB 动态代理对比？</h3><ol><li><p><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p></li><li><p>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p></li><li><p>为什么jdk动态代理只能代理接口：<a href="https://blog.csdn.net/lx1315998513/article/details/120641124" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/lx1315998513/article/details/120641124<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>cglib相关：<a href="https://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/zghwaicsdn/article/details/50957474<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationHandler</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Proxy</span></span><span class="token punctuation">;</span>

<span class="token comment">// 定义接口</span>
<span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现接口的类</span>
<span class="token keyword">class</span> <span class="token class-name">MyImplementation</span> <span class="token keyword">implements</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;正在做一些事情...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// JDK动态代理处理器</span>
<span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>

    <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;在方法调用之前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;在方法调用之后&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdkDynamicProxyExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建目标对象</span>
        <span class="token class-name">MyInterface</span> realObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyImplementation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建动态代理实例</span>
        <span class="token class-name">MyInterface</span> proxyObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyInterface</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
                <span class="token class-name">JdkDynamicProxyExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">MyInterface</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span>realObject<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 通过代理对象调用方法</span>
        proxyObject<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们来看CGLIB动态代理的例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">Enhancer</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">MethodInterceptor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">MethodProxy</span></span><span class="token punctuation">;</span>

<span class="token comment">// 不需要实现接口的类</span>
<span class="token keyword">class</span> <span class="token class-name">MyCglibClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;CGLIB: 正在做一些事情...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// CGLIB动态代理处理器</span>
<span class="token keyword">class</span> <span class="token class-name">MyCglibInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;CGLIB: 在方法调用之前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;CGLIB: 在方法调用之后&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CglibDynamicProxyExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建Enhancer对象，类似于JDK动态代理的Proxy类</span>
        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置父类</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token class-name">MyCglibClass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置回调</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCglibInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建代理对象</span>
        <span class="token class-name">MyCglibClass</span> proxyObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MyCglibClass</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 通过代理对象调用方法</span>
        proxyObject<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="_59-静态代理和动态代理的对比" tabindex="-1"><a class="header-anchor" href="#_59-静态代理和动态代理的对比" aria-hidden="true">#</a> 59.静态代理和动态代理的对比？</h3><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的</li></ol><h3 id="_60-有哪些常见的-io-模型" tabindex="-1"><a class="header-anchor" href="#_60-有哪些常见的-io-模型" aria-hidden="true">#</a> 60.有哪些常见的 IO 模型?</h3><p>​ IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><h3 id="_61-讲讲java中常见的三种io模型" tabindex="-1"><a class="header-anchor" href="#_61-讲讲java中常见的三种io模型" aria-hidden="true">#</a> 61.讲讲java中常见的三种IO模型？</h3><ol><li>BIO (Blocking I/O)</li></ol><p>​ <strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>​ 同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><figure><img src="https://minio.pigx.top/oss/2022/07/RdX5fP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>NIO</li></ol><p>​ Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>​ Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。</p><p>​ Java NIO 系统的核心在于：<strong>通道（Channel）和缓冲区（Buffer）</strong>。通道表示打开到 IO 设备（例如：文件、套接字）的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，<strong>Channel 负责传输，Buffer 负责存储</strong></p><ol start="3"><li>AIO</li></ol><p>​ AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>​ 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><figure><img src="https://minio.pigx.top/oss/2022/07/b7ybPk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_62-java创建对象有几种方式" tabindex="-1"><a class="header-anchor" href="#_62-java创建对象有几种方式" aria-hidden="true">#</a> 62.java创建对象有几种方式？</h3><ol><li>new创建新对象。</li><li>通过反射机制。</li><li>采用clone机制。</li><li>通过序列化机制。</li></ol><h3 id="_63-final有哪些用法" tabindex="-1"><a class="header-anchor" href="#_63-final有哪些用法" aria-hidden="true">#</a> 63.final有哪些用法？</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token number">1.</span> 被ﬁnal修饰的类不可以被继承 
<span class="token number">1.</span> 被ﬁnal修饰的方法不可以被重写 
<span class="token number">1.</span> 被ﬁnal修饰的变量不可以被改变<span class="token punctuation">.</span>如果修饰引用<span class="token punctuation">,</span>那么表示引用不可变<span class="token punctuation">,</span>引用指向的内容可变<span class="token punctuation">.</span>
<span class="token number">1.</span> 被ﬁnal修饰的方法<span class="token punctuation">,</span><span class="token constant">JVM</span>会尝试将其内联<span class="token punctuation">,</span>以提高运行效率<span class="token punctuation">.</span> 
<span class="token number">1.</span> 被ﬁnal修饰的常量<span class="token punctuation">,</span>在编译阶段会存入常量池中<span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_64-oom遇到过哪些情况-sof呢" tabindex="-1"><a class="header-anchor" href="#_64-oom遇到过哪些情况-sof呢" aria-hidden="true">#</a> 64.OOM遇到过哪些情况，SOF呢?</h3><p>​ OutOfMemoryError异常,除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的 可能。</p><ol><li><p>Java Heap 溢出：</p><p>java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来 避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p></li><li><p>虚拟机栈和本地方法栈溢出</p><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverﬂowError异常。</p><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常 这里需要注意当栈的大小越大可分配的线程数就越少。</p></li><li><p>运行时常量池溢出</p><p>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。</p><p>该方法 的作用是：</p><p>​ 如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对 象；</p><p>​ 否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p></li><li><p>方法区溢出</p><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。</p></li></ol><p>SOF（堆栈溢出StackOverﬂow）：</p><p>StackOverﬂowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p><p>栈溢出的原因：递归调用，大量循环或死循环。</p><h3 id="_65-说明一下public-static-void-main-string-args-这段声明里每个关键字的作用" tabindex="-1"><a class="header-anchor" href="#_65-说明一下public-static-void-main-string-args-这段声明里每个关键字的作用" aria-hidden="true">#</a> 65.说明一下public static void main(String args[])这段声明里每个关键字的作用?</h3><p>​ public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为 pulic.</p><p>​ static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。</p><p>​ void: main方法没有返回值。</p><p>​ String是命令行传进参数的类型，args是指命令行传进的字符串数组。</p><h3 id="_66-public-private-protected的区别-继承方法与访问权限" tabindex="-1"><a class="header-anchor" href="#_66-public-private-protected的区别-继承方法与访问权限" aria-hidden="true">#</a> 66.public，private，protected的区别，继承方法与访问权限</h3><figure><img src="https://minio.pigx.top/oss/2022/07/M85CQw.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_67-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" tabindex="-1"><a class="header-anchor" href="#_67-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" aria-hidden="true">#</a> 67.short s1 = 1; s1 = s1 + 1;有错吗？short s1 = 1; s1 += 1;有错吗？</h3><p>​ 对于short s1 = 1; s1 = s1 + 1；由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能 赋值给short型。</p><p>​ 而short s1 = 1; s1 += 1；<strong>+=操作符会进行隐式自动类型转换</strong>，是 Java 语言规定的运算 符；Java编译器会对它进行特殊处理，因此可以正确编译。因为s1+= 1;相当于s1 = (short)(s1 + 1)。</p><h3 id="_68-static的独特之处" tabindex="-1"><a class="header-anchor" href="#_68-static的独特之处" aria-hidden="true">#</a> 68.static的独特之处?</h3><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享 。</p><p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p><p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p><p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><h3 id="_69-程序初始化的顺序" tabindex="-1"><a class="header-anchor" href="#_69-程序初始化的顺序" aria-hidden="true">#</a> 69.程序初始化的顺序</h3><p>在Java语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建对象。</p><p>java程序的初始化—般遵循以下三个原则（以下三个原则优先级依次递减）:</p><p>1）静态对象（变 量）优先于非静态对象初始化,其中静态对象（变量）只初始化1次,而非静态对象（变量）可 能会初始化多次。</p><p>2）父类优先于子类进行初始化。</p><p>3）按照成员变量定义顺序进行初始化。即使变量定义散布于方法定义之中，它们依然在任意方法（包括构造方法）被调用之前先进行初始化。</p><p>Java程序的初始化工作可以在许多不同的代码块中来完成（例如:静态代码块、构造函数 等），它们执行的顺序为:父类静态变量→父类静态代码块→子类静态变量→子类静态代码→父类非静态变量→父类非静态代码块→父类构造方法→子类非静态变量→子类非静态代码块→子类构造方法。</p><p>（静态）非静态成员域在定义时初始化和（静态）非静态代码块中初始化的优先级是平级的，也就是说按照从上到下初始化，最后—次初始化为最终的值（不包括非静态的成员域在构造器中初始化）。所以在（静态）非静态块中初始化的域甚至能在该域声明的上方，因为分 配存储空间在初始化之前就完成了。</p><figure><img src="https://minio.pigx.top/oss/2022/08/FU1Vt1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/W8YpEU.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/2p9Waf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/FvsyhW.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_70-clone方法的保护机制" tabindex="-1"><a class="header-anchor" href="#_70-clone方法的保护机制" aria-hidden="true">#</a> 70.clone方法的保护机制</h3><p>clone0方法的保护机制在Object中是被声明为 protected的。以User类为例,通过声明为protected就可以保证只有User类里面才能“克隆”User对象。</p><h3 id="_71-java中由substring方法是否会引起内存泄漏" tabindex="-1"><a class="header-anchor" href="#_71-java中由substring方法是否会引起内存泄漏" aria-hidden="true">#</a> 71.Java中由SubString方法是否会引起内存泄漏?</h3><p>在JDKl.6中, String类中存储了三个重要的属性: char［］value、offSet和intcount,分别用来表示字符串对应的字符数组、数组的起始位置及String中包含的字符数。由这三个变量就可以唯—决定一个字符串。在调用SubString方法的时候,虽然会创建1个新的字符串,但是新对象的value仍然会使用原来字符串的value属性。只是count和of fset的值不一样而已。</p><p>虽然字符串在堆中是1个新的对象,但是它与原字符串都指向了相同的字符数组。对于垃圾回收器来说,这个字符数组仍然被使用，因此无法回收。“Helloworld”这个字符串虽然不被使用了, 但是仍然无法被垃圾回收器回收，因此就造成了内存泄漏。</p><h3 id="_72-java中提供了哪两种用于多态的机制" tabindex="-1"><a class="header-anchor" href="#_72-java中提供了哪两种用于多态的机制" aria-hidden="true">#</a> 72.Java中提供了哪两种用于多态的机制?</h3><p>编译时多态和运行时多态。编译时多态是通过方法重载实现的，运行时多态是通过方法重写（子类覆盖父类万法）实现的。</p><h3 id="_73-在java中哪个数据类型可以用来表示money" tabindex="-1"><a class="header-anchor" href="#_73-在java中哪个数据类型可以用来表示money" aria-hidden="true">#</a> 73.在Java中哪个数据类型可以用来表示Money?</h3><p>可以用BigDecimal来表示Money,可能很多程序员都会有疑问,为什么不能使用float或者double呢?因为float与double只是计算了一个近似值’无法表示非常精确的值float与 double类型数据的计算结果在不同的ⅣM上可能会有不同的实现。</p><p>而要表示Money,就必须使用一个非常精确的值。需要注意的是在使用BigDecimal时候需要使用String类型的构造方法,不能使用参数类型为double的构造方法,因为参数类型为double时,BigDecimal内部还是使用 double作为类型进行运算的,从而会导致计算结果不精确。</p><h3 id="_74-javaio流的实现机制" tabindex="-1"><a class="header-anchor" href="#_74-javaio流的实现机制" aria-hidden="true">#</a> 74.JavaIO流的实现机制</h3><p>在Java语言中,输入和输出都被称为抽象的流,流可以被看作一组有序的字节集合,即数据在两个设备之间的传输。流的本质是数据传输，根据处理数据类型的不同，流可以分为两大类:字节流和字符流。</p><p>字节流以字节（8bit）为单位，读到一个字节就返回一个字节，包含两个抽象类: InputStream（输 入流）和OutputStream（输出流）。</p><p>字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个,在UTF—8码表中是3个字节）时，先去查指定的编码表,将查到的字符返回，它包含两个抽象类:Reader（输入流）和Writer（输出流）。</p><p>其中字节流和字符流最主要的区别为:字节流在处理 输入输出的时候不会用到缓存,而字符流用到了缓存。</p><p>每个抽象类都有很多具体的实现类,JavaIO类在设计的时候采用了Decorator（装饰者）设计模式。</p><h3 id="_75-管理文件和目录的类" tabindex="-1"><a class="header-anchor" href="#_75-管理文件和目录的类" aria-hidden="true">#</a> 75.管理文件和目录的类</h3><p>Java提供了一个非常重要的类 （File）来管理文件和文件夹，通过File类不仅能够查看文件或目录的属性，而且还可以实现对文件 或目录的创建、删除与重命名等操作。</p><figure><img src="https://minio.pigx.top/oss/2022/08/nfPk7V.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/3d75Jf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_76-javasocket" tabindex="-1"><a class="header-anchor" href="#_76-javasocket" aria-hidden="true">#</a> 76.JavaSoCket？</h3><figure><img src="https://minio.pigx.top/oss/2022/08/2QD5dK.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_77-内部类的分类及其特点" tabindex="-1"><a class="header-anchor" href="#_77-内部类的分类及其特点" aria-hidden="true">#</a> 77.内部类的分类及其特点</h3><p>内部类可以分为很多种，但是主要有4种内部类：静态内部类、成员内部类、局部内部类、匿名内部类。</p><p>1.静态内部类是指被声明为static的内部类，不能访问外部类的普通成员变量，只能访问外部类中的静态成员变量和静态方法。</p><p>2.去掉关键字static就是成员内部类，可以自由的引用外部类的属性和方法。</p><p>3.局部内部类是指定义在一个代码块内的类，作用范围为其所在的代码块。局部类类似于局部变量一样，不能被public、protected、private以及static修饰，只能访问方法中定义为final类型的局部变量。</p><p>4.匿名内部类，是一种没有类名的内部类，不使用关键字class、extends、implements，它必须继承其他类或实现其它接口。</p><p>（1）匿名内部类不能有构造函数</p><p>（2）不能定义静态成员、方法和类</p><p>（3）不能是public、protected、private、static。</p><p>（4）只能创建匿名内部类的一个实例</p><h1 id="java集合" tabindex="-1"><a class="header-anchor" href="#java集合" aria-hidden="true">#</a> java集合</h1><figure><img src="https://minio.pigx.top/oss/2022/07/8bNBio.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-说说-list-set-queue-map-四者的区别" tabindex="-1"><a class="header-anchor" href="#_1-说说-list-set-queue-map-四者的区别" aria-hidden="true">#</a> 1.说说 List, Set, Queue, Map 四者的区别？</h3><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="_2-介绍一下集合框架底层数据结构" tabindex="-1"><a class="header-anchor" href="#_2-介绍一下集合框架底层数据结构" aria-hidden="true">#</a> 2.介绍一下集合框架底层数据结构？</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p><p>List</p><ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><p>Set</p><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><p>Queue</p><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><p>Map</p><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="_3-为什么要使用集合" tabindex="-1"><a class="header-anchor" href="#_3-为什么要使用集合" aria-hidden="true">#</a> 3.为什么要使用集合？</h3><p>​ 当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p><p>​ 数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p><h3 id="_4-arraylist-和-vector-的区别" tabindex="-1"><a class="header-anchor" href="#_4-arraylist-和-vector-的区别" aria-hidden="true">#</a> 4.ArrayList 和 Vector 的区别?</h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li></ul><h3 id="_5-arraylist-与-linkedlist-区别" tabindex="-1"><a class="header-anchor" href="#_5-arraylist-与-linkedlist-区别" aria-hidden="true">#</a> 5.ArrayList 与 LinkedList 区别?</h3><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响： <ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><p>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！</p><h3 id="_6-聊一聊arraylist的扩容机制" tabindex="-1"><a class="header-anchor" href="#_6-聊一聊arraylist的扩容机制" aria-hidden="true">#</a> 6.聊一聊ArrayList的扩容机制？</h3><p>​ <strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><ol><li><p>Arrlist扩容是原来的数组长度1.5倍。</p></li><li><p>数组进行扩容时，会将老数据中得元素重新拷贝一份道新的数组中，每次数组容量得增长大于时原用量得1.5倍。</p></li></ol><h3 id="_7-comparable-和-comparator-有什么区别" tabindex="-1"><a class="header-anchor" href="#_7-comparable-和-comparator-有什么区别" aria-hidden="true">#</a> 7.comparable 和 Comparator 有什么区别？</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><h3 id="_8-比较-hashset、linkedhashset-和-treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#_8-比较-hashset、linkedhashset-和-treeset-三者的异同" aria-hidden="true">#</a> 8.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同？</h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h3 id="_9-queue-与-deque-的区别" tabindex="-1"><a class="header-anchor" href="#_9-queue-与-deque-的区别" aria-hidden="true">#</a> 9.Queue 与 Deque 的区别？</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类。</p><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h3 id="_10-arraydeque-与-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#_10-arraydeque-与-linkedlist-的区别" aria-hidden="true">#</a> 10.ArrayDeque 与 LinkedList 的区别？</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="_11-说一说-priorityqueue" tabindex="-1"><a class="header-anchor" href="#_11-说一说-priorityqueue" aria-hidden="true">#</a> 11.说一说 PriorityQueue？</h3><p><code>PriorityQueue</code> 与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h3 id="_12-hashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_12-hashmap-和-hashtable-的区别" aria-hidden="true">#</a> 12.HashMap 和 Hashtable 的区别？</h3><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 <strong>16</strong>。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h3 id="_13-hashmap-和-hashset-区别" tabindex="-1"><a class="header-anchor" href="#_13-hashmap-和-hashset-区别" aria-hidden="true">#</a> 13.HashMap 和 HashSet 区别？</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p><table><thead><tr><th style="text-align:center;"><code>HashMap</code></th><th style="text-align:center;"><code>HashSet</code></th></tr></thead><tbody><tr><td style="text-align:center;">实现了 <code>Map</code> 接口</td><td style="text-align:center;">实现 <code>Set</code> 接口</td></tr><tr><td style="text-align:center;">存储键值对</td><td style="text-align:center;">仅存储对象</td></tr><tr><td style="text-align:center;">调用 <code>put()</code>向 map 中添加元素</td><td style="text-align:center;">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td style="text-align:center;"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td style="text-align:center;"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h3 id="_14-hashmap-和-treemap-区别" tabindex="-1"><a class="header-anchor" href="#_14-hashmap-和-treemap-区别" aria-hidden="true">#</a> 14.HashMap 和 TreeMap 区别？</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><h3 id="_15-说说hashmap-的底层实现" tabindex="-1"><a class="header-anchor" href="#_15-说说hashmap-的底层实现" aria-hidden="true">#</a> 15.说说HashMap 的底层实现？</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>JDK1.8 之后相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><figure><img src="https://minio.pigx.top/oss/2022/08/3K81Ev.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/7ElxIh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><ul><li><p><strong>loadFactor 加载因子</strong></p><p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p>put方法</p></li></ul><p>​ HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p>​ <strong>对 putVal 方法添加元素的分析如下：</strong></p><ol><li><p>如果定位到的数组位置没有元素 就直接插入。</p></li><li><p>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</p></li></ol><p><strong>我们再来对比一下 JDK1.7 put 方法的代码</strong></p><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用<strong>头插法</strong>插入元素</li></ul><h3 id="_16-hashmap-的长度为什么是-2-的幂次方" tabindex="-1"><a class="header-anchor" href="#_16-hashmap-的长度为什么是-2-的幂次方" aria-hidden="true">#</a> 16.HashMap 的长度为什么是 2 的幂次方？</h3><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h3 id="_17-concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_17-concurrenthashmap-和-hashtable-的区别" aria-hidden="true">#</a> 17.ConcurrentHashMap 和 Hashtable 的区别?</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p><strong>Hashtable:</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/mHR1lS.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/c4DLju.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/GUryGa.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_18-concurrenthashmap底层数据结构分析" tabindex="-1"><a class="header-anchor" href="#_18-concurrenthashmap底层数据结构分析" aria-hidden="true">#</a> 18.ConcurrentHashMap底层数据结构分析？</h3><ol><li>ConcurrentHashMap 1.7</li></ol><p>​ 1. 存储结构</p><blockquote><p>下图存在两个笔误 : Segmeng -&gt; Segment ; HashEntity -&gt; HashEntry</p></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/GOIBtq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Java 7 中 <code>ConcurrentHashMap</code> 的存储结构如上图，<code>ConcurrnetHashMap</code> 由很多个 <code>Segment</code> 组合，而每一个 <code>Segment</code> 是一个类似于 HashMap 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p><p>Java 7 中：</p><p>ConcurrnetHashMap 的<strong>初始化</strong>逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></li><li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.</li><li><strong>初始化 segments[0]</strong>，<strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol><p>ConcurrentHashMap 在 <strong>put</strong> 一个数据时的处理流程，下面梳理下具体流程。</p><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 Segment。</p></li><li><p>如果指定位置的 Segment 为空，则初始化这个 Segment。</p><p><strong>初始化 Segment 流程：</strong></p><ol><li>检查计算得到的位置的 Segment 是否为null.</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li><li>再次检查计算得到的指定位置的 Segment 是否为null.</li><li>使用创建的 HashEntry 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li></ol></li><li><p>Segment.put 插入 key,value 值。</p></li></ol><p>ConcurrentHashMap 的扩容只会<strong>扩容</strong>到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置</p><p>到这里就很简单了，<strong>get</strong> 方法只需要两步即可。</p><ol><li>计算得到 key 的存放位置。</li><li>遍历指定位置查找相同 key 的 value 值。</li></ol><p>Jdk1.8</p><figure><img src="https://minio.pigx.top/oss/2022/07/yY6kyV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 <strong>Segment 数组 + HashEntry 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p><h3 id="_19-谈谈concurrenthashmap的扩容机制" tabindex="-1"><a class="header-anchor" href="#_19-谈谈concurrenthashmap的扩容机制" aria-hidden="true">#</a> 19.谈谈ConcurrentHashMap的扩容机制？</h3><p>1.7版本</p><ol><li><p>1.7版本的ConcurrentHashMap是基于Segment分段实现的</p></li><li><p>每个Segment相对于⼀个⼩型的HashMap</p></li><li><p>每个Segment内部会进⾏扩容，和HashMap的扩容逻辑类似</p></li><li><p>先⽣成新的数组，然后转移元素到新数组中</p></li><li><p>扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值</p></li></ol><p>1.8版本</p><ol><li><p>1.8版本的ConcurrentHashMap不再基于Segment实现</p></li><li><p>当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容</p></li><li><p>如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进⾏扩容</p></li><li><p>ConcurrentHashMap是⽀持多个线程同时扩容的</p></li><li><p>扩容之前也先⽣成⼀个新的数组</p></li><li><p>在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或 多组的元素转移⼯作</p></li></ol><h3 id="_20-jdk1-7到jdk1-8-hashmap-发生了什么变化-底层" tabindex="-1"><a class="header-anchor" href="#_20-jdk1-7到jdk1-8-hashmap-发生了什么变化-底层" aria-hidden="true">#</a> 20.Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)?</h3><ol><li><p>1.7中底层是数组+链表，1.8中底层是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和查询整体效率</p></li><li><p>1.7中链表插⼊使⽤的是头插法，1.8中链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法</p></li><li><p>1.7中哈希算法⽐较复杂，存在各种右移与异或运算，1.8中进⾏了简化，因为复杂的哈希算法的⽬的 就是提⾼散列性，来提供HashMap的整体效率，⽽1.8中新增了红⿊树，所以可以适当的简化哈希 算法，节省CPU资源。</p></li></ol><h3 id="_21-说一下hashmap的put方法" tabindex="-1"><a class="header-anchor" href="#_21-说一下hashmap的put方法" aria-hidden="true">#</a> 21.说⼀下HashMap的Put⽅法</h3><p>先说HashMap的Put⽅法的⼤体流程：</p><ol><li><p>根据Key通过哈希算法与与运算得出数组下标</p></li><li><p>如果数组下标位置元素为空，则<strong>将key和value封装为Entry对象</strong>（<strong>JDK1.7中是Entry对象，JDK1.8中是Node对象</strong>）并放⼊该位置</p></li><li><p>如果数组下标位置元素不为空，则要分情况讨论</p></li></ol><p>a. 如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry对象，并使⽤头插法添加到当前位置的链表中</p><p>b. 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红⿊树Node，还是链表Node</p><p>​ ⅰ. 如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个 过程中会判断红⿊树中是否存在当前key，如果存在则更新value</p><p>​ ⅱ. 如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过尾插 法插⼊到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会 判断是否存在当前key，如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链 表中，插⼊到链表后，会看当前链表的节点个数，如果⼤于等于8，那么则会将该链表转 成红⿊树</p><p>​ ⅲ. 将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要 就扩容，如果不需要就结束PUT⽅法</p><h3 id="_22-hashmap的扩容机制原理" tabindex="-1"><a class="header-anchor" href="#_22-hashmap的扩容机制原理" aria-hidden="true">#</a> 22.HashMap的扩容机制原理</h3><p>1.7版本</p><ol><li>先⽣成新数组</li><li>遍历⽼数组中的每个位置上的链表上的每个元素</li><li>取每个元素的key，并基于新数组⻓度，计算出每个元素在新数组中的下标</li><li>将元素添加到新数组中去</li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li></ol><p>1.8版本</p><ol><li>先⽣成新数组</li><li>遍历⽼数组中的每个位置上的链表或红⿊树</li><li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</li><li>如果是红⿊树，则先遍历红⿊树，先计算出红⿊树中每个元素对应在新数组中的下标位置</li></ol><p>​ a. 统计每个下标位置的元素个数</p><p>​ b. 如果该位置下的元素个数超过了8，则⽣成⼀个新的红⿊树，并将根节点的添加到新数组的对应位置</p><p>​ c. 如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的头节点添加到新数组的对应位置</p><ol start="5"><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li></ol><h3 id="_23-copyonwritearraylist的底层原理是怎样的" tabindex="-1"><a class="header-anchor" href="#_23-copyonwritearraylist的底层原理是怎样的" aria-hidden="true">#</a> 23.CopyOnWriteArrayList的底层原理是怎样的</h3><ol><li><p>⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏ 。</p></li><li><p>并且，写操作会加锁，防⽌出现并发写⼊丢失数据的问题。</p></li><li><p>写操作结束之后会把原数组指向新数组。</p></li><li><p>CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应 ⽤场景，但是CopyOnWriteArrayList会⽐较占内存，同时可能读到的数据不是实时最新的数据，所 以不适合实时性要求很⾼的场景。</p></li></ol><h3 id="_24-fail-safe-机制与-fail-fast-机制分别有什-么作用" tabindex="-1"><a class="header-anchor" href="#_24-fail-safe-机制与-fail-fast-机制分别有什-么作用" aria-hidden="true">#</a> 24.fail-safe 机制与 fail-fast 机制分别有什 么作用?</h3><p>fail-safe 和 fail-fast， 是多线程并发操作集合时的一种失败处理机制。</p><p>Fail-fast：表示快速失败， 在集合遍历过程中，一旦发现容器中的数据被修改了， 会立刻抛出 ConcurrentModificationException (并发修改)异常，从而导致遍历失败，像这种情况（贴下面这个图）。</p><figure><img src="https://minio.pigx.top/oss/2022/08/GHx8lC.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>定义一个 Map 集合，使用 Iterator 迭代器进行数据遍历，在遍历过程中，对集 合数据做变更时，就会发生 fail-fast 。</p><p>java.util 包下的集合类都是快速失败机制的,常见的的使用 器有 HashMap 和 ArrayList 等。</p><p>Fail-safe， 表示失败安全，也就是在这种机制下，出现集合元素的修改，不会抛 出 ConcurrentModificationException。</p><p>原因是采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的， 而是先复制原有集合内容，</p><p>在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历 过程中对原集合所作的修改并不能被迭代器检测到</p><p>比如这种情况（贴下面这个图），定义了一个 CopyOnWriteArrayList， 在对这 个集合遍历过程中，对集合元素做修改后，不会抛出异常，但同时也不会打印出 增加的元素。</p><figure><img src="https://minio.pigx.top/oss/2022/08/mf88En.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>java.util.concurrent 包下的容器都是安全失败的,可以在多线程下并发使用,并发 修改。</p><p>常 见 的 的 使 用 fail-safe 方 式 遍 历 的 容 器 有 ConcerrentHashMap 和 CopyOnWriteArrayList 等。</p><h3 id="_25-什么叫做阻塞队列的有界和无界" tabindex="-1"><a class="header-anchor" href="#_25-什么叫做阻塞队列的有界和无界" aria-hidden="true">#</a> 25.什么叫做阻塞队列的有界和无界</h3><p>阻塞队列，是一种特殊的队列，它在普通队列的基础上提供了两个附加功能</p><p>当队列为空的时候，获取队列中元素的消费者线程会被阻塞，同时唤醒生产者线程。</p><p>当队列满了的时候，向队列中添加元素的生产者线程被阻塞，同时唤醒消费者线程。</p><figure><img src="https://minio.pigx.top/oss/2022/08/akyPs1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其中，阻塞队列中能够容纳的元素个数，通常情况下是有界的，比如我们实例化一个ArrayBlockingList，可以在构造方法中传入一个整形的数字，表示这个基于数组的阻塞队列中能够容纳的元素个数。这种就是有界队列。</p><p>而无界队列，就是没有设置固定大小的队列，不过它并不是像我们理解的那种元 素没有任何限制，而是它的元素存储量很大，像 LinkedBlockingQueue，它的默 认队列长度是 Integer.Max_Value，所以我们感知不到它的长度限制。</p><p>无界队列存在比较大的潜在风险，如果在并发量较大的情况下，线程池中可以几 乎无限制的添加任务，容易导致内存溢出的问题！</p><h3 id="_26-concurrenthashmap-底层具体实现知-道吗-实现原理是什么" tabindex="-1"><a class="header-anchor" href="#_26-concurrenthashmap-底层具体实现知-道吗-实现原理是什么" aria-hidden="true">#</a> 26.ConcurrentHashMap 底层具体实现知 道吗？实现原理是什么？</h3><p><strong>ConcurrentHashMap 的整体架构</strong></p><p>这个是 ConcurrentHashMap 在 JDK1.8 中的存储结构，它是由数组、单向链表、 红黑树组成。</p><p>当我们初始化一个 ConcurrentHashMap 实例时，默认会初始化一个长度为 16 的数组。由于 ConcurrentHashMap 它的核心仍然是 hash 表，所以必然会存在 hash 冲突问题。 ConcurrentHashMap 采用链式寻址法来解决 hash 冲突。</p><p>当 hash 冲 突 比 较 多 的 时 候 ， 会 造 成 链 表 长 度 较 长 ， 这 种 情 况 会 使 得 ConcurrentHashMap 中数据元素的查询复杂度变成 O(<sub>n</sub>)。因此在 JDK1.8 中， 引入了红黑树的机制。 当数组长度大于 64 并且链表长度大于等于 8 的时候，单项链表就会转换为红黑树。 另外，随着 ConcurrentHashMap 的动态扩容，一旦链表长度小于 8，红黑树会退化成单向链表。</p><figure><img src="https://minio.pigx.top/oss/2022/08/xvLqSD.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>ConcurrentHashMap 的基本功能</strong></p><p>ConcurrentHashMap 本质上是一个 HashMap，因此功能和 HashMap 一样，但 是 ConcurrentHashMap 在 HashMap 的基础上，提供了并发安全的实现。 并发安全的主要实现是通过对指定的 Node 节点加锁，来保证数据更新的安全性。</p><figure><img src="https://minio.pigx.top/oss/2022/08/FdrN37.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>ConcurrentHashMap 在性能方面做的优化</strong></p><p>如果在并发性能和数据安全性之间做好平衡，在很多地方都有类似的设计，比如 cpu 的三级缓存、mysql 的 buffer_pool、Synchronized 的锁升级等等。</p><p>ConcurrentHashMap 也做了类似的优化，主要体现在以下几个方面： 在 JDK1.8 中， ConcurrentHashMap 锁的粒度是数组中的某一个节点， 而在 JDK1.7，锁定的是 Segment，锁的范围要更大，因此性能上会更低。</p><p>引入红黑树，降低了数据查询的时间复杂度，红黑树的时间复杂度是 O(<sub>logn</sub>)。</p><p>当数组长度不够时， ConcurrentHashMap 需要对数组进行扩容，在扩容的实现 上， ConcurrentHashMap 引入了多线程并发扩容的机制，简单来说就是多个线程对原始数组进行分片后，每个线程负责一个分片的数据迁移，从而提升了扩容 过程中数据迁移的效率。</p><figure><img src="https://minio.pigx.top/oss/2022/08/jUyXUy.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>ConcurrentHashMap 中有一个 size()方法来获取总的元素个数，而在多线程并 发场景中，在保证原子性的前提下来实现元素个数的累加，性能是非常低的。 ConcurrentHashMap 在这个方面的优化主要体现在两个点：</p><p>当线程竞争不激烈时，直接采用 CAS 来实现元素个数的原子递增。</p><p>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素个数， 则直接从数组中随机选择一个，再通过 CAS 实现原子递增。它的核心思想是引 入了数组来实现对并发更新的负载</p><figure><img src="https://minio.pigx.top/oss/2022/08/PNxCvf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_27-基于数组的阻塞队列-arrayblockingqueue-原理" tabindex="-1"><a class="header-anchor" href="#_27-基于数组的阻塞队列-arrayblockingqueue-原理" aria-hidden="true">#</a> 27.基于数组的阻塞队列 ArrayBlockingQueue 原理</h3><p>阻塞队列（BlockingQueue）是在队列的基础上增加了两个附加操作，</p><p>在队列为空的时候，获取元素的线程会等待队列变为非空。</p><p>当队列满时，存储元素的线程会等待队列可用。</p><figure><img src="https://minio.pigx.top/oss/2022/08/vyghVx.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于阻塞队列的特性，可以非常容易实现生产者消费者模型，也就是生产者只需 要关心数据的生产，消费者只需要关注数据的消费，所以如果队列满了，生产者 就等待，同样，队列空了，消费者也需要等待。</p><p>要实现这样的一个阻塞队列，需要用到两个关键的技术，队列元素的存储、以及 线程阻塞和唤醒。</p><p>而 ArrayBlockingQueue 是基于数组结构的阻塞队列，也就是队列元素是存储在 一个数组结构里面，并且由于数组有长度限制，为了达到循环生产和循环消费的 目的， ArrayBlockingQueue 用到了循环数组。</p><p>而线程的阻塞和唤醒， 用到了 J.U.C 包里面的 ReentrantLock 和 Condition。 Condition 相当于 wait/notify 在 JUC 包里面的实现。</p><h1 id="并发编程" tabindex="-1"><a class="header-anchor" href="#并发编程" aria-hidden="true">#</a> 并发编程</h1><h3 id="_1-什么是线程和进程" tabindex="-1"><a class="header-anchor" href="#_1-什么是线程和进程" aria-hidden="true">#</a> 1.什么是线程和进程?</h3><p><strong>何为进程</strong>?</p><p>​ 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>​ 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p><strong>何为线程</strong>?</p><p>​ 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h3 id="_2-请简要描述线程与进程的关系-区别及优缺点" tabindex="-1"><a class="header-anchor" href="#_2-请简要描述线程与进程的关系-区别及优缺点" aria-hidden="true">#</a> 2.请简要描述线程与进程的关系,区别及优缺点？</h3><p>​ 一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong>和 <strong>本地方法栈</strong>。</p><p>​ <strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。进程作为资源分配的基本单位，线程作为资源调度的基本单位。</strong></p><h3 id="_3-程序计数器为什么是私有的" tabindex="-1"><a class="header-anchor" href="#_3-程序计数器为什么是私有的" aria-hidden="true">#</a> 3.程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="_4-虚拟机栈和本地方法栈为什么是私有的" tabindex="-1"><a class="header-anchor" href="#_4-虚拟机栈和本地方法栈为什么是私有的" aria-hidden="true">#</a> 4.虚拟机栈和本地方法栈为什么是私有的?</h3><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的</p><h3 id="_5-一句话简单介绍堆和方法区" tabindex="-1"><a class="header-anchor" href="#_5-一句话简单介绍堆和方法区" aria-hidden="true">#</a> 5.一句话简单介绍堆和方法区？</h3><p>​ 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="_6-说说并发与并行的区别" tabindex="-1"><a class="header-anchor" href="#_6-说说并发与并行的区别" aria-hidden="true">#</a> 6.说说并发与并行的区别?</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行</li></ul><h3 id="_7-为什么要使用多线程呢" tabindex="-1"><a class="header-anchor" href="#_7-为什么要使用多线程呢" aria-hidden="true">#</a> 7.为什么要使用多线程呢?</h3><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li><li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li></ul><h3 id="_8-使用多线程可能带来什么问题" tabindex="-1"><a class="header-anchor" href="#_8-使用多线程可能带来什么问题" aria-hidden="true">#</a> 8.使用多线程可能带来什么问题?</h3><p>​ 并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h3 id="_9-说说线程的生命周期和状态" tabindex="-1"><a class="header-anchor" href="#_9-说说线程的生命周期和状态" aria-hidden="true">#</a> 9.说说线程的生命周期和状态?</h3><figure><img src="https://minio.pigx.top/oss/2022/07/zUj8f3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/7VsZS9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h3 id="_10-什么是上下文切换" tabindex="-1"><a class="header-anchor" href="#_10-什么是上下文切换" aria-hidden="true">#</a> 10.什么是上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p><h3 id="_11-什么是线程死锁-如何避免死锁" tabindex="-1"><a class="header-anchor" href="#_11-什么是线程死锁-如何避免死锁" aria-hidden="true">#</a> 11.什么是线程死锁?如何避免死锁?</h3><p>​ 线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>上面的例子符合产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p><strong>如何避免死锁？</strong></p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><p>在开发过程中：</p><ol><li><p>要注意加锁顺序，保证每个线程按同样的顺序进⾏加锁</p></li><li><p>要注意加锁时限，可以针对所设置⼀个超时时间</p></li><li><p>要注意死锁检查，这是⼀种预防机制，确保在第⼀时间发现死锁并进⾏解决</p></li></ol><h3 id="_12-说说-sleep-方法和-wait-方法区别和共同点" tabindex="-1"><a class="header-anchor" href="#_12-说说-sleep-方法和-wait-方法区别和共同点" aria-hidden="true">#</a> 12.说说 sleep() 方法和 wait() 方法区别和共同点?</h3><ul><li>两者最主要的区别在于：<strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep() </code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul><h3 id="_13-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" tabindex="-1"><a class="header-anchor" href="#_13-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" aria-hidden="true">#</a> 13.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>​ new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h3 id="_14-说一说自己对于-synchronized-关键字的了解" tabindex="-1"><a class="header-anchor" href="#_14-说一说自己对于-synchronized-关键字的了解" aria-hidden="true">#</a> 14.说一说自己对于 synchronized 关键字的了解?</h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p><p>另外，在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。</p><p><strong>为什么呢？</strong></p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h3 id="_15-说说自己是怎么使用-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#_15-说说自己是怎么使用-synchronized-关键字" aria-hidden="true">#</a> 15.说说自己是怎么使用 synchronized 关键字?</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p><p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2.修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ <em>static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份</em>）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//业务代码</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</li></ul><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意 <code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要。</p><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="_16-构造方法可以使用-synchronized-关键字修饰么" tabindex="-1"><a class="header-anchor" href="#_16-构造方法可以使用-synchronized-关键字修饰么" aria-hidden="true">#</a> 16.构造方法可以使用 synchronized 关键字修饰么？</h3><p>​ <strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p>​ 构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h3 id="_17-讲一下-synchronized-关键字的底层原理" tabindex="-1"><a class="header-anchor" href="#_17-讲一下-synchronized-关键字的底层原理" aria-hidden="true">#</a> 17.讲一下 synchronized 关键字的底层原理</h3><p>​ <strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p>​ <code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p>​ <code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p>​ <strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h3 id="_18-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" tabindex="-1"><a class="header-anchor" href="#_18-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" aria-hidden="true">#</a> 18.说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h3><p>​ JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>​ 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p>​ <strong>自旋锁</strong>：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环， 可以理解为就是啥也不干，防止从用户态转入内核态。</p><p>​ <strong>自适应锁</strong>：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上 的自旋时间和锁的持有者状态来决定。</p><p>​ <strong>锁消除</strong>：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p><p>​ <strong>锁粗化</strong>：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。</p><p>​ <strong>偏向锁</strong>：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。</p><p>​ <strong>轻量级锁</strong>：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用 CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败， 当前线程就尝试自旋来获得锁。</p><p>​ 简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p><figure><img src="https://minio.pigx.top/oss/2022/07/QwXTUf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_19-谈谈-synchronized-和-reentrantlock-的区别" tabindex="-1"><a class="header-anchor" href="#_19-谈谈-synchronized-和-reentrantlock-的区别" aria-hidden="true">#</a> 19.谈谈 synchronized 和 ReentrantLock 的区别？</h3><p>两者都是可重入锁。<strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。</p><p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）。</p><p>ReentrantLock 比 synchronized 增加了一些高级功能</p><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>sychronized是⾮公平锁，ReentrantLock可以选择公平锁或⾮公平锁 sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识 来标识锁的状态。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote><h3 id="_20-讲讲cpu-缓存模型" tabindex="-1"><a class="header-anchor" href="#_20-讲讲cpu-缓存模型" aria-hidden="true">#</a> 20.讲讲CPU 缓存模型？</h3><p><strong>为什么要弄一个 CPU 高速缓存呢？</strong></p><p><strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p><p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p><p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下（实际上，现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache）:</p><figure><img src="https://minio.pigx.top/oss/2022/07/uU4fqh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>CPU Cache 的工作方式：</strong></p><p>先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p><p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。</strong></p><h3 id="_21-讲一下-jmm-java-内存模型" tabindex="-1"><a class="header-anchor" href="#_21-讲一下-jmm-java-内存模型" aria-hidden="true">#</a> 21.讲一下 JMM(Java 内存模型)？</h3><p>Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。Java 内存模型主要目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生的效果不一致。</p><p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p><blockquote><ul><li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li><li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li></ul></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/jDlkFc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要解决这个问题，就需要把变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>所以，<strong><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/zBKLn7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_22-并发编程的三个重要特性" tabindex="-1"><a class="header-anchor" href="#_22-并发编程的三个重要特性" aria-hidden="true">#</a> 22.并发编程的三个重要特性？</h3><ol><li><strong>原子性</strong> : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h3 id="_23-说说-synchronized-关键字和-volatile-关键字的区别" tabindex="-1"><a class="header-anchor" href="#_23-说说-synchronized-关键字和-volatile-关键字的区别" aria-hidden="true">#</a> 23.说说 synchronized 关键字和 volatile 关键字的区别？</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile </code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li><li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li><li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h3 id="_24-threadlocal-原理" tabindex="-1"><a class="header-anchor" href="#_24-threadlocal-原理" aria-hidden="true">#</a> 24.ThreadLocal 原理？</h3><h3 id="_25-为什么要用线程池" tabindex="-1"><a class="header-anchor" href="#_25-为什么要用线程池" aria-hidden="true">#</a> 25.为什么要用线程池？</h3><p>​ <strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="_26-实现-runnable-接口和-callable-接口的区别" tabindex="-1"><a class="header-anchor" href="#_26-实现-runnable-接口和-callable-接口的区别" aria-hidden="true">#</a> 26.实现 Runnable 接口和 Callable 接口的区别？</h3><p>​ <strong><code>Runnable</code> 接口</strong> 不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong> 可以。</p><h3 id="_27-执行-execute-方法和-submit-方法的区别是什么呢" tabindex="-1"><a class="header-anchor" href="#_27-执行-execute-方法和-submit-方法的区别是什么呢" aria-hidden="true">#</a> 27.执行 execute()方法和 submit()方法的区别是什么呢？</h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h3 id="_28-如何创建线程池" tabindex="-1"><a class="header-anchor" href="#_28-如何创建线程池" aria-hidden="true">#</a> 28.如何创建线程池？</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p><strong>方式一：通过构造方法实现</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/EvNPJA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p><p>我们可以创建三种类型的 ThreadPoolExecutor：</p><ul><li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/KYVcpp.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_29-threadpoolexecutor构造函数重要参数分析" tabindex="-1"><a class="header-anchor" href="#_29-threadpoolexecutor构造函数重要参数分析" aria-hidden="true">#</a> 29.ThreadPoolExecutor构造函数重要参数分析？</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。</p><figure><img src="https://minio.pigx.top/oss/2022/07/h5dDkk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_30-juc-包中的原子类是哪-4-类" tabindex="-1"><a class="header-anchor" href="#_30-juc-包中的原子类是哪-4-类" aria-hidden="true">#</a> 30.JUC 包中的原子类是哪 4 类?</h3><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li></ul><h3 id="_31-能不能给我简单介绍一下-atomicinteger-类的原理" tabindex="-1"><a class="header-anchor" href="#_31-能不能给我简单介绍一下-atomicinteger-类的原理" aria-hidden="true">#</a> 31.能不能给我简单介绍一下 AtomicInteger 类的原理？</h3><p>​ AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>​ CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。</p><p>​ UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h3 id="_32-介绍一下aqs" tabindex="-1"><a class="header-anchor" href="#_32-介绍一下aqs" aria-hidden="true">#</a> 32.介绍一下AQS?</h3><p>​ AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。</p><ol><li>AQS是⼀个JAVA线程同步的框架。是JDK中很多锁⼯具的核⼼实现框架。</li><li>在AQS中，维护了⼀个信号量state和⼀个线程组成的双向链表队列。其中，这个线程队列，就是⽤来给线程排队的，⽽state就像是⼀个红绿灯，⽤来控制线程排队或者放⾏的。 在不同的场景下， 有不⽤的意义。</li><li>在可重⼊锁这个场景下，state就⽤来表示加锁的次数。0标识⽆锁，每加⼀次锁，state就加1。释 放锁state就减1。</li></ol><h3 id="_33-shutdown-和shutdownnow-的区别" tabindex="-1"><a class="header-anchor" href="#_33-shutdown-和shutdownnow-的区别" aria-hidden="true">#</a> 33.shutdown()和shutdownNow()的区别？</h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="_34-isterminated-和isshutdown-的区别" tabindex="-1"><a class="header-anchor" href="#_34-isterminated-和isshutdown-的区别" aria-hidden="true">#</a> 34.isTerminated()和isShutdown()的区别？</h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true。</li></ul><h3 id="_35-说一下线程之间是如何通信的" tabindex="-1"><a class="header-anchor" href="#_35-说一下线程之间是如何通信的" aria-hidden="true">#</a> 35.说一下线程之间是如何通信的？</h3><p>线程之间的通信有两种方式：共享内存和消息传递。</p><ul><li><strong>共享内存</strong></li></ul><p>​ 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来 、隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p><pre><code>  线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：
</code></pre><ol><li><p>线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</p></li><li><p>线程 B 到主内存中去读取线程 A 之前更新过的共享变量。</p></li></ol><ul><li><strong>消息传递</strong></li></ul><p>​ 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 wait() 和 notify() ，或者 BlockingQueue 。</p><h3 id="_36-cas的原理以及缺点" tabindex="-1"><a class="header-anchor" href="#_36-cas的原理以及缺点" aria-hidden="true">#</a> 36.CAS的原理以及缺点?</h3><ul><li>CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含 三个操作数：</li></ul><ol><li><p>变量内存地址，V表示</p></li><li><p>旧的预期值，A表示</p></li><li><p>准备设置的新值，B表示</p></li></ol><p>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</p><ul><li>CAS的<strong>缺点</strong>主要有3点：</li></ul><ol><li><p><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是 A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是 ABA的问题大部分场景下都不影响并发的最终效果。Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段， 更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p></li><li><p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多 个可以通过AtomicReference来处理或者使用锁synchronized实现。</p></li></ol><p>CompareAndSwap 是一个 native 方法，实际上它最终还是会面临同样的问题， 就是先从内存地址中读取 state 的值，然后去比较，最后再修改。 这个过程不管是在什么层面上实现，都会存在原子性问题。 所以呢， CompareAndSwap 的底层实现中，在多核 CPU 环境下，会增加一个 Lock 指令对缓存或者总线加锁，从而保证比较并替换这两个指令的原子性。 CAS 主要用在并发场景中，比较典型的使用场景有两个。</p><p>第一个是 JUC 里面 Atomic 的原子实现，比如 AtomicInteger，AtomicLong。</p><p>第二个是实现多线程对 共 享 资 源 竞 争 的 互 斥 性 质 ， 比 如 在 AQS 、 ConcurrentHashMap、ConcurrentLinkedQueue 等都有用到。</p><h3 id="_37-引用类型有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#_37-引用类型有哪些-有什么区别" aria-hidden="true">#</a> 37.引用类型有哪些？有什么区别？</h3><p>引用类型主要分为强软弱虚四种：</p><ol><li><p><strong>强引用</strong>指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。</p></li><li><p><strong>软引用</strong>可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。</p></li><li><p><strong>弱引用</strong>可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC 的时候一定会被回收，而不管内存是否足够。</p></li><li><p><strong>虚引用</strong>也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和 ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</p></li></ol><h3 id="_38-happen-before规则" tabindex="-1"><a class="header-anchor" href="#_38-happen-before规则" aria-hidden="true">#</a> 38.happen-before规则？</h3><p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：</p><ol><li><p>单线程每个操作，happen-before于该线程中任意后续操作</p></li><li><p>volatile写happen-before与后续对这个变量的读</p></li><li><p>synchronized解锁happen-before后续对这个锁的加锁</p></li><li><p>ﬁnal变量的写happen-before于ﬁnal域对象的读</p></li><li><p>传递性规则，A先于B，B先于C，那么A一定先于C发生</p></li></ol><h3 id="_39-线程的sleep、wait、join、yield如何使用" tabindex="-1"><a class="header-anchor" href="#_39-线程的sleep、wait、join、yield如何使用" aria-hidden="true">#</a> 39.线程的sleep、wait、join、yield如何使用？</h3><p><strong>sleep</strong>:让线程睡眠，期间会出让cpu，在同步代码块中，不会释放锁。 <strong>wait</strong>(必须先获得对应的锁才能调用):让线程进入等待状态,释放当前线程持有的锁资源线程只有在notify 或者notifyAll方法调用后才会被唤醒,然后去争夺锁。 <strong>join</strong>:线程之间协同方式,使用场景: 线程A必须等待线程B运行完毕后才可以执行,那么就可以在线程A的代码中加入ThreadB.join(); <strong>yield</strong>:让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。</p><h3 id="_40-threadlocal的原理是什么-使用场景有哪些" tabindex="-1"><a class="header-anchor" href="#_40-threadlocal的原理是什么-使用场景有哪些" aria-hidden="true">#</a> 40.ThreadLocal的原理是什么，使用场景有哪些？</h3><p>Thread类中有两个变量threadLocals和inheritableThreadLocals，二者都是ThreadLocal内部类ThreadLocalMap类型的变量，我们通过查看内部内ThreadLocalMap可以发现实际上它类似于一个HashMap。在默认情况下，每个线程中的这两个变量都为null:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>只有当线程第一次调用ThreadLocal的set或者get方法的时候才会创建他们。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
                <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">return</span> result<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
<span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，每个线程的本地变量不是存放在ThreadLocal实例中，而是放在调用线程的<strong>ThreadLocals</strong>变量里面。也就是说，<strong>ThreadLocal类型的本地变量是存放在具体的线程空间上</strong>，其本身相当于一个装载本地变量的载体，通过set方法将value添加到调用线程的threadLocals中，当调用线程调用get方法时候能够从它的threadLocals中取出变量。如果调用线程一直不终止，那么这个本地变量将会一直存放在他的threadLocals中，所以不使用本地变量的时候需要调用remove方法将threadLocals中删除不用的本地变量,防止出现内存泄漏。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">ThreadLocalMap</span> m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
             m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_41-threadlocal有哪些内存泄露问题-如何避免" tabindex="-1"><a class="header-anchor" href="#_41-threadlocal有哪些内存泄露问题-如何避免" aria-hidden="true">#</a> 41.ThreadLocal有哪些内存泄露问题，如何避免？</h3><p>每个Thread都有一个ThreadLocal.ThreadLocalMap的map，该map的key为ThreadLocal实例，它为一个弱引用，我们知道弱引用有利于GC回收。当ThreadLocal的key == null时，GC就会回收这部分空间，但是value却不一定能够被回收，因为他还与Current Thread存在一个强引用关系，如下</p><p>由于存在这个强引用关系，会导致value无法回收。如果这个线程对象不会销毁那么这个强引用关系则会一直存在，就会出现内存泄漏情况。所以说只要这个线程对象能够及时被GC回收，就不会出现内存泄漏。如果碰到线程池，那就更坑了。 那么要怎么避免这个问题呢？ 在前面提过，在ThreadLocalMap中的setEntry()、getEntry()，如果遇到key == null的情况，会对value设置为null。当然我们也可以显示调用ThreadLocal的remove()方法进行处理。 下面再对ThreadLocal进行简单的总结：</p><ul><li>ThreadLocal 不是用于解决共享变量的问题的，也不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制。这点至关重要。</li><li>每个Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量，该成员变量用来存储实际的ThreadLocal变量副本。</li><li>ThreadLocal并不是为线程保存对象的副本，它仅仅只起到一个索引的作用。它的主要目的视为每一个线程隔离一个类的实例，这个实例的作用范围仅限于线程内部。</li></ul><h3 id="_42-volatile的可见性和禁止指令重排序怎么实现的" tabindex="-1"><a class="header-anchor" href="#_42-volatile的可见性和禁止指令重排序怎么实现的" aria-hidden="true">#</a> 42.volatile的可见性和禁止指令重排序怎么实现的？</h3><ul><li><p>可见性： volatile的功能就是被修饰的变量在被修改后可以立即同步到主内存，被修饰的变量在每次是用之前都从主内存刷新。本质也是通过内存屏障来实现可见性 写内存屏障（Store Memory Barrier）可以促使处理器将当前store buffer（存储缓存）的值写回主存。</p><p>读内存屏障（Load Memory Barrier）可以促使处理器处理invalidate queue（失效队列）。进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题。</p></li><li><p>禁止指令重排序： volatile是通过<strong>内存屏障</strong>来禁止指令重排序 JMM内存屏障的策略</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul></li></ul><h3 id="_43-concurrenthashmap底层原理是什么" tabindex="-1"><a class="header-anchor" href="#_43-concurrenthashmap底层原理是什么" aria-hidden="true">#</a> 43.ConcurrentHashMap底层原理是什么？</h3><p>1.7 数据结构： 内部主要是一个Segment数组，而数组的每一项又是一个HashEntry数组，元素都存在HashEntry数组里。因为每次锁定的是Segment对象，也就是整个HashEntry数组，所以又叫分段锁。 <img src="https://minio.pigx.top/oss/2022/08/ZlhewO.png" alt="" loading="lazy"></p><p>1.8 数据结构： 与HashMap一样采用：数组+链表+红黑树</p><figure><img src="https://minio.pigx.top/oss/2022/08/1OPJA4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>底层原理则是采用锁链表或者红黑树头结点，相比于HashTable的方法锁，力度更细，是对数组（table）中的桶（链表或者红黑树）的头结点进行锁定，这样锁定，只会影响数组（table）当前下标的数据，不会影响其他下标节点的操作，可以提高读写效率。 putVal执行流程：</p><ol><li>判断存储的key、value是否为空，若为空，则抛出异常</li><li>计算key的hash值，随后死循环（该循环可以确保成功插入，当满足适当条件时，会主动终止），判断table表为空或者长度为0，则初始化table表。</li><li>根据hash值获取table中该下标对应的节点，如果该节点为空，则根据参数生成新的节点，并以CAS的方式进行更新，并终止死循环。</li><li>如果该节点的hash值是MOVED(-1)，表示正在扩容，则辅助对该节点进行转移。</li><li>对数组（table）中的节点，即桶的头结点进行锁定，如果该节点的hash大于等于0，表示此桶是链表，然后对该桶进行遍历（死循环），寻找链表中与put的key的hash值相等，并且key相等的元素，然后进行值的替换，如果到链表尾部都没有符合条件的，就新建一个node，然后插入到该桶的尾部，并终止该循环遍历。</li><li>如果该节点的hash小于0，并且节点类型是TreeBin，则走红黑树的插入方式。</li><li>判断是否达到转化红黑树的阈值，如果达到阈值，则链表转化为红黑树。</li></ol><h3 id="_44-线程池中阻塞队列的作用-为什么是先添加队列而不是先创建最大线程" tabindex="-1"><a class="header-anchor" href="#_44-线程池中阻塞队列的作用-为什么是先添加队列而不是先创建最大线程" aria-hidden="true">#</a> 44.线程池中阻塞队列的作⽤？为什么是先添加队列⽽不是先创建最⼤线程？</h3><p>1、⼀般的队列只能保证作为⼀个有限⻓度的缓冲区，如果超出了缓冲⻓度，就⽆法保留当前的任务了， 阻塞队列通过阻塞可以保留住当前想要继续⼊队的任务。</p><p>​ 阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进⼊wait状态，释放cpu资源。</p><p>​ 阻塞队列⾃带阻塞和唤醒的功能，不需要额外处理，⽆任务执⾏时,线程池利⽤阻塞队列的take⽅法挂起，从⽽维持核⼼线程的存活、不⾄于⼀直占⽤cpu资源。</p><p>2、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。</p><p>就好⽐⼀个企业⾥⾯有10个（core）正式⼯的名额，最多招10个正式⼯，要是任务超过正式⼯⼈数 （task &gt; core）的情况下，⼯⼚领导（线程池）不是⾸先扩招⼯⼈，还是这10⼈，但是任务可以稍微积 压⼀下，即先放到队列去（代价低）。10个正式⼯慢慢⼲，迟早会⼲完的，要是任务还在继续增加，超 过正式⼯的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时⼯）要是正式⼯加上外包还 是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）。</p><h3 id="_45-reentrantlock中的公平锁和非公平锁的底层实现" tabindex="-1"><a class="header-anchor" href="#_45-reentrantlock中的公平锁和非公平锁的底层实现" aria-hidden="true">#</a> 45.ReentrantLock中的公平锁和⾮公平锁的底层实现</h3><p>ReentrantLock中的公平锁和⾮公平锁的底层实现</p><p>⾸先不管是公平锁和⾮公平锁，它们的底层实现都会使⽤AQS来进⾏排队，它们的区别在于：线程在使⽤lock()⽅法加锁时，如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队， 则当前线程也进⾏排队，如果是⾮公平锁，则不会去检查是否有线程在排队，⽽是直接竞争锁。</p><p>不管是公平锁还是⾮公平锁，⼀旦没竞争到锁，都会进⾏排队，当锁释放时，都是唤醒排在最前⾯的线程，所以⾮公平锁只是体现在了线程加锁阶段，⽽没有体现在线程被唤醒阶段。</p><p>另外，ReentrantLock是可重⼊锁，不管是公平锁还是⾮公平锁都是可重⼊的。</p><figure><img src="https://minio.pigx.top/oss/2022/08/aiHXPq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/Gc8pLm.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_46-reentrantlock中trylock-和lock-方法的区别" tabindex="-1"><a class="header-anchor" href="#_46-reentrantlock中trylock-和lock-方法的区别" aria-hidden="true">#</a> 46.ReentrantLock中tryLock()和lock()⽅法的区别</h3><ol><li><p>tryLock()表示尝试加锁，可能加到，也可能加不到，该⽅法不会阻塞线程，如果加到锁则返回 true，没有加到则返回false</p></li><li><p>lock()表示阻塞加锁，线程会阻塞直到加到锁，⽅法也没有返回值</p></li></ol><h3 id="_47-countdownlatch和semaphore的区别和底层原理" tabindex="-1"><a class="header-anchor" href="#_47-countdownlatch和semaphore的区别和底层原理" aria-hidden="true">#</a> 47.CountDownLatch和Semaphore的区别和底层原理</h3><p>CountDownLatch表示计数器，可以给CountDownLatch设置⼀个数字，⼀个线程调⽤ CountDownLatch的await()将会阻塞，其他线程可以调⽤CountDownLatch的countDown()⽅法来对 CountDownLatch中的数字减⼀，当数字被减成0后，所有await的线程都将被唤醒。 对应的底层原理就是，调⽤await()⽅法的线程会利⽤AQS排队，⼀旦数字被减为0，则会将AQS中 排队的线程依次唤醒。</p><p>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使⽤该信号量，通 过acquire()来获取许可，如果没有许可可⽤则线程阻塞，并通过AQS来排队，可以通过release() ⽅法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第⼀个线程开始依次唤醒，直到没有空闲许可。</p><h3 id="_48-线程池如何知道一个线程的任务已经执行完成" tabindex="-1"><a class="header-anchor" href="#_48-线程池如何知道一个线程的任务已经执行完成" aria-hidden="true">#</a> 48.线程池如何知道一个线程的任务已经执行完成</h3><p>在线程池中，有一个 submit() 方法，它提供了一个 Future 的返回值，我们通过 Future.get() 方法来获得任务的执行结果， 当线程池中的任务没执行完之前，future.get()方法会一直阻塞，直到任务执行结束。因此，只要 future.get() 方法正常 返回，也就意味着传入到线程池中的任务已经执行完成了！</p><p>可以引入一个 CountDownLatch 计数器，它可以通过初始化指定一个计数器进行倒计时，其中有两个方法分别是 await() 阻塞线程，以及 countDown() 进行倒计await()时，一旦倒计时归零，所以被阻塞在方法的线程都会被释放。</p><p>基于这样的原理，我们可以定义一个 CountDownLatch 对象并且计数器为 1，接着在线程池代码块后面调用 await() 方法阻塞主线程，然后，当传入到线程池中的 任务执行完成后，调用 countDown() 方法表示任务执行结束。</p><p>最后，计数器归零 0， 唤醒阻塞在await()方法的线程。</p><figure><img src="https://minio.pigx.top/oss/2022/08/Vby9bY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>基于这个问题，我简单总结一下，不管是线程池内部还是外部，要想知道线程是 否执行结束，我们必须要获取线程执行结束后的状态，而线程本身没有返回值， 所以只能通过阻塞-唤醒的方式来实现，future.get 和 CountDownLatch 都是这样 一个原理。</p><h3 id="_49-wait-和-notify-这个为什么要在-synchronized-代码块中" tabindex="-1"><a class="header-anchor" href="#_49-wait-和-notify-这个为什么要在-synchronized-代码块中" aria-hidden="true">#</a> 49.wait 和 notify 这个为什么要在 synchronized 代码块中？</h3><p>wait 和 notify 用来实现多线程之间的协调， wait 表示让线程进入到阻塞状态， notify 表示让阻塞的线程唤醒。</p><p>wait 和 notify 必然是成对出现的，如果一个线程被 wait()方法阻塞，那么必然需要另外一个线程通过 notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。</p><p>在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变 量 s，从而完成数据通信。</p><p>但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程 t2 在访问共享变量 s 之前，必须要知道线程 t1 已经修 改过了共享变量 s， 否则就需要等待。</p><p>同时，线程 t1 修改过了共享变量 S 之后，还需要通知在等待中的线程 t2。</p><p>所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线 程在什么条件下等待，什么条件下唤醒。</p><figure><img src="https://minio.pigx.top/oss/2022/08/tP2WSv.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>而 Synchronized 同步关键字就可以实现这样一个互斥条件，也就是在通过共享 变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变 量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线 程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之 前的通信。</p><p>所以这也是为什么 wait/notify 需要放在 Synchronized 同步代码块中的原因，有 了 Synchronized 同步锁，就可以实现对多个通信线程之间的互斥，实现条件等 待和条件唤醒。</p><p>另外，为了避免 wait/notify 的错误使用， jdk 强制要求把 wait/notify 写在同步代 码块里面，否则会抛出 IllegalMonitorStateException</p><p>最后，基于 wait/notify 的特性，非常适合实现生产者消费者的模型，比如说用 wait/notify 来实现连接池就绪前的等待与就绪后的唤醒。</p><h3 id="_50-java中interrupted-和-isinterruptedd方法的区别" tabindex="-1"><a class="header-anchor" href="#_50-java中interrupted-和-isinterruptedd方法的区别" aria-hidden="true">#</a> 50.Java中interrupted 和 isInterruptedd方法的区别？</h3><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。</p><p>Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。 当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出 InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能 被其它线程调用中断来改变。</p><h3 id="_51-synchronizedmap和concurrenthashmap有什么区别" tabindex="-1"><a class="header-anchor" href="#_51-synchronizedmap和concurrenthashmap有什么区别" aria-hidden="true">#</a> 51.SynchronizedMap和ConcurrentHashMap有什么区别？</h3><p>SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。 而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程 访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。</p><p>所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加 有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行 数据修改，也不会抛出ConcurrentModiﬁcationException。</p><h3 id="_52-线程池核心线程数怎么设置呢" tabindex="-1"><a class="header-anchor" href="#_52-线程池核心线程数怎么设置呢" aria-hidden="true">#</a> 52.线程池核心线程数怎么设置呢？</h3><p>分为CPU密集型和IO密集型</p><p><strong>CPU</strong></p><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦 任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p><strong>IO密集型</strong></p><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用CPU来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们 可以多配置一些线程，具体的计算方法是 ： 核心线程数= CPU核心数量 * 2。</p><h3 id="_53-java线程池中队列常用类型有哪些" tabindex="-1"><a class="header-anchor" href="#_53-java线程池中队列常用类型有哪些" aria-hidden="true">#</a> 53.Java线程池中队列常用类型有哪些？</h3><p>ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue</p><p>SynchronousQueue一个不存储元素的阻塞队列。</p><p>PriorityBlockingQueue一个具有优先级的无限阻塞队列。PriorityBlockingQueue也是基于最小二叉堆实现</p><p>DelayQueue 只有当其指定的延迟时间到了，才能够从队列中获取到该元素。 DelayQueue 是一个没有大小限制的队列， 因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费 者）才会被阻塞。</p><h3 id="_54-说说cyclicbarrier和countdownlatch的区别" tabindex="-1"><a class="header-anchor" href="#_54-说说cyclicbarrier和countdownlatch的区别" aria-hidden="true">#</a> 54.说说CyclicBarrier和CountDownLatch的区别？</h3><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><h3 id="_55-线程类的构造方法、静态块是被哪个线程调用的" tabindex="-1"><a class="header-anchor" href="#_55-线程类的构造方法、静态块是被哪个线程调用的" aria-hidden="true">#</a> 55.线程类的构造⽅法、静态块是被哪个线程调⽤的?</h3><p>线程类的构造⽅法、静态块是被new这个线程类所在的线程所调⽤的，⽽run⽅法⾥⾯的代码才是被线程⾃身所调⽤的。</p><h3 id="_56-死锁与活锁的区别-死锁与锁饥饿的区别" tabindex="-1"><a class="header-anchor" href="#_56-死锁与活锁的区别-死锁与锁饥饿的区别" aria-hidden="true">#</a> 56.死锁与活锁的区别，死锁与锁饥饿的区别？</h3><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的 现象，若无外力作用，它们都将无法推进下去。</p><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的 实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p>锁饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><p>Java 中导致锁饥饿的原因：</p><p>1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p><p>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p><p>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</p><h3 id="_57-volatile实现可见性的原理" tabindex="-1"><a class="header-anchor" href="#_57-volatile实现可见性的原理" aria-hidden="true">#</a> 57.volatile实现可见性的原理</h3><p>实现原理是内存屏障（MemoryBarrier）,其原理为:当CPU写数据时,如果发现一个变量在其他CPU中存有副本,那么会发出信号量通知其他CPU将该副本对应的缓存行置为无效状态,当其他CPU读取到变量副本的时候,会发现该缓存行是无效的,然后’它会从主存重新读取变量。</p><h3 id="_58-是否可以把一个数组修饰为volatile" tabindex="-1"><a class="header-anchor" href="#_58-是否可以把一个数组修饰为volatile" aria-hidden="true">#</a> 58.是否可以把一个数组修饰为volatile?</h3><p>在Java中可以用volatile来修饰数组，但是volatile只作用在这个数组的引用上，而不是整个数组的内容。也就是说如果—个线程修改了这个数组的引用,这个修改会对其他所有线程可见。但是如果只是修改了数组的内容，则无法保证这个修改对其他数组可见。</p><h3 id="_59-线上cpu飙高" tabindex="-1"><a class="header-anchor" href="#_59-线上cpu飙高" aria-hidden="true">#</a> 59.线上CPU飙高</h3><p><strong>1. CPU使用率一般多少正常</strong></p><p>CPU是整个计算机的核心计算资源，对于一个服务来说，在计算机上的体现是一个进程，一个进程可以开启多个线程，而CPU的最小执行单元是线程。 CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比，用公式来表示就是：</p><figure><img src="https://img2022.cnblogs.com/blog/1367382/202205/1367382-20220528104812761-293879759.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>因此CPU使用率可以表示某个时间点机器上程序的运行情况。通常CPU使用率在0-75%是正常，如果经常在90%以上，则说明CPU使用率过高，可能有问题存在。</p><p>现在操作系统都是基于多任务分时设计的，也就是机器上运行多个程序，正常情况下，某一个线程执行一定时间之后操作系统就会调度将CPU切换到其他线程，因此CPU使用率过高，最直接的原因可能就是创建线程过多或者某一个线程对应的程序设计有问题，导致CPU一直处于调度状态或者一直被某一个线程占用。 最明显的体现就是，计算机开机的时候，如果自启动项过多，就会短时间内CPU使用率飚高，这个时候如果自己再去开启其他应用程序，就会出现无响应或者响应慢的情况。</p><p><strong>2.具体原因</strong></p><p>导致CPU飚高的原因 （1）线程过多 创建线程过多导致CPU上下文切换频繁，对于CPU来说，同一时刻下每个CPU核心只能运行一个线程，如果有多个线程要执行，CPU只能通过上下文切换的方式来执行不同的线程。上下文切换需要做两个事情</p><ul><li>保存当前运行线程的执行状态</li><li>让处于等待状态的线程来执行 这两个过程需要CPU执行内核相关指令实现状态保存到响应的寄存器和存储器，如果较多的上下文切换会频繁的占据CPU而占用资源，无法去执行用户进程中的指令，导致实际的用户进程的响应速度下降。</li></ul><p>（2）代码逻辑问题</p><p>如果线程出现死循环等情况无法退出，也会一直占用CPU资源无法释放，（但是现在一般程序都有抢占式调度？某一个线程占用一定时间CPU或者内存达到某一定阈值就会出现抢占式调度。）</p><p><strong>3.尝试解决方案</strong></p><p>这两个问题导致的CPU利用率较高，通过top命令，定位到CPU利用率比较高的进程，然后shift+h找到CPU比较高的线程，两种情况。</p><ul><li>CPU利用率过高的一直是同一个线程，说明程序存在线程长期没有释放CPU的情况，</li><li>CPU利用率过高的线程ID不断变化，说明线程创建过多</li></ul><p>也可能是定位之后发现线程对应的代码正确，CPU只是在飚高的某些时刻，用户访问量较大，导致资源不够。</p><p>​ AQS --&gt; Sync --&gt; NonfairAsyc --&gt; FairAsync ​ 加锁：lock --&gt; nonfairAsyc.lock() --&gt; AQS.acquire(1) --&gt; NonfairAsyc.tryAcquire(1) --&gt; Sync.nonfairTryAcquire(1) ​ 1.CAS尝试获取锁：如果state的值为0，则获取锁成功，并记录排他有锁线程是当前线程(再次尝试获取锁)。 ​ 2.判断当前线程是否是排他有锁线程，如果是则state的值加1。 ​ 3.获取锁失败，则入队。 ​ 解锁：</p><p>​ 1. 判断当前线程是否是排他有锁线程，不是则报错。</p><p>​ 2. 对state的值减1，判断减1后的值是否为0，为0则释放锁。</p><p>​ 3. 不为0则释放锁结束。</p><h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm" aria-hidden="true">#</a> jvm</h1><h3 id="_1-介绍下-java-内存区域-运行时数据区" tabindex="-1"><a class="header-anchor" href="#_1-介绍下-java-内存区域-运行时数据区" aria-hidden="true">#</a> 1.介绍下 Java 内存区域（运行时数据区）?</h3><p>​ Java 虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同。</p><figure><img src="https://minio.pigx.top/oss/2022/07/vckmOu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/JDABXX.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h3 id="_2-程序计数器" tabindex="-1"><a class="header-anchor" href="#_2-程序计数器" aria-hidden="true">#</a> 2.程序计数器？</h3><p>​ 程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意 ：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="_3-java-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_3-java-虚拟机栈" aria-hidden="true">#</a> 3.Java 虚拟机栈？</h3><p>​ 与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>​ 除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p>​ 方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>​ 栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><figure><img src="https://minio.pigx.top/oss/2022/07/t7bYhE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用 。</p><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p><figure><img src="https://minio.pigx.top/oss/2022/07/lsLPXU.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><h3 id="_4-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_4-本地方法栈" aria-hidden="true">#</a> 4.本地方法栈？</h3><p>​ 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="_5-堆" tabindex="-1"><a class="header-anchor" href="#_5-堆" aria-hidden="true">#</a> 5.堆？</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden (伊甸园)区、两个 Survivor(幸存者) 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><figure><img src="https://minio.pigx.top/oss/2022/07/KksQ1D.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值。</p><h3 id="_6-方法区" tabindex="-1"><a class="header-anchor" href="#_6-方法区" aria-hidden="true">#</a> 6.方法区？</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><figure><img src="https://minio.pigx.top/oss/2022/07/UhwPnh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_7-运行时常量池" tabindex="-1"><a class="header-anchor" href="#_7-运行时常量池" aria-hidden="true">#</a> 7.运行时常量池？</h3><p>Class 文件中有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。</p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h3 id="_8-字符串常量池" tabindex="-1"><a class="header-anchor" href="#_8-字符串常量池" aria-hidden="true">#</a> 8.字符串常量池？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 在堆中创建字符串对象”ab“</span>
<span class="token comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span>
<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。</p><p><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><figure><img src="https://minio.pigx.top/oss/2022/07/SNoGFn.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h3 id="_9-直接内存" tabindex="-1"><a class="header-anchor" href="#_9-直接内存" aria-hidden="true">#</a> 9.直接内存？</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h3 id="_10-java-对象的创建过程" tabindex="-1"><a class="header-anchor" href="#_10-java-对象的创建过程" aria-hidden="true">#</a> 10.Java 对象的创建过程？</h3><p>1:类加载检查</p><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>2:分配内存</p><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式</strong> ：</p><ul><li>指针碰撞 ： <ul><li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li><li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表 ： <ul><li>适用场合 ：堆内存不规整的情况下。</li><li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</p><p>3:初始化零值</p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p>4:设置对象头</p><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p>5:执行 init 方法</p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="_11-对象的内存布局" tabindex="-1"><a class="header-anchor" href="#_11-对象的内存布局" aria-hidden="true">#</a> 11.对象的内存布局？</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="_12-对象的访问定位" tabindex="-1"><a class="header-anchor" href="#_12-对象的访问定位" aria-hidden="true">#</a> 12.对象的访问定位？</h3><p>目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><p>句柄：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><p>直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h3 id="_13-内存分配原则" tabindex="-1"><a class="header-anchor" href="#_13-内存分配原则" aria-hidden="true">#</a> 13.内存分配原则?</h3><ul><li>对象优先在 Eden 区分配</li></ul><p>​ 大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><ul><li>大对象直接进入老年代</li></ul><p>​ 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>​ 大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><ul><li>长期存活的对象将进入老年代</li></ul><p>​ 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>​ 大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p><p>​ 对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="_14-主要进行-gc-的区域" tabindex="-1"><a class="header-anchor" href="#_14-主要进行-gc-的区域" aria-hidden="true">#</a> 14.主要进行 gc 的区域？</h3><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="_15-空间分配担保" tabindex="-1"><a class="header-anchor" href="#_15-空间分配担保" aria-hidden="true">#</a> 15.空间分配担保？</h3><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><h3 id="_16-死亡对象判断方法" tabindex="-1"><a class="header-anchor" href="#_16-死亡对象判断方法" aria-hidden="true">#</a> 16.死亡对象判断方法？</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><ol><li><strong>引用计数法</strong></li></ol><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><ol start="2"><li>可达性分析算法</li></ol><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>​ 要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>​ 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="_17-引用类型总结" tabindex="-1"><a class="header-anchor" href="#_17-引用类型总结" aria-hidden="true">#</a> 17.引用类型总结？</h3><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="_18-如何判断一个常量是废弃常量" tabindex="-1"><a class="header-anchor" href="#_18-如何判断一个常量是废弃常量" aria-hidden="true">#</a> 18.如何判断一个常量是废弃常量？</h3><p>假如在字符串常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池了。</p><h3 id="_19-如何判断一个类是无用的类" tabindex="-1"><a class="header-anchor" href="#_19-如何判断一个类是无用的类" aria-hidden="true">#</a> 19.如何判断一个类是无用的类？</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收</p><h3 id="_20-垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#_20-垃圾收集算法" aria-hidden="true">#</a> 20.垃圾收集算法？</h3><ul><li><strong>标记-清除算法</strong></li></ul><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><ul><li><strong>标记-复制算法</strong></li></ul><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><ul><li><strong>标记-整理算法</strong></li></ul><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><ul><li><strong>分代收集算法</strong></li></ul><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h3 id="_21-垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_21-垃圾收集器" aria-hidden="true">#</a> 21.垃圾收集器？</h3><ul><li><strong>Serial 收集器</strong></li></ul><p>​ Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>&quot;Stop The World&quot;</strong> ），直到它收集结束。</p><p>​ <strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><ul><li><strong>ParNew 收集器</strong></li></ul><p>​ <strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><ul><li><p><strong>Parallel Scavenge 收集器</strong></p><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p></li><li><p><strong>Serial Old 收集器</strong></p></li></ul><p>​ <strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><ul><li><strong>Parallel Old 收集器</strong></li></ul><p>​ <strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器</p><ul><li><strong>CMS 收集器</strong></li></ul><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</p></li><li><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p></li><li><p><strong>G1 收集器</strong></p></li></ul><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="_22-类加载过程" tabindex="-1"><a class="header-anchor" href="#_22-类加载过程" aria-hidden="true">#</a> 22.类加载过程？</h3><p>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><figure><img src="https://minio.pigx.top/oss/2022/07/qAHDV4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p><p>所有的类都由类加载器加载，加载的作用就是将 <code>.class</code>文件加载到内存。</p><h3 id="_23-类加载器总结" tabindex="-1"><a class="header-anchor" href="#_23-类加载器总结" aria-hidden="true">#</a> 23.类加载器总结？</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><h3 id="_24-双亲委派模型介绍" tabindex="-1"><a class="header-anchor" href="#_24-双亲委派模型介绍" aria-hidden="true">#</a> 24.双亲委派模型介绍？</h3><p>​ 每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。</p><p>​ 加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p><figure><img src="https://minio.pigx.top/oss/2022/07/dFcV06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_25-双亲委派模型的好处" tabindex="-1"><a class="header-anchor" href="#_25-双亲委派模型的好处" aria-hidden="true">#</a> 25.双亲委派模型的好处？</h3><ol><li><p>避免类的重复加载</p></li><li><p>避免Java的核心API被篡改</p></li></ol><h3 id="_26-如果我们不想用双亲委派模型怎么办" tabindex="-1"><a class="header-anchor" href="#_26-如果我们不想用双亲委派模型怎么办" aria-hidden="true">#</a> 26.如果我们不想用双亲委派模型怎么办</h3><p>​ 自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</p><figure><img src="https://minio.pigx.top/oss/2022/07/IfNTT6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_27-什么是字节码" tabindex="-1"><a class="header-anchor" href="#_27-什么是字节码" aria-hidden="true">#</a> 27.什么是字节码？</h3><p>因为JVM针对各种操作系统和平台都进行了定制，无论在什么平台，都可以通过javac命令将一个.java文件编译成固定格式的字节码（.class文件）供JVM使用。之所以被称为字节码，是因为**.class文件是由十六进制值组成的，JVM以两个十六进制值为一组，就是以字节为单位进行读取** 格式如下</p><figure><img src="https://minio.pigx.top/oss/2022/08/iHCRmJ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_28-一个对象从加载到jvm-再到被gc清除-都经历了什么过程" tabindex="-1"><a class="header-anchor" href="#_28-一个对象从加载到jvm-再到被gc清除-都经历了什么过程" aria-hidden="true">#</a> 28.⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？</h3><ol><li><p>⽤户创建⼀个对象，JVM⾸先需要到⽅法区去找对象的类型信息。然后再创建对象。</p></li><li><p>JVM要实例化⼀个对象，⾸先要在堆当中先创建⼀个对象。-&gt; 半初始化状态</p></li><li><p>对象⾸先会分配在堆内存中新⽣代的Eden。然后经过⼀次Minor GC，对象如果存活，就会进⼊S 区。在后续的每次GC中，如果对象⼀直存活，就会在S区来回拷⻉，每移动⼀次，年龄加1。-&gt; 多⼤年龄才会移⼊⽼年代？ 年龄最⼤15， 超过⼀定年龄后，对象转⼊⽼年代。</p></li><li><p>当⽅法执⾏结束后，栈中的指针会先移除掉。</p></li><li><p>堆中的对象，经过Full GC，就会被标记为垃圾，然后被GC线程清理掉。</p></li></ol><h3 id="_29-什么是三色标记" tabindex="-1"><a class="header-anchor" href="#_29-什么是三色标记" aria-hidden="true">#</a> 29.什么是三⾊标记？</h3><p>三⾊标记：是⼀种逻辑上的抽象。将每个内存对象分成三种颜⾊：</p><ol><li>⿊⾊：表示⾃⼰和成员变量都已经标记完毕。</li><li>灰⾊：⾃⼰标记完了，但是成员变量还没有完全标记完。</li><li>⽩⾊：⾃⼰未标记完。</li></ol><h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> Mysql</h1><h3 id="_1-一条-sql-语句在-mysql-内部是如何执行的" tabindex="-1"><a class="header-anchor" href="#_1-一条-sql-语句在-mysql-内部是如何执行的" aria-hidden="true">#</a> 1.一条 SQL 语句在 MySQL 内部是如何执行的?</h3><figure><img src="https://minio.pigx.top/oss/2022/07/zi1jXt.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/N2LsQR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-mysql-支持哪些存储引擎-默认使用哪个" tabindex="-1"><a class="header-anchor" href="#_2-mysql-支持哪些存储引擎-默认使用哪个" aria-hidden="true">#</a> 2.MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>​ MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><h3 id="_3-mysql-存储引擎架构了解吗" tabindex="-1"><a class="header-anchor" href="#_3-mysql-存储引擎架构了解吗" aria-hidden="true">#</a> 3.MySQL 存储引擎架构了解吗？</h3><p>​ MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><h3 id="_4-myisam-和-innodb-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_4-myisam-和-innodb-的区别是什么" aria-hidden="true">#</a> 4.MyISAM 和 InnoDB 的区别是什么？</h3><p><strong>1.是否支持行级锁</strong></p><p>​ MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p><strong>2.是否支持事务</strong></p><p>​ MyISAM 不提供事务支持。</p><p>​ InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p><strong>3.是否支持外键</strong></p><p>​ MyISAM 不支持，而 InnoDB 支持。</p><p>​ 外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>​ 阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><figure><img src="https://minio.pigx.top/oss/2022/07/y1XOIB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>​ MyISAM 不支持，而 InnoDB 支持。</p><p>​ 使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>​ MyISAM 不支持，而 InnoDB 支持。</p><p><strong>6.索引实现不一样。</strong></p><p>​ 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>​ InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><h3 id="_5-mysql-查询缓存" tabindex="-1"><a class="header-anchor" href="#_5-mysql-查询缓存" aria-hidden="true">#</a> 5.MySQL 查询缓存?</h3><p>​ 执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。</p><p>​ <strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。</p><p>​ <strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong></p><h3 id="_6-何谓数据库事务" tabindex="-1"><a class="header-anchor" href="#_6-何谓数据库事务" aria-hidden="true">#</a> 6.何谓数据库事务？</h3><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><h3 id="_7-并发事务带来了哪些问题" tabindex="-1"><a class="header-anchor" href="#_7-并发事务带来了哪些问题" aria-hidden="true">#</a> 7.并发事务带来了哪些问题?</h3><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><h3 id="_8-不可重复读和幻读有什么区别呢" tabindex="-1"><a class="header-anchor" href="#_8-不可重复读和幻读有什么区别呢" aria-hidden="true">#</a> 8.<strong>不可重复读和幻读有什么区别呢？</strong></h3><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><h3 id="_9-sql-标准定义了哪些事务隔离级别" tabindex="-1"><a class="header-anchor" href="#_9-sql-标准定义了哪些事务隔离级别" aria-hidden="true">#</a> 9.SQL 标准定义了哪些事务隔离级别?</h3><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">READ-UNCOMMITTED</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">READ-COMMITTED</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">REPEATABLE-READ</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">SERIALIZABLE</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr></tbody></table><h3 id="_10-mysql-的隔离级别是基于锁实现的吗" tabindex="-1"><a class="header-anchor" href="#_10-mysql-的隔离级别是基于锁实现的吗" aria-hidden="true">#</a> 10.MySQL 的隔离级别是基于锁实现的吗?</h3><p>​ MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>​ SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。</p><p>​ 不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="_11-mysql-的默认隔离级别是什么" tabindex="-1"><a class="header-anchor" href="#_11-mysql-的默认隔离级别是什么" aria-hidden="true">#</a> 11.MySQL 的默认隔离级别是什么?</h3><p>​ MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p><h3 id="_12-表级锁和行级锁了解吗-有什么区别" tabindex="-1"><a class="header-anchor" href="#_12-表级锁和行级锁了解吗-有什么区别" aria-hidden="true">#</a> 12.表级锁和行级锁了解吗？有什么区别？</h3><p>​ MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p><p>​ InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h3 id="_13-共享锁和排他锁呢" tabindex="-1"><a class="header-anchor" href="#_13-共享锁和排他锁呢" aria-hidden="true">#</a> 13.共享锁和排他锁呢？</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">S 锁</th><th style="text-align:left;">X 锁</th></tr></thead><tbody><tr><td style="text-align:left;">S 锁</td><td style="text-align:left;">不冲突</td><td style="text-align:left;">冲突</td></tr><tr><td style="text-align:left;">X 锁</td><td style="text-align:left;">冲突</td><td style="text-align:left;">冲突</td></tr></tbody></table><h3 id="_14-innodb-有哪几类行锁" tabindex="-1"><a class="header-anchor" href="#_14-innodb-有哪几类行锁" aria-hidden="true">#</a> 14.InnoDB 有哪几类行锁？</h3><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</li></ul><h3 id="_15-何为索引-有什么作用" tabindex="-1"><a class="header-anchor" href="#_15-何为索引-有什么作用" aria-hidden="true">#</a> 15.何为索引？有什么作用？</h3><p>​ **索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。**索引的作用就相当于书的目录。</p><p>​ 索引的原理：就是把⽆序的数据变成有序的查询。</p><h3 id="_16-索引的优缺点" tabindex="-1"><a class="header-anchor" href="#_16-索引的优缺点" aria-hidden="true">#</a> 16.索引的优缺点?</h3><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h3 id="_17-为什么mysql-没有使用hash作为索引的数据结构呢" tabindex="-1"><a class="header-anchor" href="#_17-为什么mysql-没有使用hash作为索引的数据结构呢" aria-hidden="true">#</a> 17.<strong>为什么MySQL 没有使用Hash作为索引的数据结构呢？</strong></h3><p><strong>1.Hash 冲突问题</strong>。</p><p><strong>2.Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p><h3 id="_18-b-树-b-树" tabindex="-1"><a class="header-anchor" href="#_18-b-树-b-树" aria-hidden="true">#</a> 18.B 树&amp; B+树?</h3><p>​ B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><h3 id="_19-b-树-b-树两者有何异同呢" tabindex="-1"><a class="header-anchor" href="#_19-b-树-b-树两者有何异同呢" aria-hidden="true">#</a> 19.<strong>B 树&amp; B+树两者有何异同呢？</strong></h3><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点(双向链表)。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p>​ 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。</p><p>​ MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引</strong>”。</p><p>​ InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引</strong>（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><h3 id="_20-索引类型" tabindex="-1"><a class="header-anchor" href="#_20-索引类型" aria-hidden="true">#</a> 20.索引类型?</h3><ul><li><strong>主键索引(Primary Key)</strong></li></ul><p>​ 数据表的主键列使用的就是主键索引。</p><p>​ 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>​ 在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><figure><img src="https://minio.pigx.top/oss/2022/07/8HUiNu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>二级索引(辅助索引)</strong></li></ul><p>​ <strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>​ 唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p>二级索引:</p><figure><img src="https://minio.pigx.top/oss/2022/07/aWnMJ1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_21-聚集索引与非聚集索引以及优缺点" tabindex="-1"><a class="header-anchor" href="#_21-聚集索引与非聚集索引以及优缺点" aria-hidden="true">#</a> 21.聚集索引与非聚集索引以及优缺点?</h3><ul><li>聚集索引</li></ul><p>​ <strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>​ 在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p>​ <strong>聚集索引的优点:</strong></p><p>​ 聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><p>​ <strong>聚集索引的缺点：</strong></p><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><ul><li>非聚集索引</li></ul><p>​ <strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p><p>​ <strong>二级索引属于非聚集索引。</strong></p><p>​ 非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><p>​ <strong>非聚集索引的优点：</strong></p><p>​ <strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><p>​ <strong>非聚集索引的缺点：</strong></p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><p>​ 聚集索引和非聚集索引:</p><figure><img src="https://minio.pigx.top/oss/2022/07/su79VT.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_22-非聚集索引一定回表查询吗-覆盖索引" tabindex="-1"><a class="header-anchor" href="#_22-非聚集索引一定回表查询吗-覆盖索引" aria-hidden="true">#</a> 22.非聚集索引一定回表查询吗(覆盖索引)?</h3><p><strong>非聚集索引不一定回表查询。</strong></p><h3 id="_23-覆盖索引" tabindex="-1"><a class="header-anchor" href="#_23-覆盖索引" aria-hidden="true">#</a> 23.覆盖索引？</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是<strong>主键+列值</strong>。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/2mBGBo.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_24-联合索引" tabindex="-1"><a class="header-anchor" href="#_24-联合索引" aria-hidden="true">#</a> 24.联合索引？</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><h3 id="_25-最左前缀匹配原则" tabindex="-1"><a class="header-anchor" href="#_25-最左前缀匹配原则" aria-hidden="true">#</a> 25.最左前缀匹配原则</h3><p>​ 最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>、<strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p><p>​ 所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h3 id="_26-创建索引的注意事项" tabindex="-1"><a class="header-anchor" href="#_26-创建索引的注意事项" aria-hidden="true">#</a> 26.创建索引的注意事项？</h3><p><strong>1.选择合适的字段创建索引：</strong></p><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p><p>​ 虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p><p>​ 因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><p><strong>4.注意避免冗余索引</strong> 。</p><p>​ 冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><p>​ 前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引</p><h3 id="_27-使用索引的一些建议" tabindex="-1"><a class="header-anchor" href="#_27-使用索引的一些建议" aria-hidden="true">#</a> 27.使用索引的一些建议？</h3><ul><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ul><h3 id="_28-redo-log是什么-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#_28-redo-log是什么-mysql为什么不丢数据" aria-hidden="true">#</a> 28.<a name="mysql-redo-log"></a>redo log是什么？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>​ <code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p>​ 比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p><figure><img src="https://minio.pigx.top/oss/2022/07/Xj4vmP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ <code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p><p>​ 后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>​ 更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>​ 然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p><figure><img src="https://minio.pigx.top/oss/2022/07/qDRWjN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_29-redo-log刷盘时机-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#_29-redo-log刷盘时机-mysql为什么不丢数据" aria-hidden="true">#</a> 29.redo log刷盘时机？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p><figure><img src="https://minio.pigx.top/oss/2022/07/87fvqr.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/HGFiR7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>innodb_flush_log_at_trx_commit=0时</strong>，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p><figure><img src="https://minio.pigx.top/oss/2022/07/tMdLxm.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>innodb_flush_log_at_trx_commit=1</strong>时，只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p><figure><img src="https://minio.pigx.top/oss/2022/07/gP3lsU.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>innodb_flush_log_at_trx_commit=2时</strong>，只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p><figure><img src="https://minio.pigx.top/oss/2022/07/kbkKuY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_30-为什么不直接刷盘修改后的数据-而是刷盘redo-log-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#_30-为什么不直接刷盘修改后的数据-而是刷盘redo-log-mysql为什么不丢数据" aria-hidden="true">#</a> 30.为什么不直接刷盘修改后的数据，而是刷盘redo log?<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>​ 数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，没有必要把完整的数据页刷盘。</p><p>​ 而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>​ 如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>​ 所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p><h3 id="_31-什么是binlog-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#_31-什么是binlog-mysql为什么不丢数据" aria-hidden="true">#</a> 31.什么是binlog？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>​ <code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><p>​ 而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>​ 不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p><p>​ <code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><p>​ <code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><figure><img src="https://minio.pigx.top/oss/2022/07/1yQA7j.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_32-binlog记录格式-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#_32-binlog记录格式-mysql为什么不丢数据" aria-hidden="true">#</a> 32.binlog记录格式？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong></li><li><strong>row</strong></li><li><strong>mixed</strong></li></ul><p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p><figure><img src="https://minio.pigx.top/oss/2022/07/MkA1ZE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p><p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p><figure><img src="https://minio.pigx.top/oss/2022/07/e4MfiB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p><p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p><p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</p><h3 id="_33-binlog的写入机制-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#_33-binlog的写入机制-mysql为什么不丢数据" aria-hidden="true">#</a> 33.binlog的写入机制？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p><code>binlog</code>日志刷盘流程如下</p><figure><img src="https://minio.pigx.top/oss/2022/07/c03Uor.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_34-undo-log-mysql为什么不丢数据" tabindex="-1"><a class="header-anchor" href="#_34-undo-log-mysql为什么不丢数据" aria-hidden="true">#</a> 34.undo log？<a href="#mysql-logs">Mysql为什么不丢数据</a></h3><p>​ 我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。</p><p>​ 如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>​ MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p>​ <code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><h3 id="_35-mysql的事务隔离级别有哪几种-默认的是哪一种" tabindex="-1"><a class="header-anchor" href="#_35-mysql的事务隔离级别有哪几种-默认的是哪一种" aria-hidden="true">#</a> 35.mysql的事务隔离级别有哪几种？默认的是哪一种？</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">READ-UNCOMMITTED</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">READ-COMMITTED</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">REPEATABLE-READ</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">SERIALIZABLE</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p><p>标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。</p><p>但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong> ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong> ： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul><h3 id="_36-解决幻读的方法" tabindex="-1"><a class="header-anchor" href="#_36-解决幻读的方法" aria-hidden="true">#</a> 36.解决幻读的方法？</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p><ol><li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li></ol><h3 id="_37-一致性非锁定读和锁定读" tabindex="-1"><a class="header-anchor" href="#_37-一致性非锁定读和锁定读" aria-hidden="true">#</a> 37.一致性非锁定读和锁定读?</h3><p><strong>一致性非锁定读</strong></p><p>​ 对于 **一致性非锁定读（Consistent Nonlocking Reads）**的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见。</p><p>​ 在 <code>InnoDB</code> 存储引擎中，**[多版本控制 (multi versioning)]**就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)。</p><p>​ 在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/12/R0M0Ls.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>锁定读</strong></p><p>如果执行的是下列语句，就是 [<strong>锁定读（Locking Reads）</strong>]</p><ul><li><code>select ... lock in share mode</code></li><li><code>select ... for update</code></li><li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li></ul><p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p><ul><li><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li><li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul><p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。</p><p>上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong>。</p><h3 id="_38-sql注入问题" tabindex="-1"><a class="header-anchor" href="#_38-sql注入问题" aria-hidden="true">#</a> 38.sql注入问题？</h3><p>原因:用户传入的参数中注入符合sql的语法，从而破坏原有sql结构语意，达到攻击效果。</p><h3 id="_39-什么是3nf-范式" tabindex="-1"><a class="header-anchor" href="#_39-什么是3nf-范式" aria-hidden="true">#</a> 39.什么是3NF（范式）?</h3><p>1NF 指的是数据库表中的任何属性都具有原子性的，不可再分解。</p><p>2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性。</p><p>3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</p><h3 id="_40-null和空串判断" tabindex="-1"><a class="header-anchor" href="#_40-null和空串判断" aria-hidden="true">#</a> 40.NULL和空串判断?</h3><p>NULL值是没有值,，它不是空串。如果指定&#39;&#39;(两个单引号，其间没有字符)，这在NOT NULL列中是允许 的。空串是一个有效的值，它不是无值。</p><p>判断NULL需要用 IS NULL 或者 IS NOT NULL。</p><h3 id="_41-like走索引吗" tabindex="-1"><a class="header-anchor" href="#_41-like走索引吗" aria-hidden="true">#</a> 41.like走索引吗?</h3><p>Xxx% 走索引， %xxx不走索引。</p><h3 id="_42-主键和唯一索引区别" tabindex="-1"><a class="header-anchor" href="#_42-主键和唯一索引区别" aria-hidden="true">#</a> 42.主键和唯一索引区别？</h3><p>本质区别，主键是一种约束，唯一索引是一种索引。 主键不能有空值（非空+唯一），唯一索引可以为空。 主键可以是其他表的外键，唯一索引不可以。 一个表只能有一个主键，唯一索引可以多个。 都可以建立联合主键或联合唯一索引。 主键-》聚簇索引，唯一索引-&gt;非聚簇索引。</p><h3 id="_43-索引不生效的情况" tabindex="-1"><a class="header-anchor" href="#_43-索引不生效的情况" aria-hidden="true">#</a> 43.索引不生效的情况？</h3><p>使用不等于查询 NULL值</p><p>列参与了数学运算或者函数</p><p>在字符串like时左边是通配符.比如 %xxx</p><p>当mysql分析全表扫描比使用索引快的时候不使用索引.</p><p>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/04/3Vi0M0.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_44-mvvc" tabindex="-1"><a class="header-anchor" href="#_44-mvvc" aria-hidden="true">#</a> 44.MVVC？</h3><p>MVCC 全称是多版本并发控制系统，是一种用来解决读 - 写冲突的无锁并发控制。</p><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p><p>也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳 关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。这样在读操作不用阻塞写操 作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/12/R0M0Ls.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_45-varchar-10-和int-10-代表什么含义" tabindex="-1"><a class="header-anchor" href="#_45-varchar-10-和int-10-代表什么含义" aria-hidden="true">#</a> 45.varchar(10)和int(10)代表什么含义？</h3><p>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度。</p><p>int的10只是代表了展示的长度, 不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示 时按照长度展示。</p><h3 id="_46-count-在不同引擎的实现方式" tabindex="-1"><a class="header-anchor" href="#_46-count-在不同引擎的实现方式" aria-hidden="true">#</a> 46.count(*)在不同引擎的实现方式?</h3><p>MyISAM :把一个表的总行数存在了磁盘上，执行 count(<em>) 的时候会直接返回这个数，效率很高。</em></p><p>InnoDB : 比较麻烦，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p><h3 id="_47-锁的类型有哪些呢" tabindex="-1"><a class="header-anchor" href="#_47-锁的类型有哪些呢" aria-hidden="true">#</a> 47.锁的类型有哪些呢？</h3><p>​ mysql 锁分为共享锁和排他锁，也叫做读锁和写锁。</p><p>​ 读锁是共享的，可以通过 lock in share mode 实现，这时候只能读不能写。</p><p>​ 写锁是排他的，它会阻塞其他的写锁和读锁。</p><p>​ 从颗粒度来区分，可以分为表锁和行锁两种。 表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如 alter 修改表结构的时候会锁表。 行锁又可以分为乐观锁和悲观锁，悲观锁可以通过 for update 实现，乐观锁则通过版本号实现。</p><h3 id="_48-那-acid-靠什么保证的呢" tabindex="-1"><a class="header-anchor" href="#_48-那-acid-靠什么保证的呢" aria-hidden="true">#</a> 48.那 ACID 靠什么保证的呢？</h3><p><strong>A</strong> 原子性由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql</p><p><strong>C</strong> 一致性是由其他三大特性保证，程序代码要保证业务上的一致性</p><p><strong>I</strong> 隔离性由 MVCC 来保证</p><p><strong>D</strong> 持久性由内存 + redo log 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，事务提交的 时候通过 redo log 刷盘，宕机的时候可以从 redo log 恢复</p><h3 id="_49-说说-mysql-主从同步怎么做的吧" tabindex="-1"><a class="header-anchor" href="#_49-说说-mysql-主从同步怎么做的吧" aria-hidden="true">#</a> 49.说说 mysql 主从同步怎么做的吧？</h3><p>首先先了解 mysql 主从同步的原理</p><ol><li><p>master 提交完事务后，写入 binlog</p></li><li><p>slave 连接到 master，获取 binlog</p></li><li><p>master 创建 dump 线程，推送 binglog 到 slave</p></li><li><p>slave 启动一个 IO 线程读取同步过来的 master 的 binlog，记录到 relay log 中继日志中</p></li><li><p>slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步</p></li><li><p>slave 记录自己的 binglog</p></li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/0WPBBl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会 产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此 产生两个概念。</p><p><strong>全同步复制</strong></p><p>主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方 式的话性能会受到严重影响。</p><p><strong>半同步复制</strong></p><p>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回 ACK 确认给主库，主库收到至 少一个从库的确认就认为写操作完成。</p><h3 id="_50-解释mysql外连接、内连接与自连接的区别" tabindex="-1"><a class="header-anchor" href="#_50-解释mysql外连接、内连接与自连接的区别" aria-hidden="true">#</a> 50.解释MySQL外连接、内连接与自连接的区别？</h3><p>先说什么是交叉连接: 交叉连接又叫<strong>笛卡尔积</strong>，它是指不使用任何条件，直接将一个表的所有记录和另一 个表中的所有记录一一匹配。</p><p><strong>内连接</strong> 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在 结果集中，即内连接只连接匹配的行。</p><p><strong>外连接</strong> 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中 的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p><p>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没 有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。</p><p>右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连 接。</p><h3 id="_51-sql语言包括哪几部分-每部分都有哪些操作关键字" tabindex="-1"><a class="header-anchor" href="#_51-sql语言包括哪几部分-每部分都有哪些操作关键字" aria-hidden="true">#</a> 51.SQL语言包括哪几部分？每部分都有哪些操作关键字？</h3><p>SQL语言包括数据定义(<strong>DDL</strong>)、数据操纵(<strong>DML</strong>),数据控制(<strong>DCL</strong>)和数据查询（<strong>DQL</strong>）四个部分。</p><p>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等</p><p>数据操纵：Select ,insert,update,delete,</p><p>数据控制：grant,revoke</p><p>数据查询：select</p><h3 id="_52-数据库的三范式是什么" tabindex="-1"><a class="header-anchor" href="#_52-数据库的三范式是什么" aria-hidden="true">#</a> 52.数据库的三范式是什么？</h3><p>第一范式：列不可再分</p><p>第二范式：行可以唯一区分，主键约束</p><p>第三范式：表的非主属性不能依赖与 其他表的非主属性 外键约束</p><h3 id="_53-sql优化手段有哪些" tabindex="-1"><a class="header-anchor" href="#_53-sql优化手段有哪些" aria-hidden="true">#</a> 53.SQL优化手段有哪些？</h3><p>1、查询语句中不要使用select * (无法覆盖索引)</p><p>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</p><p>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代</p><p>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时， union all会更好)</p><p>5、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表 扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有 null值，然后这样查询： select id from t where num=0</p><h3 id="_54-简单说一说drop、delete与truncate的区别" tabindex="-1"><a class="header-anchor" href="#_54-简单说一说drop、delete与truncate的区别" aria-hidden="true">#</a> 54.简单说一说drop、delete与truncate的区别？</h3><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p><p>delete和truncate只删除表的数据不删除表的结构 速度,一般来说: drop&gt; truncate &gt;delete delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效; 如果有相应的trigger,执行 的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p><h3 id="_55-大表如何优化" tabindex="-1"><a class="header-anchor" href="#_55-大表如何优化" aria-hidden="true">#</a> 55.大表如何优化？</h3><ol><li><strong>限定数据的范围</strong></li></ol><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们 可以控制在一个月的范围内；</p><ol start="2"><li><strong>读/写分离</strong></li></ol><p>经典的数据库拆分方案，主库负责写，从库负责读；</p><ol start="3"><li><strong>垂直分区</strong></li></ol><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信 息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</p><p>垂直拆分的优点： 可以使得列数据变小， 简化表的结构，易于维护。</p><p>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层 进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><ol start="4"><li><strong>水平分区</strong></li></ol><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达 到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据 拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单 一表数据量过大对性能造成影响。</p><p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问 题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平 拆分最好分库 。</p><p>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能 较差，逻辑复杂。</p><p>下面补充一下数据库分片的两种常见方案：</p><p>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网 的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</p><p>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现 在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p><h3 id="_56-为什么-select-count-from-table-在-innodb-比-myisam-慢" tabindex="-1"><a class="header-anchor" href="#_56-为什么-select-count-from-table-在-innodb-比-myisam-慢" aria-hidden="true">#</a> 56.为什么 SELECT COUNT(<em>) FROM table 在 InnoDB 比 MyISAM 慢？</em></h3><p>对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可 能会慢很多，尤其在大表的情况下。因为，InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。</p><h3 id="_57-主键与索引有什么区别" tabindex="-1"><a class="header-anchor" href="#_57-主键与索引有什么区别" aria-hidden="true">#</a> 57.主键与索引有什么区别？</h3><p>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</p><p>主键不允许为空值，唯一索引列允许空值；</p><p>一个表只能有一个主键，但是可以有多个唯一索引；</p><p>主键可以被其他表引用为外键，唯一索引列不可以；</p><p>主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本</p><h3 id="_58-可以使用多少列创建索引" tabindex="-1"><a class="header-anchor" href="#_58-可以使用多少列创建索引" aria-hidden="true">#</a> 58.可以使用多少列创建索引？</h3><p>任何标准表最多可以创建 16 个索引列。</p><h3 id="_59-mysql锁的类型有哪些" tabindex="-1"><a class="header-anchor" href="#_59-mysql锁的类型有哪些" aria-hidden="true">#</a> 59.mysql锁的类型有哪些？</h3><p>基于锁的属性分类：共享锁、排他锁。</p><p>基于锁的粒度分类：行级锁（innodb ）、表级锁（ innodb 、myisam）、页级锁（ innodb引擎）、记录锁、间隙锁、临键锁。</p><p>基于锁的状态分类：意向共享锁、意向排它锁。</p><p>共享锁（share lock）： 共享锁又称读锁，简称 S 锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</p><p>排他锁（exclusive lock）：排他锁又称写锁，简称 X 锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取，避免了出现脏数据和脏读的问题。</p><p>表锁（table lock）：表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；特点：粒度大，加锁简单，容易冲突；</p><p>行锁：行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问，特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高</p><p>记录锁（Record lock）:记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录，加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题</p><p>页锁：页级锁是 MysQL 中锁定粒度介于行级锁和表级锁中间的一种锁．表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。特点：开销和加锁时间界于表锁和行锁之间，会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>间隙锁：是属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读）的事务级别中。</p><p>临键锁（Next-Key lock)：也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</p><h3 id="_60-怎么处理mysql的慢查询" tabindex="-1"><a class="header-anchor" href="#_60-怎么处理mysql的慢查询" aria-hidden="true">#</a> 60.怎么处理MySQL的慢查询？</h3><p>1、开启慢查询日志，准确定位到哪个sql语句出现了问题。</p><p>2、分析sql语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</p><p>3、分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</p><p>4、如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p><h3 id="_61-什么是mysql的主从复制" tabindex="-1"><a class="header-anchor" href="#_61-什么是mysql的主从复制" aria-hidden="true">#</a> 61.什么是mysql的主从复制？</h3><p>​ MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h3 id="_62-mysql为什么需要主从同步" tabindex="-1"><a class="header-anchor" href="#_62-mysql为什么需要主从同步" aria-hidden="true">#</a> 62.mysql为什么需要主从同步？</h3><p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p>2、做数据的热备</p><p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p><h3 id="_63-innodb是如何实现事务的" tabindex="-1"><a class="header-anchor" href="#_63-innodb是如何实现事务的" aria-hidden="true">#</a> 63.Innodb是如何实现事务的</h3><p>Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例：</p><ol><li><p>Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在Buffer Pool中</p></li><li><p>执⾏update语句，修改Buffer Pool中的数据，也就是内存中的数据</p></li><li><p>针对update语句⽣成⼀个RedoLog对象，并存⼊LogBuffer中</p></li><li><p>针对update语句⽣成undolog⽇志，⽤于事务回滚</p></li><li><p>如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将Buffer Pool中所修改的数据⻚持久化到磁盘中</p></li><li><p>如果事务回滚，则利⽤undolog⽇志进⾏回滚</p></li></ol><h3 id="_64-b-树和-b-树的理解" tabindex="-1"><a class="header-anchor" href="#_64-b-树和-b-树的理解" aria-hidden="true">#</a> 64.b 树和 b+树的理解</h3><p>二叉树，每个节点支持两个分支的树结构，相比于单向链表，多了一个分支。</p><p>二叉查找树，在二叉树的基础上增加了一个规则，左子树的所有节点的值都小于它的根节点，右子树的所有子节点都大于它的根节点。</p><figure><img src="https://minio.pigx.top/oss/2022/08/yUVMQu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>二叉查找树会出现斜树问题，导致时间复杂度增加，因此又引入了一种平衡二叉树，它具有二叉查找树的所有特点，同时增加了一个规则：”它的左右两个子 树的高度差的绝对值不超过 1“。平衡二叉树会采用左旋、右旋的方式来实现平 衡。</p><figure><img src="https://minio.pigx.top/oss/2022/08/fIbPve.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>而 B 树是一种多路平衡查找树，它满足平衡二叉树的规则，但是它可以有多 个子树，子树的数量取决于关键字的数量，比如这个图中根节点有两个关键字 3 和 5，那么它能够拥有的子路数量=关键字数+1。</p><p>因此从这个特征来看，在存储同样数据量的情况下，平衡二叉树的高度要大于 B 树。</p><figure><img src="https://minio.pigx.top/oss/2022/08/vorQ5u.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B+树，其实是在 B 树的基础上做的增强，最大的区别有两个：</p><p>B 树的数据存储在每个节点上，而 B+树中的数据是存储在叶子节点，并且通过 链表的方式把叶子节点中的数据进行连接。</p><p>B+树的子路数量等于关键字数</p><p>（如图所示）这个是 B 树的存储结构，从 B 树上可以看到每个节点会存储数据。</p><figure><img src="https://minio.pigx.top/oss/2022/08/GqiEPV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（如图所示）这个是 B+树，B+树的所有数据是存储在叶子节点，并且叶子节点 的数据是用双向链表关联的。</p><figure><img src="https://minio.pigx.top/oss/2022/08/vQXOSH.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>B 树和 B+树，一般都是应用在文件系统和数据库系统中，用来减少磁盘 IO 带来 的性能损耗。</p><p>以 Mysql 中的 InnoDB 为例，当我们通过select语句去查询一条数据时，InnoDB需要从磁盘上去读取数据，这个过程会涉及到磁盘 IO 以及磁盘的随机 IO（如图 所示）</p><p>我们知道磁盘 IO 的性能是特别低的，特别是随机磁盘 IO。</p><p>很明显，磁盘 IO 这个过程的性能开销是非常大的，特别是查询的数据量比较多 的情况下。</p><p>所以在 InnoDB 中，干脆对存储在磁盘块上的数据建立一个索引，然后把索引数 据以及索引列对应的磁盘地址，以 B+树的方式来存储。</p><p>如图所示，当我们需要查询目标数据的时候，根据索引从 B+树中查找目标数据 即可，由于 B+树分路较多， 所以只需要较少次数的磁盘 IO 就能查找到。</p><p><strong>为什么用 B 树或者 B+树来做索引结构？</strong></p><p>原因是 AVL（平衡二叉树） 树的高度要比 B 树的高度 要高，而高度就意味着磁盘 IO 的数量。所以为了减少磁盘 IO 的次数，文件系 统或者数据库才会采用 B 树或者 B+树。</p><p><a href="https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/d7Zfat2fP6IX5DMKKtEIjQ<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_65-for-update的作用和用法" tabindex="-1"><a class="header-anchor" href="#_65-for-update的作用和用法" aria-hidden="true">#</a> 65.for update的作用和用法？</h3><p><strong>一、for update定义</strong></p><p>for update是一种<strong>行级锁，又叫排它锁</strong>，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。</p><p>只有当出现如下之一的条件，才会释放共享更新锁： 1、执行提交（COMMIT）语句 2、退出数据库（LOG　OFF） 3、程序停止运行</p><p><strong>2、概念和用法</strong></p><p>通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。</p><p>而select … for update 语句是我们经常使用手工加锁语句。在数据库中执行select … for update ,大家会发现会对数据库中的表或某些行数据进行锁表，在mysql中，如果查询条件带有主键，会锁行数据，如果没有，会锁表。</p><p>由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。</p><p>举个例子: 假设有张表user ，里面有 id 和 name 两列，id是主键。</p><p>例1: (明确指定主键，并且数据真实存在，row lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE id=3 FOR UPDATE;

SELECT * FROM user WHERE id=3 and name=&#39;Tom&#39; FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例2: (明确指定主键，但数据不存在，无lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE id=0 FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例3: (主键不明确，table lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE id&lt;&gt;3 FOR UPDATE;

SELECT * FROM user WHERE id LIKE &#39;%3%&#39; FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例4: (无主键，table lock)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM user WHERE name=&#39;Tom&#39; FOR UPDATE;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意： 1、FOR UPDATE仅适用于InnoDB，且必须在事务处理模块(BEGIN/COMMIT)中才能生效。</p><p>2、要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。</p><p>3、Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。</p><p><strong>3、什么时候需要使用for update？</strong></p><p>借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。</p><p>场景上，比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。</p><p><strong>4、for update悲观锁</strong></p><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它解锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。就像for update，再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p><h3 id="_66-如何保证-repeatable-read-级别绝对不产生幻读" tabindex="-1"><a class="header-anchor" href="#_66-如何保证-repeatable-read-级别绝对不产生幻读" aria-hidden="true">#</a> 66.如何保证 REPEATABLE READ 级别绝对不产⽣幻读？</h3><p>在SQL中加⼊ for update (排他锁) 或 lock in share mode (共享锁)语句实现。就是锁住了可能造成幻读的数据，阻⽌数据的写⼊操 作。</p><h3 id="_67-mysql的update的加锁情况" tabindex="-1"><a class="header-anchor" href="#_67-mysql的update的加锁情况" aria-hidden="true">#</a> 67.mysql的update的加锁情况</h3><p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。 <strong>1.使用了唯一索引</strong> 在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。 <strong>2.没有使用索引</strong> 在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。</p><h3 id="_68-mysql的数据存在磁盘上到底长什么样" tabindex="-1"><a class="header-anchor" href="#_68-mysql的数据存在磁盘上到底长什么样" aria-hidden="true">#</a> 68.MySQL的数据存在磁盘上到底长什么样</h3><p><strong>MyISAM</strong></p><p>每个 <code>MyISAM</code> 表都以3个文件存储在磁盘上。这些文件的名称以表名开头，以扩展名指示文件类型。</p><p><code>.frm</code> 文件（frame）存储表<strong>结构</strong>；</p><p><code>.MYD</code> 文件（MY Data）存储表<strong>数据</strong>；</p><p><code>.MYI</code> 文件（MY Index）存储表<strong>索引</strong>。</p><p><code>MySQL</code> 里的数据默认是存放在安装目录下的 data 文件夹中，也可以自己修改。</p><p><code>.MYI</code> 文件组织索引的方式就是 <code>B+tree</code>。叶子节点的 value 处存放的就是<strong>索引所在行的磁盘文件地址</strong>。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/uPOiXS.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>底层查找过程</strong>：</p><p>首先会判断查找条件 <code>where</code> 中的字段是否是索引字段，如果是就会先拿着这字段去 <code>.MYI</code> 文件里通过 <code>B+tree</code> 快速定位，从根节点开始定位查找；</p><p>找到后再把这个索引关键字（就是我们的条件）存放的磁盘文件地址拿到 <code>.MYD</code> 文件里面找，从而定位到索引所在行的记录。</p><blockquote><p>表逻辑上相邻的记录行数据在磁盘上并不一定是物理相邻的。</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/vLPYia.gif" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>InnoDB</strong></p><p>一张 <code>InnoDB</code> 表底层会对应<strong>2个</strong>文件在文件夹中进行数据存储。</p><p><code>.frm</code> 文件（frame）存储表<strong>结构</strong>；</p><p><code>.ibd</code> 文件（InnoDB Data）存储表<strong>索引+数据</strong>。</p><p>很显然，<code>InnoDB</code> 把索引和数据都放在一个文件里存着了。毫无疑问，<code>InnoDB</code> 表里面的数据也是用 <code>B+tree</code> 数据结构组织起来的。</p><p>下面我们来看看它具体是怎么存储的。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/VWjGsw.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>.ibd</code> 存储数据的特点就是 <code>B+tree</code> 的叶子节点上<strong>包括了我们要的索引和该索引所在行的其它列数据</strong>。</p><p><strong>底层查找过程</strong>：</p><p>首先会判断查找条件 <code>where</code> 中的字段是否是索引字段，如果是就会先拿着这字段去 <code>.ibd</code> 文件里通过 <code>B+tree</code> 快速定位，从根节点开始定位查找；</p><p>找到后直接把这个索引关键字及其记录所在行的其它列数据返回。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/09/HSUnHG.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_69-为什么用了索引-sql查询还是慢" tabindex="-1"><a class="header-anchor" href="#_69-为什么用了索引-sql查询还是慢" aria-hidden="true">#</a> 69.为什么用了索引，SQL查询还是慢？</h3><p>慢查询归纳起来大概有这么几种情况：</p><ul><li>全表扫描</li><li>全索引扫描</li><li>索引过滤性不好</li><li>频繁回表的开销</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/10/4lRMDG.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_70-什么是三星索引" tabindex="-1"><a class="header-anchor" href="#_70-什么是三星索引" aria-hidden="true">#</a> 70.什么是三星索引？</h3><ol><li><strong>第一颗星 - 使用合适的索引</strong>：确保在<code>WHERE</code>子句中的查询列构成了合适的单列索引或联合索引，以加速数据检索。这是为了减小数据查找的开销，提高查询性能。</li><li><strong>第二颗星 - 避免排序</strong>：当查询中涉及<code>ORDER BY</code>子句时，如果查询结果已经按所需列排序，就可以避免生成临时表或执行排序操作，从而提高查询效率。</li><li><strong>第三颗星 - 覆盖索引</strong>：选择在<code>SELECT</code>中包含尽可能多的索引列，以避免回表查询。回表查询是指在索引中找到匹配行后，还需要进一步检索主表中的数据。通过选择索引列，可以减少回表查询的需求，从而提高查询性能。</li></ol><h3 id="_71-count-1-和count-哪个效率高" tabindex="-1"><a class="header-anchor" href="#_71-count-1-和count-哪个效率高" aria-hidden="true">#</a> 71.count(1)和count(*) 哪个效率高？</h3><p><strong>count(1)和count(列名)对比</strong></p><p>两者的主要区别是：</p><ul><li><code>count(1)</code> 会统计表中的所有的记录数，包含字段为 <code>null</code> 的记录。</li><li><code>count(字段)</code> 会统计该字段在表中出现的次数，忽略字段为 <code>null</code> 的情况。即不统计字段为 <code>null</code> 的记录。</li></ul><hr><p><strong>count(*)、count(1)和count(列名)区别</strong></p><p><strong>执行效果上：</strong></p><ul><li><code>count(*)</code>包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li><code>count(1)</code>包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li><code>count(列名)</code>只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p><strong>执行效率上：</strong></p><ul><li>列名为主键， <code>count(列名)</code> 会比 <code>count(1)</code>快</li><li>列名不为主键， <code>count(1)</code> 会比 <code>count(列名)</code>快</li><li>如果表多个列并且没有主键，则 <code>count(1)</code> 的执行效率优于 <code>count(*)</code></li><li>如果有主键，则 <code>selectcount(主键)</code> 的执行效率是最优的</li><li>如果表只有一个字段，则 <code>selectcount（*）</code>最优。</li></ul><h3 id="_72-《阿里巴巴java开发手册》里面写超过三张表禁止join-这是为什么-这样的话那sql要怎么写" tabindex="-1"><a class="header-anchor" href="#_72-《阿里巴巴java开发手册》里面写超过三张表禁止join-这是为什么-这样的话那sql要怎么写" aria-hidden="true">#</a> 72.《阿里巴巴JAVA开发手册》里面写超过三张表禁止join 这是为什么？这样的话那sql要怎么写？</h3><p>做这个限制有两个原因：一是优化器很弱，涉及多个表的查询，往往得不到很好的查询计划，这块比较复杂，感兴趣的朋友可以关注我，我以后会写文章专门介绍；二是<a href="https://www.zhihu.com/search?q=%E6%89%A7%E8%A1%8C%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">执行器<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>很弱，只有nested loop join，block nested loop join和index nested loop join。</p><ol><li><p>nested loop join就是分别从两个表读一行数据进行两两对比，<a href="https://www.zhihu.com/search?q=%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">复杂度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是n^2</p></li><li><p>block nested loop join是分别从两个表读很多行数据，然后进行两两对比，复杂度也是n^2，只是少了些<a href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">函数调用<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>等overhead</p></li><li><p>index nested loop join是从第一个表读一行，然后在第二个表的索引中查找这个数据，索引是B+树索引，复杂度可以近似认为是<a href="https://www.zhihu.com/search?q=nlogn&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">nlogn<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，比上面两个好很多，<strong>这就是要保证关联字段有索引的原因</strong></p></li><li><p>如果有hash join，就不用做这种限制了，用第一个表（小表）建hash table，第二个表在[hash table](<a href="https://www.zhihu.com/search?q=hash" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/search?q=hash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> table&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A153450286})中查找匹配的项，复杂度是n。缺点是hash table占的内存可能会比较大，不过也有基于磁盘的[hash join](<a href="https://www.zhihu.com/search?q=hash" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/search?q=hash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> join&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A153450286})，实现起来比较复杂</p></li></ol><p><strong>二：在这种限制下SQL怎么写？</strong></p><p>可是我确实需要两个表里的数据链接在一起啊，我们可以做个<a href="https://www.zhihu.com/search?q=%E5%86%97%E4%BD%99&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">冗余<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，建表的时候，就把这些列放在一个表里，比如一开始有student(id, name)，class(id, description)，student_class(student_id, class_id)三张表，这样是符合数据库范式的(第一范式，第二范式，<a href="https://www.zhihu.com/search?q=%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">第三范式<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，BC范式等)，没有任何冗余，但是马上就不符合“编程规范“了，那我们可以用一张大表代替它，<a href="https://www.zhihu.com/search?q=student_class_full&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">student_class_full<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>(student_id, class_id, name, description)，这样name和<a href="https://www.zhihu.com/search?q=description&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">description<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>可能要被存储多份，但是由于不需要join了，查询的性能就可以提高很多了。</p><p>任何的<a href="https://www.zhihu.com/search?q=%E8%A7%84%E8%8C%83&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A153450286%7D" target="_blank" rel="noopener noreferrer">规范<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>都是在特定情况下的某种妥协，脱离了这个环境，就不一定成立了。</p><h3 id="_73-什么是mysql的索引下推" tabindex="-1"><a class="header-anchor" href="#_73-什么是mysql的索引下推" aria-hidden="true">#</a> 73.什么是mysql的索引下推</h3><p>MySQL的索引下推（Index Condition Pushdown）是一种查询优化技术，它允许数据库在执行查询时使用索引来过滤不满足条件的行，而不必读取整个数据行，从而提高查询性能。</p><p>具体来说，索引下推的工作方式如下：</p><ol><li><p>当执行一个查询时，MySQL会首先使用索引来查找满足查询条件的行。</p></li><li><p>然后，MySQL会对使用索引定位到的行应用查询中的额外过滤条件。这些额外的条件可以是与索引列无关的其他列的条件。</p></li><li><p>如果行满足额外的过滤条件，它将被包括在查询结果中，否则将被丢弃。</p></li></ol><p>索引下推的优势在于它减少了磁盘和内存的读取操作，因为不需要读取整个数据行，而只需读取索引和满足额外条件的行。这降低了查询的I/O开销，提高了查询性能。</p><h3 id="_74-mysql为什么不丢数据-mysql七种日志" tabindex="-1"><a class="header-anchor" href="#_74-mysql为什么不丢数据-mysql七种日志" aria-hidden="true">#</a> <a name="mysql-logs"></a>74.mysql为什么不丢数据(mysql七种日志)</h3><p><strong>Mysql逻辑架构</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/ZblHgP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MySQL的逻辑架构大致可以分为三层：</p><ul><li>第一层：处理客户端连接、授权认证，安全校验等。</li><li>第二层：服务器<code>server</code>层，负责对SQL解释、分析、优化、执行操作引擎等。</li><li>第三层：存储引擎，负责MySQL中数据的存储和提取。</li></ul><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/5jIwam.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>redo log（重做日志）</strong><a href="#mysql-redo-log">什么是redo log以及redo log刷盘策略</a></p><p><code>redo log</code>属于MySQL存储引擎<code>InnoDB</code>的事务日志。</p><p>MySQL的数据是存放在磁盘中的，每次读写数据都需做磁盘IO操作，如果并发场景下性能就会很差。为此MySQL提供了一个优化手段，引入缓存<code>Buffer Pool</code>。这个缓存中包含了磁盘中<strong>部分</strong>数据页（<code>page</code>）的映射，以此来缓解数据库的磁盘压力。</p><p>当从数据库读数据时，首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入缓存；当向数据库写入数据时，先向缓存写入，此时缓存中的数据页数据变更，这个数据页称为<strong>脏页</strong>，<code>Buffer Pool</code>中修改完数据后会按照设定的更新策略，定期刷到磁盘中，这个过程称为<strong>刷脏页</strong>。</p><p><strong>MySQL宕机</strong></p><p>如果刷脏页还未完成，可MySQL由于某些原因宕机重启，此时<code>Buffer Pool</code>中修改的数据还没有及时的刷到磁盘中，就会导致数据丢失，无法保证事务的持久性。</p><p>为了解决这个问题引入了<code>redo log</code>，redo Log如其名侧重于重做！它记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置。</p><p><code>redo log</code>用到了<code>WAL</code>（Write-Ahead Logging）技术，这个技术的核心就在于修改记录前，一定要先写日志，并保证日志先落盘，才能算事务提交完成。</p><p>有了redo log再修改数据时，InnoDB引擎会把更新记录先写在redo log中，在修改<code>Buffer Pool</code>中的数据，当提交事务时，调用<code>fsync</code>把redo log刷入磁盘。至于缓存中更新的数据文件何时刷入磁盘，则由后台线程异步处理。</p><blockquote><p><strong>注意</strong>：此时redo log的事务状态是<code>prepare</code>，还未真正提交成功，要等<code>bin log</code>日志写入磁盘完成才会变更为<code>commit</code>，事务才算真正提交完成。</p></blockquote><p>这样一来即使刷脏页之前MySQL意外宕机也没关系，只要在重启时解析redo log中的更改记录进行重放，重新刷盘即可。</p><p><strong>大小固定</strong></p><p>redo log采用固定大小，循环写入的格式，当redo log写满之后，重新从头开始如此循环写，形成一个环状。</p><p>那为什么要如此设计呢？</p><p>因为redo log记录的是数据页上的修改，如果<code>Buffer Pool</code>中数据页已经刷磁盘后，那这些记录就失效了，新日志会将这些失效的记录进行覆盖擦除。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/nfnqJ3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图中的<code>write pos</code>表示redo log当前记录的日志序列号<code>LSN</code>(log sequence number)，写入还未刷盘，循环往后递增；<code>check point</code>表示redo log中的修改记录已刷入磁盘后的LSN，循环往后递增，这个LSN之前的数据已经全落盘。</p><p><code>write pos</code>到<code>check point</code>之间的部分是redo log空余的部分（绿色），用来记录新的日志；<code>check point</code>到<code>write pos</code>之间是redo log已经记录的数据页修改数据，此时数据页还未刷回磁盘的部分。当<code>write pos</code>追上<code>check point</code>时，会先推动<code>check point</code>向前移动，空出位置（刷盘）再记录新的日志。</p><blockquote><p><strong>注意</strong>：redo log日志满了，在擦除之前，需要确保这些要被擦除记录对应在内存中的数据页都已经刷到磁盘中了。擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求的，此刻MySQL的性能会下降。所以在并发量大的情况下，合理调整redo log的文件大小非常重要。</p></blockquote><p><strong>crash-safe</strong></p><p>因为redo log的存在使得<code>Innodb</code>引擎具有了<code>crash-safe</code>的能力，即MySQL宕机重启，系统会自动去检查redo log，将修改还未写入磁盘的数据从redo log恢复到MySQL中。</p><p>MySQL启动时，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。会先检查数据页中的<code>LSN</code>，如果这个 LSN 小于 redo log 中的LSN，即<code>write pos</code>位置，说明在<code>redo log</code>上记录着数据页上尚未完成的操作，接着就会从最近的一个<code>check point</code>出发，开始同步数据。</p><p>简单理解，比如：redo log的<code>LSN</code>是500，数据页的<code>LSN</code>是300，表明重启前有部分数据未完全刷入到磁盘中，那么系统则将redo log中<code>LSN</code>序号300到500的记录进行重放刷盘。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/UkEzaU.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>undo log（回滚日志）</strong></p><p><code>undo log</code>也是属于MySQL存储引擎InnoDB的事务日志。</p><p><code>undo log</code>属于逻辑日志，如其名主要起到回滚的作用，它是保证事务原子性的关键。记录的是数据修改前的状态，在数据修改的流程中，同时会记录一条与当前操作相反的逻辑日志到<code>undo log</code>中。</p><p>我们举个栗子：假如更新ID=1记录的name字段，name原始数据为小富，现改name为程序员内点事</p><p>事务执行<code>update X set name = 程序员内点事 where id =1</code>语句时，先会在<code>undo log</code>中记录一条相反逻辑的<code>update X set name = 小富 where id =1</code>记录，这样当某些原因导致服务异常事务失败，就可以借助<code>undo log</code>将数据回滚到事务执行前的状态，保证事务的完整性。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/h4sKvE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那可能有人会问：同一个事物内的一条记录被多次修改，那是不是每次都要把数据修改前的状态都写入<code>undo log</code>呢？</p><p>答案是不会的！</p><p><code>undo log</code>只负责记录事务开始前要修改数据的原始版本，当我们再次对这行数据进行修改，所产生的修改记录会写入到<code>redo log</code>，<code>undo log</code>负责完成回滚，<code>redo log</code>负责完成前滚。</p><p><strong>回滚</strong></p><p>未提交的事务，即事务未执行<code>commit</code>。但该事务内修改的脏页中，可能有一部分脏块已经刷盘。如果此时数据库实例宕机重启，就需要用回滚来将先前那部分已经刷盘的脏块从磁盘上撤销。</p><p><strong>前滚</strong></p><p>未完全提交的事务，即事务已经执行<code>commit</code>，但该事务内修改的脏页中只有一部分数据被刷盘，另外一部分还在<code>buffer pool</code>缓存上，如果此时数据库实例宕机重启，就需要用前滚来完成未完全提交的事务。将先前那部分由于宕机在内存上的未来得及刷盘数据，从<code>redo log</code>中恢复出来并刷入磁盘。</p><blockquote><p>数据库实例恢复时，先做前滚，后做回滚。</p></blockquote><p>如果你仔细看过了上边的 <code>MySQL数据更新流程图</code> 就会发现，<code>undo log</code>、<code>redo log</code>、<code>bin log</code>三种日志都是在刷脏页之前就已经刷到磁盘了的，相互协作最大限度保证了用户提交的数据不丢失。</p><p><strong>bin log（归档日志）</strong></p><p><code>bin log</code>是一种数据库Server层（和什么引擎无关），以二进制形式存储在磁盘中的逻辑日志。<code>bin log</code>记录了数据库所有<code>DDL</code>和<code>DML</code>操作（不包含 <code>SELECT</code> 和 <code>SHOW</code>等命令，因为这类操作对数据本身并没有修改）。</p><p>默认情况下，二进制日志功能是关闭的。可以通过以下命令查看二进制日志是否开启：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;log_bin&#39;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | OFF   |
+---------------+-------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bin log</code>也被叫做<code>归档日志</code>，因为它不会像<code>redo log</code>那样循环写擦除之前的记录，而是会一直记录日志。一个<code>bin log</code>日志文件默认最大容量<code>1G</code>（也可以通过<code>max_binlog_size</code>参数修改），单个日志超过最大值，则会新创建一个文件继续写。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show binary logs;
+-----------------+-----------+
| Log_name        | File_size |
+-----------------+-----------+
| mysq-bin.000001 |      8687 |
| mysq-bin.000002 |      1445 |
| mysq-bin.000003 |      3966 |
| mysq-bin.000004 |       177 |
| mysq-bin.000005 |      6405 |
| mysq-bin.000006 |       177 |
| mysq-bin.000007 |       154 |
| mysq-bin.000008 |       154 |
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bin log</code>日志的内容格式其实就是执行SQL命令的反向逻辑，这点和<code>undo log</code>有点类似。一般来说开启<code>bin log</code>都会给日志文件设置过期时间（<code>expire_logs_days</code>参数，默认永久保存），要不然日志的体量会非常庞大。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;expire_logs_days&#39;;
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| expire_logs_days | 0     |
+------------------+-------+
1 row in set

mysql&gt; SET GLOBAL expire_logs_days=30;
Query OK, 0 rows affected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bin log</code>主要应用于MySQL主从模式（<code>master-slave</code>）中，主从节点间的数据同步；以及基于时间点的数据还原。</p><p><strong>主从同步</strong></p><p>通过下图MySQL的主从复制过程，来了解下<code>bin log</code>在主从模式下的应用。</p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/pBBGas.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>用户在主库<code>master</code>执行<code>DDL</code>和<code>DML</code>操作，修改记录顺序写入<code>bin log</code>;</li><li>从库<code>slave</code>的I/O线程连接上Master，并请求读取指定位置<code>position</code>的日志内容;</li><li><code>Master</code>收到从库<code>slave</code>请求后，将指定位置<code>position</code>之后的日志内容，和主库bin log文件的名称以及在日志中的位置推送给从库;</li><li>slave的I/O线程接收到数据后，将接收到的日志内容依次写入到<code>relay log</code>文件最末端，并将读取到的主库bin log文件名和位置<code>position</code>记录到<code>master-info</code>文件中，以便在下一次读取用;</li><li>slave的SQL线程检测到<code>relay log</code>中内容更新后，读取日志并解析成可执行的SQL语句，这样就实现了主从库的数据一致;</li></ul><p><strong>基于时间点还原</strong></p><p>我们看到<code>bin log</code>也可以做数据的恢复，而<code>redo log</code>也可以，那它们有什么区别？</p><ul><li>层次不同：redo log 是InnoDB存储引擎实现的，bin log 是MySQL的服务器层实现的，但MySQL数据库中的任何存储引擎对于数据库的更改都会产生bin log。</li><li>作用不同：redo log 用于碰撞恢复（<code>crash recovery</code>），保证MySQL宕机也不会影响持久性；bin log 用于时间点恢复（<code>point-in-time recovery</code>），保证服务器可以基于时间点恢复数据和主从复制。</li><li>内容不同：redo log 是物理日志，内容基于磁盘的页<code>Page</code>；bin log的内容是二进制，可以根据<code>binlog_format</code>参数自行设置。</li><li>写入方式不同：redo log 采用循环写的方式记录；binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上。</li><li>刷盘时机不同：bin log在事务提交时写入；redo log 在事务开始时即开始写入。</li></ul><p>bin log 与 redo log 功能并不冲突而是起到相辅相成的作用，需要二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><p><strong>relay log（中继日志）</strong></p><p><code>relay log</code>日志文件具有与<code>bin log</code>日志文件相同的格式，从上边MySQL主从复制的流程可以看出，<code>relay log</code>起到一个中转的作用，<code>slave</code>先从主库<code>master</code>读取二进制日志数据，写入从库本地，后续再异步由<code>SQL线程</code>读取解析<code>relay log</code>为对应的SQL命令执行。</p><p><strong>slow query log</strong></p><p>慢查询日志（<code>slow query log</code>）: 用来记录在 MySQL 中执行时间超过指定时间的查询语句，在 SQL 优化过程中会经常使用到。通过慢查询日志，我们可以查找出哪些查询语句的执行效率低，耗时严重。</p><p>出于性能方面的考虑，一般只有在排查慢SQL、调试参数时才会开启，默认情况下，慢查询日志功能是关闭的。可以通过以下命令查看是否开启慢查询日志：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;slow_query%&#39;;
+---------------------+--------------------------------------------------------+
| Variable_name       | Value                                                  |
+---------------------+--------------------------------------------------------+
| slow_query_log      | OFF                                                    |
| slow_query_log_file | /usr/local/mysql/data/iZ2zebfzaequ90bdlz820sZ-slow.log |
+---------------------+--------------------------------------------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过如下命令开启慢查询日志后，我发现 <code>iZ2zebfzaequ90bdlz820sZ-slow.log</code> 日志文件里并没有内容啊，可能因为我执行的 SQL 都比较简单没有超过指定时间。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt;  SET GLOBAL slow_query_log=ON;
Query OK, 0 rows affected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上边提到超过 <code>指定时间</code> 的查询语句才算是慢查询，那么这个时间阈值又是多少嘞？我们通过 <code>long_query_time</code> 参数来查看一下，发现默认是 10 秒。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;long_query_time&#39;;
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们将 <code>long_query_time</code> 参数改小为 0.001秒再次执行查询SQL，看看慢查询日志里是否有变化。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SET GLOBAL long_query_time=0.001;
Query OK, 0 rows affected
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>果然再执行 SQL 的时，执行时间大于 0.001秒，发现慢查询日志开始记录了。</p><p><strong>general query log</strong></p><p>一般查询日志（<code>general query log</code>）：用来记录用户的<strong>所有</strong>操作，包括客户端何时连接了服务器、客户端发送的所有<code>SQL</code>以及其他事件，比如 <code>MySQL</code> 服务启动和关闭等等。<code>MySQL</code>服务器会按照它接收到语句的先后顺序写入日志文件。</p><p>由于一般查询日志记录的内容过于详细，开启后 Log 文件的体量会非常庞大，所以出于对性能的考虑，默认情况下，该日志功能是关闭的，通常会在排查故障需获得详细日志的时候才会临时开启。</p><p>我们可以通过以下命令查看一般查询日志是否开启，命令如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; show variables like &#39;general_log&#39;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| general_log   | OFF   |
+---------------+-------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下边开启一般查询日志并查看日志存放的位置。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SET GLOBAL general_log=on;
Query OK, 0 rows affected
mysql&gt; show variables like &#39;general_log_file&#39;;
+------------------+---------------------------------------------------+
| Variable_name    | Value                                             |
+------------------+---------------------------------------------------+
| general_log_file | /usr/local/mysql/data/iZ2zebfzaequ90bdlz820sZ.log |
+------------------+---------------------------------------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行一条查询 SQL 看看日志内容的变化。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; select * from t_config;
+---------------------+------------+---------------------+---------------------+
| id                  | remark     | create_time         | last_modify_time    |
+---------------------+------------+---------------------+---------------------+
| 1325741604307734530 | 我是广播表 | 2020-11-09 18:06:44 | 2020-11-09 18:06:44 |
+---------------------+------------+---------------------+---------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到日志内容详细的记录了所有执行的命令、SQL、SQL的解析过程、数据库设置等等</p><p><strong>error log</strong></p><p>错误日志（<code>error log</code>）: 应该是 MySQL 中最好理解的一种日志，主要记录 MySQL 服务器每次启动和停止的时间以及诊断和出错信息。</p><p>默认情况下，该日志功能是开启的，通过如下命令查找错误日志文件的存放路径。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; SHOW VARIABLES LIKE &#39;log_error&#39;;
+---------------+----------------------------------------------------------------+
| Variable_name | Value                                                          |
+---------------+----------------------------------------------------------------+
| log_error     | /usr/local/mysql/data/LAPTOP-UHQ6V8KP.err |
+---------------+----------------------------------------------------------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：错误日志中记录的可并非全是错误信息，像 MySQL 如何启动 <code>InnoDB</code> 的表空间文件、如何初始化自己的存储引擎，初始化 <code>buffer pool</code> 等等，这些也记录在错误日志文件中。</p><h3 id="_75-百亿级数据分表后怎么分页查呢" tabindex="-1"><a class="header-anchor" href="#_75-百亿级数据分表后怎么分页查呢" aria-hidden="true">#</a> 75.百亿级数据分表后怎么分页查呢？</h3><p><a href="https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/EplL3kBx5vOXGDhDOP8NjQ<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><figure><img src="https://cdn.jsdelivr.net/gh/fxzbiz/img@url/2023/11/11/Q9sKpN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_76-为什么一条sql执行会慢" tabindex="-1"><a class="header-anchor" href="#_76-为什么一条sql执行会慢" aria-hidden="true">#</a> 76.为什么一条sql执行会慢？</h3><p><strong>写操作</strong></p><ul><li>当 redo log 写满时就会进行刷脏页，此时写操作也会终止，那么 SQL 执行自然就会变慢。</li><li>遇到所要修改的数据行或表加了锁时，需要等待锁释放后才能进行后续操作，SQL 执行也会变慢。</li></ul><p><strong>读操作</strong></p><ul><li>读操作慢很常见的一个原因是未命中索引从而导致全表扫描，可以通过 explain 方式对 SQL 语句进行分析。</li><li>另一种原因是在读操作时，要读入的数据页不在内存中，需要通过淘汰脏页才能申请新的数据页从而导致执行变慢。</li></ul><h3 id="_77-mysql中的锁" tabindex="-1"><a class="header-anchor" href="#_77-mysql中的锁" aria-hidden="true">#</a> 77.mysql中的锁</h3><p><strong>行级锁和表级锁及页级锁</strong></p><blockquote><p><strong>在MySQL数据库体系中，可以按照锁的粒度把数据库锁分为行级锁(Innodb引擎)、表级锁(MyISam引擎)和页级锁(BDB引擎 )</strong>。</p></blockquote><p><strong>行级锁</strong></p><ul><li><strong>行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。</strong><ul><li><strong>行级锁能大大减少数据库操作的冲突</strong>。</li><li><strong>其加锁粒度最小，但加锁的开销也最大</strong>。</li></ul></li></ul><blockquote><p><strong>行级锁分为共享锁和排他锁。具体针对于这两种锁会在后续介绍</strong>。</p></blockquote><ul><li><strong>特点</strong><ul><li><strong>开销大，加锁慢</strong>；</li><li><strong>会出现死锁</strong>；</li><li><strong>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</strong></li></ul></li></ul><p><strong>表级锁</strong></p><blockquote><p><strong>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持</strong>。</p></blockquote><ul><li>最常使用的MYISAM与INNODB都支持表级锁定。</li></ul><blockquote><p><strong>表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</strong>。</p></blockquote><ul><li><strong>特点</strong><ul><li><strong>开销小，加锁快</strong>；</li><li><strong>不会出现死锁</strong>；</li><li><strong>锁定粒度大，发出锁冲突的概率最高，并发度最低</strong>。</li></ul></li></ul><p><strong>页级锁</strong></p><blockquote><p><strong>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。</strong></p></blockquote><blockquote><p><strong>表级锁速度快，但冲突多，行级冲突少，但速度慢。</strong></p></blockquote><blockquote><p><strong>所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</strong></p></blockquote><ul><li><strong>特点</strong><ul><li><strong>开销和加锁时间界于表锁和行锁之间；</strong></li><li><strong>会出现死锁；</strong></li><li><strong>锁定粒度界于表锁和行锁之间，并发度一般</strong></li></ul></li></ul><p><strong>MySQL常用存储引擎的锁机制</strong></p><ul><li><strong>MyISAM和MEMORY采用表级锁(table-level locking)</strong></li><li><strong>BDB采用页面锁(page-level locking)或表级锁，默认为页面锁</strong></li><li><strong>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</strong></li></ul><p><strong>Innodb中的行锁与表锁</strong></p><ul><li><strong>Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？</strong><ul><li><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</strong></li><li><strong>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></li></ul></li></ul><blockquote><p><strong>实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</strong></p></blockquote><ul><li>在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。 <ul><li><strong>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</strong>。</li><li><strong>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁</strong>。</li></ul></li></ul><blockquote><p><strong>即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁,而不是行锁</strong>。</p></blockquote><blockquote><p><strong>因此，在分析锁冲突时, 别忘了检查 SQL 的执行计划,以确认是否真正使用了索引。</strong></p></blockquote><p><strong>行级锁与死锁</strong></p><blockquote><p><strong>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待</strong>。</p></blockquote><ul><li><strong>在InnoDB中，锁是逐步获得的，就造成了死锁的可能。行级锁并不是直接锁记录，而是锁索引</strong>。 <ul><li><strong>索引分为主键索引和非主键索引两种：</strong><ul><li><strong>如果一条语句操作了主键索引，MySQL就会锁定这条主键索引</strong>；</li><li><strong>如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引</strong>。</li></ul></li></ul></li></ul><blockquote><p><strong>在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking</strong>。</p></blockquote><ul><li>当两个事务同时执行： <ul><li><strong>一个锁住了主键索引，在等待其他相关索引</strong>。</li><li><strong>另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁</strong>。</li></ul></li></ul><blockquote><p>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p></blockquote><ul><li>有多种方法可以避免死锁，这里只介绍常见的三种 <ol><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li><li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li></ol></li></ul><p><strong>共享锁与排他锁</strong></p><blockquote><p><strong>上面介绍过，行级锁是MySQL中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。</strong></p></blockquote><p>行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁及排他锁的概念、使用方式及注意事项等。</p><p><strong>共享锁(Share Lock)</strong></p><blockquote><p><strong>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁</strong>。</p></blockquote><blockquote><p><strong>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据</strong>。</p></blockquote><p>用法</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>在查询语句后面增加<strong>LOCK IN SHARE MODE</strong>，<strong>MySQL会对查询结果中的每行都加共享锁</strong>。</li><li><strong>当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞</strong>。<strong>其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据</strong>。</li></ul><p><strong>排他锁（exclusive Lock）</strong></p><ul><li><strong>排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据</strong>。</li></ul><blockquote><p><strong>对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）</strong></p></blockquote><p>用法</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p><strong>在查询语句后面增加FOR UPDATE，MySQL会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</strong></p></blockquote><p><strong>意向锁</strong></p><blockquote><p><strong>意向锁是一种不与行级锁冲突表级锁，这一点非常重要。意向锁分为两种： 1. 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁） 2. 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁） 即：意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InnoDB会先获取该数据行所在在数据表的对应意向锁</strong>。</p></blockquote><p>InnoDB支持多粒度锁，特定场景下，行级锁可以与表级锁共存。</p><ul><li><strong>意向锁之间互不排斥，但除了IS与S兼容外，意向锁会与共享锁 / 排他锁 互斥。</strong></li><li><strong>IX，IS是表级锁，不会和行级的X，S锁发生冲突</strong>。只会和表级的X，S发生冲突。</li><li><strong>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</strong></li></ul><hr><ul><li><strong>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</strong>。</li><li><strong>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁</strong>。</li></ul><blockquote><p><strong>对于一般的Select语句，InnoDB不会加任何锁(快照读)。</strong></p></blockquote><h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h3 id="_1-简单介绍一下-redis" tabindex="-1"><a class="header-anchor" href="#_1-简单介绍一下-redis" aria-hidden="true">#</a> 1.简单介绍一下 Redis?</h3><p><strong>Redis 就是一个使用 C 语言开发的数据库</strong>，与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p><p>另外，<strong>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</strong></p><p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p><h3 id="_2-redis-可以做消息队列么" tabindex="-1"><a class="header-anchor" href="#_2-redis-可以做消息队列么" aria-hidden="true">#</a> 2.Redis 可以做消息队列么？</h3><p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p><ul><li>发布 / 订阅模式</li><li>按照消费者组进行消费</li><li>消息持久化（ RDB 和 AOF）</li></ul><p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p><h3 id="_3-redis-单线程模型了解吗" tabindex="-1"><a class="header-anchor" href="#_3-redis-单线程模型了解吗" aria-hidden="true">#</a> 3.Redis 单线程模型了解吗？</h3><p>​ <strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> ，这套事件处理模型对应的是 Redis 中的文件事件处理器。由于文件事件处理器是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p>​ <strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>​ Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>​ 这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。</p><p>我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/msTPSD.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-redis6-0-之前为什么不使用多线程" tabindex="-1"><a class="header-anchor" href="#_4-redis6-0-之前为什么不使用多线程" aria-hidden="true">#</a> 4.Redis6.0 之前为什么不使用多线程？</h3><p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持</strong></p><p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p><p>大体上来说，<strong>Redis 6.0 之前主要还是单线程处理。</strong></p><p><strong>那，Redis6.0 之前为什么不使用多线程？</strong></p><p>我觉得主要原因有下面 3 个：</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><h3 id="_5-redis6-0-之后为何引入了多线程" tabindex="-1"><a class="header-anchor" href="#_5-redis6-0-之后为何引入了多线程" aria-hidden="true">#</a> 5.Redis6.0 之后为何引入了多线程？</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。</p><h3 id="_6-redis-是如何判断数据是否过期的呢" tabindex="-1"><a class="header-anchor" href="#_6-redis-是如何判断数据是否过期的呢" aria-hidden="true">#</a> 6.Redis 是如何判断数据是否过期的呢？</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><figure><img src="https://minio.pigx.top/oss/2022/07/3lUnPA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_7-过期的数据的删除策略了解么" tabindex="-1"><a class="header-anchor" href="#_7-过期的数据的删除策略了解么" aria-hidden="true">#</a> 7.过期的数据的删除策略了解么？</h3><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个：</p><ol><li><p><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</p></li><li><p><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p><p>具体就是Redis每秒10次做的事情：</p><ol><li>测试随机的20个keys进行相关过期检测。</li><li>删除所有已经过期的keys。</li><li>如果有多于25%的keys过期，重复步奏1.</li></ol></li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制</strong>。</p><h3 id="_8-redis-内存淘汰机制了解么" tabindex="-1"><a class="header-anchor" href="#_8-redis-内存淘汰机制了解么" aria-hidden="true">#</a> 8.Redis 内存淘汰机制了解么？</h3><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h3 id="_9-怎么保证-redis-挂掉之后再重启数据可以进行恢复" tabindex="-1"><a class="header-anchor" href="#_9-怎么保证-redis-挂掉之后再重启数据可以进行恢复" aria-hidden="true">#</a> 9.怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p><h3 id="_10-什么是-rdb-持久化" tabindex="-1"><a class="header-anchor" href="#_10-什么是-rdb-持久化" aria-hidden="true">#</a> 10.什么是 RDB 持久化？</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><h3 id="_11-什么是-aof-持久化" tabindex="-1"><a class="header-anchor" href="#_11-什么是-aof-持久化" aria-hidden="true">#</a> 11.什么是 AOF 持久化？</h3><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>appendonly yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><h3 id="_12-aof-重写了解吗" tabindex="-1"><a class="header-anchor" href="#_12-aof-重写了解吗" aria-hidden="true">#</a> 12.AOF 重写了解吗？</h3><p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><h3 id="_13-redis-4-0-对于持久化机制做了什么优化" tabindex="-1"><a class="header-anchor" href="#_13-redis-4-0-对于持久化机制做了什么优化" aria-hidden="true">#</a> 13.Redis 4.0 对于持久化机制做了什么优化？</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h3 id="_14-如何使用-redis-事务" tabindex="-1"><a class="header-anchor" href="#_14-如何使用-redis-事务" aria-hidden="true">#</a> 14.如何使用 Redis 事务？</h3><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><p>使用 <code>MULTI</code> 命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code>命令将执行所有命令。</p><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）。</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol><p>你也可以通过 <code>DISCARD</code> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p><p><code>WATCH</code> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p><h3 id="_15-redis-支持原子性吗" tabindex="-1"><a class="header-anchor" href="#_15-redis-支持原子性吗" aria-hidden="true">#</a> 15.Redis 支持原子性吗？</h3><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p><p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><h3 id="_16-如何解决-redis-事务的缺陷" tabindex="-1"><a class="header-anchor" href="#_16-如何解决-redis-事务的缺陷" aria-hidden="true">#</a> 16.如何解决 Redis 事务的缺陷？</h3><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器<strong>一次性执行完成，大幅减小了网络开销</strong>。</p><p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，<strong>保证了操作不会被其他指令插入或打扰。</strong></p><p>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的。因此，严格来说，通过 <strong>Lua 脚本来批量执行 Redis 命令也是不满足原子性的</strong>。</p><h3 id="_17-什么是-bigkey" tabindex="-1"><a class="header-anchor" href="#_17-什么是-bigkey" aria-hidden="true">#</a> 17.什么是 bigkey？</h3><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个。</p><h3 id="_18-bigkey-有什么危害" tabindex="-1"><a class="header-anchor" href="#_18-bigkey-有什么危害" aria-hidden="true">#</a> 18.bigkey 有什么危害？</h3><p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p><p>bigkey 的主要影响有：</p><p>网络阻塞；获取 bigkey 时，传输的数据量比较大，会增加带宽的压力。</p><p>超时阻塞；因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。</p><p>导致内存空间不平衡；一个 bigkey 存储数据量比较大，同一个 key 在同一个节点或服务器中存储，会造成一定影响。</p><h3 id="_19-大量-key-集中过期问题" tabindex="-1"><a class="header-anchor" href="#_19-大量-key-集中过期问题" aria-hidden="true">#</a> 19.大量 key 集中过期问题？</h3><p>对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p><p>如何解决呢？下面是两种常见的方法：</p><ol><li>给 key 设置随机过期时间。</li><li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><h3 id="_20-什么是缓存穿透" tabindex="-1"><a class="header-anchor" href="#_20-什么是缓存穿透" aria-hidden="true">#</a> 20.什么是缓存穿透？</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p><p><strong>有哪些解决办法？</strong></p><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。</p><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下</p><figure><img src="https://minio.pigx.top/oss/2022/07/tTYbJw.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong></p><h3 id="_21-什么是缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_21-什么是缓存雪崩" aria-hidden="true">#</a> 21.什么是缓存雪崩？</h3><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p><p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p><p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><p><strong>有哪些解决办法？</strong></p><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h3 id="_22-3种常用的缓存读写策略" tabindex="-1"><a class="header-anchor" href="#_22-3种常用的缓存读写策略" aria-hidden="true">#</a> 22.3种常用的缓存读写策略？</h3><ul><li><p>Cache Aside Pattern（旁路缓存模式）</p><p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p></li></ul><p>​ Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</p><p>​ <strong>写</strong> ：</p><p>​ 1.先更新 DB</p><p>​ 2.然后直接删除 cache 。</p><p>​ <strong>读</strong> :</p><p>​ 1.从 cache 中读取数据，读取到就直接返回</p><p>​ 2.cache中读取不到的话，就从 DB 中读取数据返回</p><p>​ 3.再把数据放到 cache 中。</p><p>​ <strong>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</strong></p><p>​ <strong>答案：</strong> 不行！因为这样可能会造成<strong>数据库（DB）和缓存（Cache）数据不一致</strong>的问题。</p><blockquote><p>请求1先把cache中的A数据删除 -&gt; 请求2从DB中读取数据-&gt;请求1再把DB中的A数据更新。</p></blockquote><p>​ <strong>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</strong></p><p>​ <strong>答案：</strong> 可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</p><p>​ <strong>Cache Aside Pattern 的缺陷</strong>。</p><p>​ <strong>缺陷1：首次请求数据一定不在 cache 的问题</strong></p><p>​ 解决办法：可以将热点数据可以提前放入cache 中。</p><p>​ <strong>缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>​ 解决办法：</p><p>​ 1.数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</p><p>​ 2.可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</p><ul><li><strong>Read/Write Through Pattern（读写穿透）</strong></li></ul><p>​ Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入DB中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</p><p>​ <strong>写（Write Through）：</strong></p><p>​ 1.先查 cache，cache 中不存在，直接更新 DB。</p><p>​ 2.cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</p><p>​ <strong>读(Read Through)：</strong></p><p>​ 1.从 cache 中读取数据，读取到就直接返回 。</p><p>​ 2.读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</p><ul><li>Write Behind Pattern（异步缓存写入）</li></ul><p>​ Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p><p>​ 但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p><h3 id="_24-什么是内存碎片" tabindex="-1"><a class="header-anchor" href="#_24-什么是内存碎片" aria-hidden="true">#</a> 24.什么是内存碎片?</h3><p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p><p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p><h3 id="_25-为什么会有-redis-内存碎片" tabindex="-1"><a class="header-anchor" href="#_25-为什么会有-redis-内存碎片" aria-hidden="true">#</a> 25.为什么会有 Redis 内存碎片?</h3><p>Redis 内存碎片产生比较常见的 2 个原因：</p><p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p><p>**2、频繁修改 Redis 中的数据也会产生内存碎片。**当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p><h3 id="_26-redis的有几种数据类型" tabindex="-1"><a class="header-anchor" href="#_26-redis的有几种数据类型" aria-hidden="true">#</a> 26.Redis的有几种数据类型？</h3><p>基础：字符串（String）、哈希（hash)、列表（list)、集合(set)、有序集合(zset)。</p><p>还有HyperLogLog、流、地理坐标等</p><h3 id="_27-redis为什么快-单线程" tabindex="-1"><a class="header-anchor" href="#_27-redis为什么快-单线程" aria-hidden="true">#</a> 27.redis为什么快？单线程？</h3><p>redis使用了单线程架构和I/O多路复用模型模型。</p><p>纯内存访问。</p><p>由于是单线程避免了线程上下文切换带来的资源消耗。</p><h3 id="_28-redis默认分多少个数据库" tabindex="-1"><a class="header-anchor" href="#_28-redis默认分多少个数据库" aria-hidden="true">#</a> 28.redis默认分多少个数据库？</h3><p>16</p><h3 id="_29-redis持久化的几种方式" tabindex="-1"><a class="header-anchor" href="#_29-redis持久化的几种方式" aria-hidden="true">#</a> 29.redis持久化的几种方式？</h3><p>RDB、AOF、混合持久化。</p><h3 id="_30-rdb的优点" tabindex="-1"><a class="header-anchor" href="#_30-rdb的优点" aria-hidden="true">#</a> 30.RDB的优点？</h3><p>rdb是一个紧凑的二进制文件，代表Redis在某个时间点上的数据快照。 适合于备份，全量复制的场景，对于灾难恢复非常有用。</p><p>Redis加载RDB恢复数据的速度远快于AOF方式。</p><h3 id="_31-rdb的缺点" tabindex="-1"><a class="header-anchor" href="#_31-rdb的缺点" aria-hidden="true">#</a> 31.RDB的缺点？</h3><p>RDB没法做到实时的持久化。中途意外终止，会丢失一段时间内的数据。</p><p>RDB需要fork()创建子进程，属于重量级操作，可能导致Redis卡顿若干秒。</p><h3 id="_32-aof持久化" tabindex="-1"><a class="header-anchor" href="#_32-aof持久化" aria-hidden="true">#</a> 32.AOF持久化？</h3><p>AOF(append only file)为了解决rdb不能实时持久化的问题，aof来搞定。以独立的日志方式记录把每次命令记录到aof文件中。</p><h3 id="_33-aof工作流程" tabindex="-1"><a class="header-anchor" href="#_33-aof工作流程" aria-hidden="true">#</a> 33.AOF工作流程？</h3><p>1.所有写入命令追加到aof_buf缓冲区。</p><p>2.AOF缓冲区根据对应的策略向硬盘做同步操作。</p><p>3.随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</p><p>4.当redis服务器重启时，可以加载AOF文件进行数据恢复。</p><h3 id="_34-为什么aof要先把命令追加到缓存区-aof-buf-中" tabindex="-1"><a class="header-anchor" href="#_34-为什么aof要先把命令追加到缓存区-aof-buf-中" aria-hidden="true">#</a> 34.为什么AOF要先把命令追加到缓存区(aof_buf)中？</h3><p>Redis使用单线程响应命令，如果每次写入文件命令都直接追加到硬盘，性能就会取决于硬盘的负载。如 果使用缓冲区，redis提供多种缓冲区策略，在性能和安全性方面做出平衡。</p><h3 id="_35-aof优点" tabindex="-1"><a class="header-anchor" href="#_35-aof优点" aria-hidden="true">#</a> 35.AOF优点？</h3><p>AOF提供了3种保存策略：每秒保存、跟系统策略、每次操作保存。</p><p>实时性比较高，一般来说会选 择每秒保存，因此意外发生时顶多失去一秒的数据。 文件追加写形式，所以文件很少有损坏问题，如最后意外发生少写数据，可通过redis-check-aof工 具修复。 AOF由于是文本形式，直接采用协议格式，避免二次处理开销，另外对于修改也比较灵活。</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p><h3 id="_36-aof缺点" tabindex="-1"><a class="header-anchor" href="#_36-aof缺点" aria-hidden="true">#</a> 36.AOF缺点？</h3><p>AOF文件要比RDB文件大。 AOF冷备没RDB迅速。 由于执行频率比较高，所以负载高时，性能没有RDB好。</p><h3 id="_37-混合持久化-优缺点" tabindex="-1"><a class="header-anchor" href="#_37-混合持久化-优缺点" aria-hidden="true">#</a> 37.混合持久化？优缺点？</h3><p>一般来说我们的线上都会采取混合持久化。redis4.0以后添加了新的混合持久化方式。</p><p><strong>优点：</strong></p><p>在快速加载的同时，避免了丢失过更多的数据。</p><p><strong>缺点：</strong></p><p>由于混合了两种格式，所以可读性差。 兼容性，需要4.0以后才支持。</p><h3 id="_38-redis-cluster槽范围" tabindex="-1"><a class="header-anchor" href="#_38-redis-cluster槽范围" aria-hidden="true">#</a> 38.Redis Cluster槽范围？</h3><p>0~16383</p><h3 id="_39-什么是缓存预热" tabindex="-1"><a class="header-anchor" href="#_39-什么是缓存预热" aria-hidden="true">#</a> 39.什么是缓存预热？</h3><p>就是系统上线后，提前将相关数据加载到缓存系统，避免用户先查库，然后在缓存。</p><h3 id="_40-redis-的同步机制了解是什么" tabindex="-1"><a class="header-anchor" href="#_40-redis-的同步机制了解是什么" aria-hidden="true">#</a> 40.Redis 的同步机制了解是什么？</h3><p>Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓冲区， RDB 文件全部同步到复制节点，复制节点接受完成后将 RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p><h3 id="_41-怎么使用redis实现消息队列" tabindex="-1"><a class="header-anchor" href="#_41-怎么使用redis实现消息队列" aria-hidden="true">#</a> 41.怎么使用Redis实现消息队列？</h3><p>一般使用 list 结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep 一会再重试。</p><p>面试官可能会问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会 阻塞住直到消息到来。</p><p>面试官可能还问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</p><p>面试官可能还问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用 专业的消息队列如 rabbitmq 等。</p><p>面试官可能还问 Redis 如何实现延时队列？使用sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</p><h3 id="_42-是否使用过redis-cluster集群-集群的原理是什么" tabindex="-1"><a class="header-anchor" href="#_42-是否使用过redis-cluster集群-集群的原理是什么" aria-hidden="true">#</a> 42.是否使用过Redis Cluster集群，集群的原理是什么？</h3><p>使用过 Redis 集群，它的原理是：</p><ol><li><p>所有的节点相互连接</p></li><li><p>集群消息通信通过集群总线通信，集群总线端口大小为客户端服务端口 + 10000（固定值）</p></li><li><p>节点与节点之间通过二进制协议进行通信</p></li><li><p>客户端和集群节点之间通信和通常一样，通过文本协议进行 集群节点不会代理查询</p></li><li><p>数据按照 Slot 存储分布在多个 Redis 实例上</p></li><li><p>集群节点挂掉会自动故障转移</p></li><li><p>可以相对平滑扩/缩容节点</p></li></ol><p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号 在 0~16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p><h3 id="_43-redis-集群架构模式有哪几种" tabindex="-1"><a class="header-anchor" href="#_43-redis-集群架构模式有哪几种" aria-hidden="true">#</a> 43.Redis 集群架构模式有哪几种？</h3><p>Redis 集群架构是支持单节点单机模式的，也支持一主多从的主从结构，还支持带有哨兵的集群部署模式。</p><h3 id="_44-说说-redis-哈希槽的概念" tabindex="-1"><a class="header-anchor" href="#_44-说说-redis-哈希槽的概念" aria-hidden="true">#</a> 44.说说 Redis 哈希槽的概念？</h3><p>Redis 集群并没有使用一致性 hash，而是引入了哈希槽的概念。Redis 集群有 16384（2^14）个哈 希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><h3 id="_45-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某-个固定的已知的前缀开头的-如果将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#_45-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某-个固定的已知的前缀开头的-如果将它们全部找出来" aria-hidden="true">#</a> 45.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p><ol><li>使用 keys 命令</li></ol><p>直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询 的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。而且 Redis 是单线程，keys 指令会导 致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复。这在生产 环境是不允许的。除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条 件的 key 值，会发现查询结果非常大，输出的信息非常多。所以不推荐使用这个命令。</p><ol start="2"><li>使用 scan 命令</li></ol><p>scan 指令可以无阻塞的提取出指定模式的 key 列表， 但 是会有一定的重复概率， 在客户端做一次去重就可以了， 但是整体所花费的时间 会比直接用 keys 指令长。</p><h3 id="_46-redis-主从复制的核心原理" tabindex="-1"><a class="header-anchor" href="#_46-redis-主从复制的核心原理" aria-hidden="true">#</a> 46.Redis 主从复制的核⼼原理</h3><p>通过执⾏slaveof命令或设置slaveof选项，让⼀个服务器去复制另⼀个服务器的数据。主数据库可以进⾏读写操作，当写操作导致数据变化时会⾃动将数据同步给从数据库。⽽从数据库⼀般是只读的，并接 受主数据库同步过来的数据。⼀个主数据库可以拥有多个从数据库，⽽⼀个从数据库只能拥有⼀个主数 据库。</p><p>全量复制：</p><ol><li><p>主节点通过bgsave命令fork⼦进程进⾏RDB持久化，该过程是⾮常消耗CPU、内存(⻚表复制)、硬盘IO的</p></li><li><p>主节点通过⽹络将RDB⽂件发送给从节点，对主从节点的带宽都会带来很⼤的消耗</p></li></ol><p>3.从节点清空⽼数据、载⼊新RDB⽂件的过程是阻塞的，⽆法响应客户端的命令；如果从节点执⾏ bgrewriteaof，也会带来额外的消耗</p><p>部分复制：</p><ol><li><p>复制偏移量：执⾏复制的双⽅，主从节点，分别会维护⼀个复制偏移量offset</p></li><li><p>复制积压缓冲区：主节点内部维护了⼀个固定⻓度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点offset的差距过⼤超过缓冲区⻓度时，将⽆法执⾏部分复制，只能执⾏全量复制。</p></li><li><p>服务器运⾏ID(runid)：每个Redis节点，都有其运⾏ID，运⾏ID由节点在启动时⾃动⽣成，主节点会 将⾃⼰的运⾏ID发送给从节点，从节点会将主节点的运⾏ID存起来。 从节点Redis断开重连的时 候，就是根据运⾏ID来判断同步的进度：</p></li></ol><p>○ 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使⽤部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p><p>○ 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进⾏全量复制。</p><h1 id="spring-spring-boot" tabindex="-1"><a class="header-anchor" href="#spring-spring-boot" aria-hidden="true">#</a> Spring&amp;Spring Boot</h1><h3 id="_1-什么是-spring-框架" tabindex="-1"><a class="header-anchor" href="#_1-什么是-spring-框架" aria-hidden="true">#</a> 1.什么是 Spring 框架?</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p><p>比如说 Spring 自带 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p><h3 id="_2-列举一些重要的-spring-模块" tabindex="-1"><a class="header-anchor" href="#_2-列举一些重要的-spring-模块" aria-hidden="true">#</a> 2.列举一些重要的 Spring 模块？</h3><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><figure><img src="https://minio.pigx.top/oss/2022/07/pttOTt.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>Spring Core</strong></p><p>核心模块， Spring 其他所有的功能基本都需要依赖于该模块，主要提供 IoC 依赖注入功能的支持。</p><p><strong>Spring Aspects</strong></p><p>该模块为与 AspectJ 的集成提供支持。</p><p><strong>Spring AOP</strong></p><p>提供了面向切面的编程实现。</p><p><strong>Spring Data Access/Integration ：</strong></p><p>Spring Data Access/Integration 由 5 个模块组成：</p><ul><li>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li>spring-tx : 提供对事务的支持。</li><li>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</li><li>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</li><li>spring-jms : Java 消息服务。</li></ul><p><strong>Spring Web</strong></p><p>Spring Web 由 4 个模块组成：</p><ul><li>spring-web ：对 Web 功能的实现提供一些最基础的支持。</li><li>spring-webmvc ： 提供对 Spring MVC 的实现。</li><li>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</li></ul><p><strong>Spring Test</strong></p><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><p><strong>Spring Context</strong></p><p>Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、事件机制、校验和调度功能。</p><h3 id="_3-spring-spring-mvc-spring-boot-之间什么关系" tabindex="-1"><a class="header-anchor" href="#_3-spring-spring-mvc-spring-boot-之间什么关系" aria-hidden="true">#</a> 3.Spring,Spring MVC,Spring Boot 之间什么关系?</h3><p>Spring 包含了多个功能模块，其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p><p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p><h3 id="_4-谈谈自己对于-spring-ioc-的了解" tabindex="-1"><a class="header-anchor" href="#_4-谈谈自己对于-spring-ioc-的了解" aria-hidden="true">#</a> 4.谈谈自己对于 Spring IoC 的了解？</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/uszX9A.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><h3 id="_5-谈谈自己对于-aop-的了解" tabindex="-1"><a class="header-anchor" href="#_5-谈谈自己对于-aop-的了解" aria-hidden="true">#</a> 5.谈谈自己对于 AOP 的了解？</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><figure><img src="https://minio.pigx.top/oss/2022/07/ADrSiJ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-spring-aop-和-aspectj-aop-有什么区别" tabindex="-1"><a class="header-anchor" href="#_6-spring-aop-和-aspectj-aop-有什么区别" aria-hidden="true">#</a> 6.Spring AOP 和 AspectJ AOP 有什么区别？</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p><p>Spring AOP 仅支持方法级别的 PointCut；AspectJ提供了完全的 AOP 支持， 它还支持属性级 别的 PointCut。</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h3 id="_7-什么是-spring-bean" tabindex="-1"><a class="header-anchor" href="#_7-什么是-spring-bean" aria-hidden="true">#</a> 7.什么是 Spring Bean？</h3><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><h3 id="_8-将一个类声明为-bean-的注解有哪些" tabindex="-1"><a class="header-anchor" href="#_8-将一个类声明为-bean-的注解有哪些" aria-hidden="true">#</a> 8.将一个类声明为 Bean 的注解有哪些?</h3><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="_9-component-和-bean-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_9-component-和-bean-的区别是什么" aria-hidden="true">#</a> 9.@Component 和 @Bean 的区别是什么？</h3><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><h3 id="_10-注入-bean-的注解有哪些" tabindex="-1"><a class="header-anchor" href="#_10-注入-bean-的注解有哪些" aria-hidden="true">#</a> 10.注入 Bean 的注解有哪些？</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotaion</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。 建议通过 <code>@Qualifier</code> 注解来显示指定名称而不是依赖变量的名称。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）</p><p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p><h3 id="_11-bean-的作用域有哪些" tabindex="-1"><a class="header-anchor" href="#_11-bean-的作用域有哪些" aria-hidden="true">#</a> 11.Bean 的作用域有哪些?</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>注解方式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_12-单例-bean-的线程安全问题了解吗" tabindex="-1"><a class="header-anchor" href="#_12-单例-bean-的线程安全问题了解吗" aria-hidden="true">#</a> 12.单例 Bean 的线程安全问题了解吗？</h3><p>单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><h3 id="_13-bean-的生命周期了解么" tabindex="-1"><a class="header-anchor" href="#_13-bean-的生命周期了解么" aria-hidden="true">#</a> 13.Bean 的生命周期了解么?</h3><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法。</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/owLC7E.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/6pcQWC.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_14-说说自己对于-spring-mvc-了解" tabindex="-1"><a class="header-anchor" href="#_14-说说自己对于-spring-mvc-了解" aria-hidden="true">#</a> 14.说说自己对于 Spring MVC 了解?</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><h3 id="_15-springmvc-工作原理了解吗" tabindex="-1"><a class="header-anchor" href="#_15-springmvc-工作原理了解吗" aria-hidden="true">#</a> 15.SpringMVC 工作原理了解吗?</h3><figure><img src="https://minio.pigx.top/oss/2022/07/1CMggh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）。</li></ol><h3 id="_16-spring-框架中用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_16-spring-框架中用到了哪些设计模式" aria-hidden="true">#</a> 16.Spring 框架中用到了哪些设计模式？</h3><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="_17-spring-管理事务的方式有几种" tabindex="-1"><a class="header-anchor" href="#_17-spring-管理事务的方式有几种" aria-hidden="true">#</a> 17.Spring 管理事务的方式有几种？</h3><ul><li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li></ul><h3 id="_18-spring-事务中哪几种事务传播行为" tabindex="-1"><a class="header-anchor" href="#_18-spring-事务中哪几种事务传播行为" aria-hidden="true">#</a> 18.Spring 事务中哪几种事务传播行为?</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>正确的事务传播行为可能的值如下:</p><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p>这个使用的很少。</p><p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p><ul><li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><h3 id="_19-spring-事务中的隔离级别有哪几种" tabindex="-1"><a class="header-anchor" href="#_19-spring-事务中的隔离级别有哪几种" aria-hidden="true">#</a> 19.Spring 事务中的隔离级别有哪几种?</h3><ul><li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</li><li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="_20-transactional-rollbackfor-exception-class-注解了解吗" tabindex="-1"><a class="header-anchor" href="#_20-transactional-rollbackfor-exception-class-注解了解吗" aria-hidden="true">#</a> 20.@Transactional(rollbackFor = Exception.class)注解了解吗？</h3><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。</p><p>当 <code>@Transactional</code> 注解作用于<strong>类</strong>上时，该类的所有 <strong>public</strong> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p><h3 id="_21-springboot的优缺点" tabindex="-1"><a class="header-anchor" href="#_21-springboot的优缺点" aria-hidden="true">#</a> 21.springboot的优缺点？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/0Nb31l.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_22-简单介绍一下-springbootapplication注解" tabindex="-1"><a class="header-anchor" href="#_22-简单介绍一下-springbootapplication注解" aria-hidden="true">#</a> 22.简单介绍一下@SpringbootApplication注解？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/0JfOiP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_23-springboot自动装配原理" tabindex="-1"><a class="header-anchor" href="#_23-springboot自动装配原理" aria-hidden="true">#</a> 23.springboot自动装配原理？</h3><h3 id="_24-transactional-的使用注意事项总结" tabindex="-1"><a class="header-anchor" href="#_24-transactional-的使用注意事项总结" aria-hidden="true">#</a> 24.<code>@Transactional</code> 的使用注意事项总结？</h3><ul><li><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；因为底层cglib是基于⽗⼦类来实现 的，⼦类是不能重载⽗类的private⽅法的，所以⽆法很好的利⽤代理，也会导致@Transactianal失效</li><li>避免同一个类中调用 <code>@Transactional</code> 注解的方法，这样会导致事务失效；只有是被代理对象调⽤时， 那么这个注解才会⽣效，所以如果是被代理对象来调⽤这个⽅法，那么@Transactional是不会失效的。</li><li>正确的设置 <code>@Transactional</code> 的 <code>rollbackFor</code> 和 <code>propagation</code> 属性，否则事务可能会回滚失败;</li><li>被 <code>@Transactional</code> 注解的方法所在的类必须被 Spring 管理，否则不生效；</li><li>底层使用的数据库必须支持事务机制，否则不生效；</li></ul><h3 id="_25-spring-框架中用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_25-spring-框架中用到了哪些设计模式" aria-hidden="true">#</a> 25.Spring 框架中用到了哪些设计模式？</h3><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="_26-ioc注入哪几种方式" tabindex="-1"><a class="header-anchor" href="#_26-ioc注入哪几种方式" aria-hidden="true">#</a> 26.IOC注入哪几种方式？</h3><ul><li><p>基于 field 注入（属性注入）</p></li><li><p>基于 setter 注入</p></li><li><p>基于 constructor 注入（构造器注入）</p><ol><li>基于 field 注入 所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式。比如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">Svc</span> svc<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>基于 setter 方法注入 通过对应变量的setXXX()方法以及在方法上面使用注解，来完成依赖注入。比如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Helper</span> helper<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHelper</span><span class="token punctuation">(</span><span class="token class-name">Helper</span> helper<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
		<span class="token keyword">this</span><span class="token punctuation">.</span>helper <span class="token operator">=</span> helper<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：在 Spring 4.3 及以后的版本中，setter 上面的 @Autowired 注解是可以不写的。</p><ol start="3"><li>基于 constructor 注入 将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Svc</span> svc<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">public</span> <span class="token class-name">HelpService</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">&quot;svcB&quot;</span><span class="token punctuation">)</span> <span class="token class-name">Svc</span> svc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>svc <span class="token operator">=</span> svc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Spring 4.3 及以后的版本中，如果这个类只有一个构造方法，那么这个构造方法上面也可以不写 @Autowired 注解。</p><ul><li>强制依赖就用构造器方式</li><li>可选、可变的依赖就用setter 注入当然你可以在同一个类中使用这两种方法。构造器注入更适合强制性的注入旨在不变性，Setter注入更适合可变性的注入。</li></ul><p>基于 field 注入虽然简单，但是却会引发很多的问题。</p><ul><li><p>容易违背了单一职责原则</p></li><li><p>你的类和依赖容器强耦合，不能在容器外使用</p></li><li><p>不能使用属性注入的方式构建不可变对象(final 修饰的变量)</p></li></ul></li></ul><h3 id="_27-什么是aop-面向切面编程" tabindex="-1"><a class="header-anchor" href="#_27-什么是aop-面向切面编程" aria-hidden="true">#</a> 27.什么是AOP(面向切面编程)？</h3><p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p><h3 id="_28-切面有几种类型的通知-分别是" tabindex="-1"><a class="header-anchor" href="#_28-切面有几种类型的通知-分别是" aria-hidden="true">#</a> 28.切面有几种类型的通知？分别是？</h3><p>前置通知(Before): 目标方法被调用之前调用通知功能。</p><p>后置通知(After): 目标方法完成之后调用通。</p><p>返回通知(After-returning): 目标方法成功执行之后调用通知。</p><p>异常通知(After-throwing): 目标方法抛出异常后调用通知。</p><p>环绕通知(Around): 在被通知的方法调用之前和调用之后执行自定义的行为。</p><h3 id="_29-什么是连接点-join-point" tabindex="-1"><a class="header-anchor" href="#_29-什么是连接点-join-point" aria-hidden="true">#</a> 29.什么是连接点 （Join point)?</h3><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改 一个字段时。</p><h3 id="_30-什么是切点-pointcut" tabindex="-1"><a class="header-anchor" href="#_30-什么是切点-pointcut" aria-hidden="true">#</a> 30.什么是切点（Pointcut)?</h3><p>切点的定义会匹配通知所要织入的一个或多个连接点。</p><p>我们通常使用明确的类和方法名称，或是利用正 则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根 据运行时的决策(比如方法的参数值)来决定是否应用通知。</p><h3 id="_31-什么是切面-aspect" tabindex="-1"><a class="header-anchor" href="#_31-什么是切面-aspect" aria-hidden="true">#</a> 31.什么是切面(Aspect)?</h3><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。</p><h3 id="_32-织入-weaving" tabindex="-1"><a class="header-anchor" href="#_32-织入-weaving" aria-hidden="true">#</a> 32.织入(Weaving)?</h3><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。</p><h3 id="_33-在目标对象的生命周期里有多个点可以进行织入" tabindex="-1"><a class="header-anchor" href="#_33-在目标对象的生命周期里有多个点可以进行织入" aria-hidden="true">#</a> 33.在目标对象的生命周期里有多个点可以进行织入？</h3><p>编译期：切面在目标类编译时被织入。AspectJ的织入编译器就是以这种方式织入切面的。</p><p>类加载期：切面在目标类加载到JVM时被织入。它可以在目标类被引入应用之前增强该目标类的字 节码。AspectJ 5的加载时织入(load-time weaving，LTW)就支持以这种方式织入切面。</p><p>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象 动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</p><h3 id="_34-aop动态代理策略" tabindex="-1"><a class="header-anchor" href="#_34-aop动态代理策略" aria-hidden="true">#</a> 34.AOP动态代理策略？</h3><p>如果目标对象实现了接口，默认采用JDK 动态代理。可以强制转为CgLib实现AOP。 如果没有实现接口，采用CgLib进行动态代理。</p><h3 id="_35-springmvc的几个组件" tabindex="-1"><a class="header-anchor" href="#_35-springmvc的几个组件" aria-hidden="true">#</a> 35.SpringMVC的几个组件？</h3><p>DispatcherServlet : 前端控制器，也叫中央控制器。相关组件都是它来调度。</p><p>HandlerMapping : 处理器映射器，根据URL路径映射到不同的Handler。</p><p>HandlerAdapter : 处理器适配器，按照HandlerAdapter的规则去执行Handler。</p><p>Handler : 处理器,由我们自己根据业务开发。</p><p>ViewResolver : 视图解析器，把逻辑视图解析成具体的视图。</p><p>View : 一个接口，它的实现支持不同的视图类型（freeMaker，JSP等）</p><h3 id="_36-beanfactory-和-applicationcontext区别" tabindex="-1"><a class="header-anchor" href="#_36-beanfactory-和-applicationcontext区别" aria-hidden="true">#</a> 36.BeanFactory 和 ApplicationContext区别？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/KAwl8Y.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_37-qualifier注解" tabindex="-1"><a class="header-anchor" href="#_37-qualifier注解" aria-hidden="true">#</a> 37.@Qualifier注解？</h3><p>当创建多个相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下， 你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。</p><h3 id="_38-application-properties和application-yml文件可放位置-优先级" tabindex="-1"><a class="header-anchor" href="#_38-application-properties和application-yml文件可放位置-优先级" aria-hidden="true">#</a> 38.application.properties和application.yml文件可放位置?优先级?</h3><p><strong>如果是2.4.0之前版本，优先级properties&gt;yaml , 但是如果是2.4.0的版本，优先级yaml&gt;properties</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/hCNQ9K.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p>先去项目根目录找config文件夹下找配置文件件</p></li><li><p>再去根目录下找配置文件</p></li><li><p>去resources下找cofnig文件夹下找配置文件</p></li><li><p>去resources下找配置文件</p></li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/ex4esS.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>SpringBoot会加载全部主配置文件；互补配置；</p><p>备注： 这里说的配置文件，都还是项目里面。最终都会被打进jar包里面的，需要注意。</p><p>1、如果同一个目录下，有application.yml也有application.properties，默认先读取 application.properties。</p><p>2、如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的<strong>不覆盖</strong>前面读取 到的。</p><p>3、创建SpringBoot项目时，一般的配置文件放置在“项目的resources目录下”</p><p>如果我们的配置文件名字不叫application.properties或者application.yml，可以通过以下参数来指定 配置文件的名字，myproject是配置文件名</p><p>$ java -jar myproject.jar --spring.config.name=myproject</p><p>我们同时也可以指定其他位置的配置文件来生效 指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。</p><p>java -jar run-0.0.1-SNAPSHOT.jar -spring.config.location=D:/application.propertie</p><h3 id="_39-bootstrap-yml-和application-yml" tabindex="-1"><a class="header-anchor" href="#_39-bootstrap-yml-和application-yml" aria-hidden="true">#</a> 39.bootstrap.yml 和application.yml?</h3><p>bootstrap.yml 优先于application.yml</p><h3 id="_40-在spring-aop-中-关注点和横切关注的区别是什么" tabindex="-1"><a class="header-anchor" href="#_40-在spring-aop-中-关注点和横切关注的区别是什么" aria-hidden="true">#</a> 40.在Spring AOP 中，关注点和横切关注的区别是什么？</h3><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><p>那什么是连接点呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切 面，它实际上是个应用程序执行Spring AOP的位置。</p><p>切入点是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p><h3 id="_41-spring-是怎么解决循环依赖的" tabindex="-1"><a class="header-anchor" href="#_41-spring-是怎么解决循环依赖的" aria-hidden="true">#</a> 41.Spring 是怎么解决循环依赖的？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/oQxOrv.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>整个流程大致如下：</p><ol><li><p>首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来；</p></li><li><p>然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来；</p></li><li><p>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)。这 个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），通过 ObjectFactory 提前曝光，所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象。C 拿 到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</p></li><li><p>回到 B，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路 就已经完成了初始化过程了。</p></li></ol><figure><img src="https://minio.pigx.top/oss/2022/08/yx5zJ0.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一级缓存：正式对象。</p><p>二级缓存：半成品对象。</p><p>三级缓存：工厂。</p><p>三级缓存主要处理的是AOP的代理对象，存储的是一个ObjectFactory。</p><p>三级缓存考虑的是代理对象，而二级缓存考虑的是性能-从三级缓存的工厂里创建出对象，再扔到二级缓存（这样就不用每次都要从工厂里拿）。</p><h3 id="_42-事务三要素是什么" tabindex="-1"><a class="header-anchor" href="#_42-事务三要素是什么" aria-hidden="true">#</a> 42.事务三要素是什么？</h3><p><strong>数据源</strong>：表示具体的事务性资源，是事务的真正处理者，如MySQL等。</p><p><strong>事务管理器</strong>：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p><p><strong>事务应用和属性配置</strong>：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属 性如隔离级别、超时时间等。</p><h3 id="_43-事务注解的本质是什么" tabindex="-1"><a class="header-anchor" href="#_43-事务注解的本质是什么" aria-hidden="true">#</a> 43.事务注解的本质是什么？</h3><p>@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置bean的事务行为。 大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为</p><p>声明式事务主要是得益于Spring AOP。<strong>使用一个事务拦截器，在方法调用的前后/周围进行事务性 增强（advice）</strong>，来驱动事务完成。</p><p>@Transactional注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所 有方法。如果此时方法上也标注了，则方法上的优先级高。 另外注意方法一定要是public的。</p><h3 id="_44-如何在spring-boot启动的时候运行一些特定的代码" tabindex="-1"><a class="header-anchor" href="#_44-如何在spring-boot启动的时候运行一些特定的代码" aria-hidden="true">#</a> 44.如何在Spring Boot启动的时候运行一些特定的代码？</h3><p>如果你想在Spring Boot启动的时候运行一些特定的代码，你可以实现接口ApplicationRunner或 者CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个run方法。</p><p>CommandLineRunner：启动获取命令行参数</p><h3 id="_45-如何实现一个ioc容器" tabindex="-1"><a class="header-anchor" href="#_45-如何实现一个ioc容器" aria-hidden="true">#</a> 45.如何实现一个IOC容器?</h3><p>​ IOC(Inversion of Control),意思是控制反转，不是什么技术，而是一种设计思想，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p><p>​ 在传统的程序设计中，我们直接在对象内部通过new进行对象创建，是程序主动去创建依赖对象，而IOC是有专门的容器来进行对象的创建，即IOC容器来控制对象的创建。</p><p>​ 在传统的应用程序中，我们是在对象中主动控制去直接获取依赖对象，这个是正转，反转是由容器来帮忙创建及注入依赖对象，在这个过程过程中，由容器帮我们查找级注入依赖对象，对象只是被动的接受依赖对象。</p><p>​ 1、先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象</p><p>​ 2、进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中</p><p>​ 3、容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作</p><p>​ 4、进行对象的初始化操作，也就是给类中的对应属性值就行设置，也就是进行依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中</p><p>​ 5、通过容器对象来获取对象，进行对象的获取和逻辑处理工作</p><p>​ 6、提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁</p><h3 id="_46-什么的是bean的自动装配" tabindex="-1"><a class="header-anchor" href="#_46-什么的是bean的自动装配" aria-hidden="true">#</a> 46.<strong>什么的是bean的自动装配</strong></h3><ul><li>自动装配是使用spring满足bean依赖的一种方法</li><li>spring会在应用上下文中为某个bean寻找其依赖的bean</li></ul><p>​ no – 缺省情况下，自动配置是通过“ref”属性手动设定，在项目中最常用 ​ byName – 根据属性名称自动装配。如果一个bean的名称和其他bean属性的名称是一样的，将会自装配它。 ​ byType – 按数据类型自动装配，如果bean的数据类型是用其它bean属性的数据类型，兼容并自动装配它。 ​ constructor – 在构造函数参数的byType方式。 ​ autodetect – 如果找到默认的构造函数，使用“自动装配用构造”; 否则，使用“按类型自动装配”。</p><h3 id="_47-springboot自动配置原理是什么" tabindex="-1"><a class="header-anchor" href="#_47-springboot自动配置原理是什么" aria-hidden="true">#</a> 47.springboot自动配置原理是什么？</h3><p>下面详细讲解自动装配的过程。</p><p>1、在springboot的启动过程中，有一个步骤是创建上下文：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">StopWatch</span> stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">ConfigurableApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SpringBootExceptionReporter</span><span class="token punctuation">&gt;</span></span> exceptionReporters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">SpringApplicationRunListeners</span> listeners <span class="token operator">=</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
		listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">try</span> <span class="token punctuation">{</span>
			<span class="token class-name">ApplicationArguments</span> applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">configureIgnoreBeanInfo</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">Banner</span> printedBanner <span class="token operator">=</span> <span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>
			context <span class="token operator">=</span> <span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			exceptionReporters <span class="token operator">=</span> <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">SpringBootExceptionReporter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>
					<span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token class-name">ConfigurableApplicationContext</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//此处完成自动装配的过程</span>
			<span class="token function">prepareContext</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
			stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">callRunners</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> exceptionReporters<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">try</span> <span class="token punctuation">{</span>
			listeners<span class="token punctuation">.</span><span class="token function">running</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ex<span class="token punctuation">,</span> exceptionReporters<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> context<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、在prepareContext方法中查找load方法，一层一层向内点击，找到最终的load方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//prepareContext方法</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">prepareContext</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">,</span> <span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">,</span>
			<span class="token class-name">SpringApplicationRunListeners</span> listeners<span class="token punctuation">,</span> <span class="token class-name">ApplicationArguments</span> applicationArguments<span class="token punctuation">,</span> <span class="token class-name">Banner</span> printedBanner<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		context<span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">postProcessApplicationContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">applyInitializers</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
		listeners<span class="token punctuation">.</span><span class="token function">contextPrepared</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">logStartupInfo</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">logStartupProfileInfo</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Add boot specific singleton beans</span>
		<span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">&quot;springApplicationArguments&quot;</span><span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>printedBanner <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">&quot;springBootBanner&quot;</span><span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">)</span>
					<span class="token punctuation">.</span><span class="token function">setAllowBeanDefinitionOverriding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowBeanDefinitionOverriding<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazyInitialization<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			context<span class="token punctuation">.</span><span class="token function">addBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LazyInitializationBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Load the sources</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sources <span class="token operator">=</span> <span class="token function">getAllSources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>sources<span class="token punctuation">,</span> <span class="token string">&quot;Sources must not be empty&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//load方法完成该功能</span>
		<span class="token function">load</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> sources<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		listeners<span class="token punctuation">.</span><span class="token function">contextLoaded</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


	<span class="token doc-comment comment">/**
	 * Load beans into the application context.
	 * <span class="token keyword">@param</span> <span class="token parameter">context</span> the context to load beans into
	 * <span class="token keyword">@param</span> <span class="token parameter">sources</span> the sources to load
	 * 加载bean对象到context中
	 */</span>
	<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> context<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sources<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;Loading source &quot;</span> <span class="token operator">+</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">arrayToCommaDelimitedString</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//获取bean对象定义的加载器</span>
		<span class="token class-name">BeanDefinitionLoader</span> loader <span class="token operator">=</span> <span class="token function">createBeanDefinitionLoader</span><span class="token punctuation">(</span><span class="token function">getBeanDefinitionRegistry</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">,</span> sources<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			loader<span class="token punctuation">.</span><span class="token function">setBeanNameGenerator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			loader<span class="token punctuation">.</span><span class="token function">setResourceLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>environment <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			loader<span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		loader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token doc-comment comment">/**
	 * Load the sources into the reader.
	 * <span class="token keyword">@return</span> the number of loaded beans
	 */</span>
	<span class="token keyword">int</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> source <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sources<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			count <span class="token operator">+=</span> <span class="token function">load</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、实际执行load的是BeanDefinitionLoader中的load方法，如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	<span class="token comment">//实际记载bean的方法</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token string">&quot;Source must not be null&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果是class类型，启用注解类型</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//如果是resource类型，启动xml解析</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token keyword">instanceof</span> <span class="token class-name">Resource</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Resource</span><span class="token punctuation">)</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//如果是package类型，启用扫描包，例如@ComponentScan</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token keyword">instanceof</span> <span class="token class-name">Package</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Package</span><span class="token punctuation">)</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//如果是字符串类型，直接加载</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token keyword">instanceof</span> <span class="token class-name">CharSequence</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span><span class="token punctuation">)</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid source type &quot;</span> <span class="token operator">+</span> source<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、下面方法将用来判断是否资源的类型，是使用groovy加载还是使用注解的方式</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//判断使用groovy脚本</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isGroovyPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">GroovyBeanDefinitionSource</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// Any GroovyLoaders added in beans{} DSL can contribute beans here</span>
			<span class="token class-name">GroovyBeanDefinitionSource</span> loader <span class="token operator">=</span> <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">instantiateClass</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token class-name">GroovyBeanDefinitionSource</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">load</span><span class="token punctuation">(</span>loader<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//使用注解加载</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isComponent</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>annotatedReader<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5、下面方法判断启动类中是否包含@Component注解，但是会神奇的发现我们的启动类中并没有该注解，继续更进发现MergedAnnotations类传入了一个参数SearchStrategy.TYPE_HIERARCHY，会查找继承关系中是否包含这个注解，@SpringBootApplication--&gt;@SpringBootConfiguration--&gt;@Configuration--&gt;@Component,当找到@Component注解之后，会把该对象注册到AnnotatedBeanDefinitionReader对象中</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isComponent</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// This has to be a bit of a guess. The only way to be sure that this type is</span>
   <span class="token comment">// eligible is to make a bean definition out of it and try to instantiate it.</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">MergedAnnotations</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token class-name">SearchStrategy</span><span class="token punctuation">.</span><span class="token constant">TYPE_HIERARCHY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// Nested anonymous classes are not eligible for registration, nor are groovy</span>
   <span class="token comment">// closures</span>
   <span class="token keyword">return</span> <span class="token operator">!</span>type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">&quot;.*\\$_.*closure.*&quot;</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>type<span class="token punctuation">.</span><span class="token function">isAnonymousClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token operator">&amp;&amp;</span> type<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> type<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

	<span class="token doc-comment comment">/**
	 * Register a bean from the given bean class, deriving its metadata from
	 * class-declared annotations.
	 * 从给定的bean class中注册一个bean对象，从注解中找到相关的元数据
	 */</span>
	<span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">doRegisterBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span>
			<span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> qualifiers<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">,</span>
			<span class="token annotation punctuation">@Nullable</span> <span class="token class-name">BeanDefinitionCustomizer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> customizers<span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token class-name">AnnotatedGenericBeanDefinition</span> abd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotatedGenericBeanDefinition</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>conditionEvaluator<span class="token punctuation">.</span><span class="token function">shouldSkip</span><span class="token punctuation">(</span>abd<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		abd<span class="token punctuation">.</span><span class="token function">setInstanceSupplier</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">ScopeMetadata</span> scopeMetadata <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopeMetadataResolver<span class="token punctuation">.</span><span class="token function">resolveScopeMetadata</span><span class="token punctuation">(</span>abd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		abd<span class="token punctuation">.</span><span class="token function">setScope</span><span class="token punctuation">(</span>scopeMetadata<span class="token punctuation">.</span><span class="token function">getScopeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span> beanName <span class="token operator">=</span> <span class="token punctuation">(</span>name <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> name <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator<span class="token punctuation">.</span><span class="token function">generateBeanName</span><span class="token punctuation">(</span>abd<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span><span class="token function">processCommonDefinitionAnnotations</span><span class="token punctuation">(</span>abd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>qualifiers <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token punctuation">&gt;</span></span> qualifier <span class="token operator">:</span> qualifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Primary</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> qualifier<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					abd<span class="token punctuation">.</span><span class="token function">setPrimary</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Lazy</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> qualifier<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					abd<span class="token punctuation">.</span><span class="token function">setLazyInit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token punctuation">{</span>
					abd<span class="token punctuation">.</span><span class="token function">addQualifier</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutowireCandidateQualifier</span><span class="token punctuation">(</span>qualifier<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>customizers <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionCustomizer</span> customizer <span class="token operator">:</span> customizers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				customizer<span class="token punctuation">.</span><span class="token function">customize</span><span class="token punctuation">(</span>abd<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token class-name">BeanDefinitionHolder</span> definitionHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">(</span>abd<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		definitionHolder <span class="token operator">=</span> <span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span><span class="token function">applyScopedProxyMode</span><span class="token punctuation">(</span>scopeMetadata<span class="token punctuation">,</span> definitionHolder<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">BeanDefinitionReaderUtils</span><span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>definitionHolder<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token doc-comment comment">/**
	 * Register the given bean definition with the given bean factory.
	 * 注册主类，如果有别名可以设置别名
	 */</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>
			<span class="token class-name">BeanDefinitionHolder</span> definitionHolder<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span>
			<span class="token keyword">throws</span> <span class="token class-name">BeanDefinitionStoreException</span> <span class="token punctuation">{</span>

		<span class="token comment">// Register bean definition under primary name.</span>
		<span class="token class-name">String</span> beanName <span class="token operator">=</span> definitionHolder<span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> definitionHolder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Register aliases for bean name, if any.</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> aliases <span class="token operator">=</span> definitionHolder<span class="token punctuation">.</span><span class="token function">getAliases</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>aliases <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> alias <span class="token operator">:</span> aliases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				registry<span class="token punctuation">.</span><span class="token function">registerAlias</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> alias<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token comment">//@SpringBootApplication</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token annotation punctuation">@SpringBootConfiguration</span>
<span class="token annotation punctuation">@EnableAutoConfiguration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span><span class="token constant">CUSTOM</span><span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span><span class="token constant">CUSTOM</span><span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">//@SpringBootConfiguration</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">//@Configuration</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Configuration</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当看完上述代码之后，只是完成了启动对象的注入，自动装配还没有开始，下面开始进入到自动装配。</p><p>6、自动装配入口，从刷新容器开始</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalStateException</span> <span class="token punctuation">{</span>
		<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// Prepare this context for refreshing.</span>
			<span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Tell the subclass to refresh the internal bean factory.</span>
			<span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Prepare the bean factory for use in this context.</span>
			<span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">try</span> <span class="token punctuation">{</span>
				<span class="token comment">// Allows post-processing of the bean factory in context subclasses.</span>
				<span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// Invoke factory processors registered as beans in the context.</span>
                <span class="token comment">// 此处是自动装配的入口</span>
				<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>7、在invokeBeanFactoryPostProcessors方法中完成bean的实例化和执行</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
	 * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
	 * respecting explicit order if given.
	 * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Must be called before singleton instantiation.
	 */</span>
	<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//开始执行beanFactoryPostProcessor对应实现类,需要知道的是beanFactoryPostProcessor是spring的扩展接口，在刷新容器之前，该接口可以用来修改bean元数据信息</span>
		<span class="token class-name">PostProcessorRegistrationDelegate</span><span class="token punctuation">.</span><span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> <span class="token function">getBeanFactoryPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span>
		<span class="token comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getTempClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> beanFactory<span class="token punctuation">.</span><span class="token function">containsBean</span><span class="token punctuation">(</span><span class="token constant">LOAD_TIME_WEAVER_BEAN_NAME</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			beanFactory<span class="token punctuation">.</span><span class="token function">addBeanPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoadTimeWeaverAwareProcessor</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			beanFactory<span class="token punctuation">.</span><span class="token function">setTempClassLoader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ContextTypeMatchClassLoader</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>8、查看invokeBeanFactoryPostProcessors的具体执行方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>
			<span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> beanFactoryPostProcessors<span class="token punctuation">)</span> <span class="token punctuation">{</span>

		<span class="token comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> processedBeans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">BeanDefinitionRegistry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">BeanDefinitionRegistry</span> registry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">;</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> regularPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">&gt;</span></span> registryProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//开始遍历三个内部类，如果属于BeanDefinitionRegistryPostProcessor子类，加入到bean注册的集合，否则加入到regularPostProcessors</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanFactoryPostProcessor</span> postProcessor <span class="token operator">:</span> beanFactoryPostProcessors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>postProcessor <span class="token keyword">instanceof</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token class-name">BeanDefinitionRegistryPostProcessor</span> registryProcessor <span class="token operator">=</span>
							<span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">)</span> postProcessor<span class="token punctuation">;</span>
					registryProcessor<span class="token punctuation">.</span><span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
					registryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>registryProcessor<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token punctuation">{</span>
					regularPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>postProcessor<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
			<span class="token comment">// uninitialized to let the bean factory post-processors apply to them!</span>
			<span class="token comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span>
			<span class="token comment">// PriorityOrdered, Ordered, and the rest.</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">&gt;</span></span> currentRegistryProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span>
            <span class="token comment">//通过BeanDefinitionRegistryPostProcessor获取到对应的处理类“org.springframework.context.annotation.internalConfigurationAnnotationProcessor”，但是需要注意的是这个类在springboot中搜索不到，这个类的完全限定名在AnnotationConfigEmbeddedWebApplicationContext中，在进行初始化的时候会装配几个类，在创建AnnotatedBeanDefinitionReader对象的时候会将该类注册到bean对象中，此处可以看到internalConfigurationAnnotationProcessor为bean名称，容器中真正的类是ConfigurationClassPostProcessor</span>
			<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postProcessorNames <span class="token operator">=</span>
					beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//首先执行类型为PriorityOrdered的BeanDefinitionRegistryPostProcessor</span>
            <span class="token comment">//PriorityOrdered类型表明为优先执行</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">PriorityOrdered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">//获取对应的bean</span>
					currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">//用来存储已经执行过的BeanDefinitionRegistryPostProcessor</span>
					processedBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
			registryProcessors<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//开始执行装配逻辑</span>
			<span class="token function">invokeBeanDefinitionRegistryPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
			currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span>
            <span class="token comment">//其次执行类型为Ordered的BeanDefinitionRegistryPostProcessor</span>
            <span class="token comment">//Ordered表明按顺序执行</span>
			postProcessorNames <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>processedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">Ordered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					processedBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
			registryProcessors<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">invokeBeanDefinitionRegistryPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
			currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span>
            <span class="token comment">//循环中执行类型不为PriorityOrdered，Ordered类型的BeanDefinitionRegistryPostProcessor</span>
			<span class="token keyword">boolean</span> reiterate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>reiterate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				reiterate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				postProcessorNames <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>processedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
						currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						processedBeans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
						reiterate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
				registryProcessors<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">invokeBeanDefinitionRegistryPostProcessors</span><span class="token punctuation">(</span>currentRegistryProcessors<span class="token punctuation">,</span> registry<span class="token punctuation">)</span><span class="token punctuation">;</span>
				currentRegistryProcessors<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.	</span>
            <span class="token comment">//执行父类方法，优先执行注册处理类</span>
			<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>registryProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//执行有规则处理类</span>
			<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>regularPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// Invoke factory processors registered with the context instance.</span>
			<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactoryPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span>
		<span class="token comment">// uninitialized to let the bean factory post-processors apply to them!</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postProcessorNames <span class="token operator">=</span>
				beanFactory<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span>
		<span class="token comment">// Ordered, and the rest.</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> priorityOrderedPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> orderedPostProcessorNames <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> nonOrderedPostProcessorNames <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ppName <span class="token operator">:</span> postProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>processedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// skip - already processed in first phase above</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">PriorityOrdered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				priorityOrderedPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isTypeMatch</span><span class="token punctuation">(</span>ppName<span class="token punctuation">,</span> <span class="token class-name">Ordered</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				orderedPostProcessorNames<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				nonOrderedPostProcessorNames<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ppName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span>
		<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>priorityOrderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>priorityOrderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> orderedPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>orderedPostProcessorNames<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> postProcessorName <span class="token operator">:</span> orderedPostProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			orderedPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>postProcessorName<span class="token punctuation">,</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">sortPostProcessors</span><span class="token punctuation">(</span>orderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>orderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Finally, invoke all other BeanFactoryPostProcessors.</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">&gt;</span></span> nonOrderedPostProcessors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>nonOrderedPostProcessorNames<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> postProcessorName <span class="token operator">:</span> nonOrderedPostProcessorNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			nonOrderedPostProcessors<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>postProcessorName<span class="token punctuation">,</span> <span class="token class-name">BeanFactoryPostProcessor</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>nonOrderedPostProcessors<span class="token punctuation">,</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Clear cached merged bean definitions since the post-processors might have</span>
		<span class="token comment">// modified the original metadata, e.g. replacing placeholders in values...</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">clearMetadataCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>9、开始执行自动配置逻辑（启动类指定的配置，非默认配置），可以通过debug的方式一层层向里进行查找，会发现最终会在ConfigurationClassParser类中，此类是所有配置类的解析类，所有的解析逻辑在parser.parse(candidates)中</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">&gt;</span></span> configCandidates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionHolder</span> holder <span class="token operator">:</span> configCandidates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">BeanDefinition</span> bd <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">//是否是注解类</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>bd <span class="token keyword">instanceof</span> <span class="token class-name">AnnotatedBeanDefinition</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AnnotatedBeanDefinition</span><span class="token punctuation">)</span> bd<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> holder<span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bd <span class="token keyword">instanceof</span> <span class="token class-name">AbstractBeanDefinition</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AbstractBeanDefinition</span><span class="token punctuation">)</span> bd<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AbstractBeanDefinition</span><span class="token punctuation">)</span> bd<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> holder<span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token punctuation">{</span>
					<span class="token function">parse</span><span class="token punctuation">(</span>bd<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> holder<span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionStoreException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span>
						<span class="token string">&quot;Failed to parse configuration class [&quot;</span> <span class="token operator">+</span> bd<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
    	<span class="token comment">//执行配置类</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>deferredImportSelectorHandler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
    	<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
		<span class="token function">processConfigurationClass</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfigurationClass</span><span class="token punctuation">(</span>metadata<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">processConfigurationClass</span><span class="token punctuation">(</span><span class="token class-name">ConfigurationClass</span> configClass<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>conditionEvaluator<span class="token punctuation">.</span><span class="token function">shouldSkip</span><span class="token punctuation">(</span>configClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ConfigurationPhase</span><span class="token punctuation">.</span><span class="token constant">PARSE_CONFIGURATION</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token class-name">ConfigurationClass</span> existingClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configurationClasses<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>configClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>existingClass <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>configClass<span class="token punctuation">.</span><span class="token function">isImported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>existingClass<span class="token punctuation">.</span><span class="token function">isImported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					existingClass<span class="token punctuation">.</span><span class="token function">mergeImportedBy</span><span class="token punctuation">(</span>configClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				<span class="token comment">// Explicit bean definition found, probably replacing an import.</span>
				<span class="token comment">// Let&#39;s remove the old one and go with the new one.</span>
				<span class="token keyword">this</span><span class="token punctuation">.</span>configurationClasses<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>configClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">this</span><span class="token punctuation">.</span>knownSuperclasses<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>configClass<span class="token operator">::</span><span class="token function">equals</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Recursively process the configuration class and its superclass hierarchy.</span>
		<span class="token class-name">SourceClass</span> sourceClass <span class="token operator">=</span> <span class="token function">asSourceClass</span><span class="token punctuation">(</span>configClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token comment">//循环处理bean,如果有父类，则处理父类，直至结束</span>
			sourceClass <span class="token operator">=</span> <span class="token function">doProcessConfigurationClass</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> sourceClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>sourceClass <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">this</span><span class="token punctuation">.</span>configurationClasses<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> configClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>10、继续跟进doProcessConfigurationClass方法，此方式是支持注解配置的核心逻辑</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
	 * Apply processing and build a complete <span class="token punctuation">{</span><span class="token keyword">@link</span> <span class="token reference"><span class="token class-name">ConfigurationClass</span></span><span class="token punctuation">}</span> by reading the
	 * annotations, members and methods from the source class. This method can be called
	 * multiple times as relevant sources are discovered.
	 * <span class="token keyword">@param</span> <span class="token parameter">configClass</span> the configuration class being build
	 * <span class="token keyword">@param</span> <span class="token parameter">sourceClass</span> a source class
	 * <span class="token keyword">@return</span> the superclass, or <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token keyword">null</span></span></span><span class="token punctuation">}</span> if none found or previously processed
	 */</span>
	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">SourceClass</span> <span class="token function">doProcessConfigurationClass</span><span class="token punctuation">(</span><span class="token class-name">ConfigurationClass</span> configClass<span class="token punctuation">,</span> <span class="token class-name">SourceClass</span> sourceClass<span class="token punctuation">)</span>
			<span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>

        <span class="token comment">//处理内部类逻辑，由于传来的参数是启动类，并不包含内部类，所以跳过</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>configClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAnnotated</span><span class="token punctuation">(</span><span class="token class-name">Component</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// Recursively process any member (nested) classes first</span>
			<span class="token function">processMemberClasses</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> sourceClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Process any @PropertySource annotations</span>
        <span class="token comment">//针对属性配置的解析</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">AnnotationAttributes</span> propertySource <span class="token operator">:</span> <span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span><span class="token function">attributesForRepeatable</span><span class="token punctuation">(</span>
				sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">PropertySources</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>
				<span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>PropertySource</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>environment <span class="token keyword">instanceof</span> <span class="token class-name">ConfigurableEnvironment</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token function">processPropertySource</span><span class="token punctuation">(</span>propertySource<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Ignoring @PropertySource annotation on [&quot;</span> <span class="token operator">+</span> sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
						<span class="token string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Process any @ComponentScan annotations</span>
        <span class="token comment">// 这里是根据启动类@ComponentScan注解来扫描项目中的bean</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AnnotationAttributes</span><span class="token punctuation">&gt;</span></span> componentScans <span class="token operator">=</span> <span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span><span class="token function">attributesForRepeatable</span><span class="token punctuation">(</span>
				sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ComponentScans</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">ComponentScan</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>componentScans<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
				<span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>conditionEvaluator<span class="token punctuation">.</span><span class="token function">shouldSkip</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ConfigurationPhase</span><span class="token punctuation">.</span><span class="token constant">REGISTER_BEAN</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">AnnotationAttributes</span> componentScan <span class="token operator">:</span> componentScans<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span>
                <span class="token comment">//遍历项目中的bean，如果是注解定义的bean，则进一步解析</span>
				<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">&gt;</span></span> scannedBeanDefinitions <span class="token operator">=</span>
						<span class="token keyword">this</span><span class="token punctuation">.</span>componentScanParser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>componentScan<span class="token punctuation">,</span> sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionHolder</span> holder <span class="token operator">:</span> scannedBeanDefinitions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token class-name">BeanDefinition</span> bdCand <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOriginatingBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>bdCand <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
						bdCand <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ConfigurationClassUtils</span><span class="token punctuation">.</span><span class="token function">checkConfigurationClassCandidate</span><span class="token punctuation">(</span>bdCand<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>metadataReaderFactory<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">//递归解析，所有的bean,如果有注解，会进一步解析注解中包含的bean</span>
						<span class="token function">parse</span><span class="token punctuation">(</span>bdCand<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> holder<span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Process any @Import annotations</span>
        <span class="token comment">//递归解析，获取导入的配置类，很多情况下，导入的配置类中会同样包含导入类注解</span>
		<span class="token function">processImports</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> sourceClass<span class="token punctuation">,</span> <span class="token function">getImports</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Process any @ImportResource annotations</span>
        <span class="token comment">//解析@ImportResource配置类</span>
		<span class="token class-name">AnnotationAttributes</span> importResource <span class="token operator">=</span>
				<span class="token class-name">AnnotationConfigUtils</span><span class="token punctuation">.</span><span class="token function">attributesFor</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ImportResource</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>importResource <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> resources <span class="token operator">=</span> importResource<span class="token punctuation">.</span><span class="token function">getStringArray</span><span class="token punctuation">(</span><span class="token string">&quot;locations&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">BeanDefinitionReader</span><span class="token punctuation">&gt;</span></span> readerClass <span class="token operator">=</span> importResource<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token string">&quot;reader&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> resource <span class="token operator">:</span> resources<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token class-name">String</span> resolvedResource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>environment<span class="token punctuation">.</span><span class="token function">resolveRequiredPlaceholders</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
				configClass<span class="token punctuation">.</span><span class="token function">addImportedResource</span><span class="token punctuation">(</span>resolvedResource<span class="token punctuation">,</span> readerClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Process individual @Bean methods</span>
        <span class="token comment">//处理@Bean注解修饰的类</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MethodMetadata</span><span class="token punctuation">&gt;</span></span> beanMethods <span class="token operator">=</span> <span class="token function">retrieveBeanMethodMetadata</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MethodMetadata</span> methodMetadata <span class="token operator">:</span> beanMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			configClass<span class="token punctuation">.</span><span class="token function">addBeanMethod</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BeanMethod</span><span class="token punctuation">(</span>methodMetadata<span class="token punctuation">,</span> configClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// Process default methods on interfaces</span>
        <span class="token comment">// 处理接口中的默认方法</span>
		<span class="token function">processInterfaces</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> sourceClass<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Process superclass, if any</span>
        <span class="token comment">//如果该类有父类，则继续返回，上层方法判断不为空，则继续递归执行</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasSuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">String</span> superclass <span class="token operator">=</span> sourceClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSuperClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>superclass <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>superclass<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;java&quot;</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
					<span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>knownSuperclasses<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>superclass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">this</span><span class="token punctuation">.</span>knownSuperclasses<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>superclass<span class="token punctuation">,</span> configClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">// Superclass found, return its annotation metadata and recurse</span>
				<span class="token keyword">return</span> sourceClass<span class="token punctuation">.</span><span class="token function">getSuperClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// No superclass -&gt; processing is complete</span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>11、查看获取配置类的逻辑</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">processImports</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> sourceClass<span class="token punctuation">,</span> <span class="token function">getImports</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token doc-comment comment">/**
	 * Returns <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token annotation punctuation">@Import</span></span></span><span class="token punctuation">}</span> class, considering all meta-annotations.
	 */</span>
	<span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">&gt;</span></span> <span class="token function">getImports</span><span class="token punctuation">(</span><span class="token class-name">SourceClass</span> sourceClass<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">&gt;</span></span> imports <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">&gt;</span></span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">collectImports</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">,</span> imports<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> imports<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
    	<span class="token doc-comment comment">/**
	 * Recursively collect all declared <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token annotation punctuation">@Import</span></span></span><span class="token punctuation">}</span> values. Unlike most
	 * meta-annotations it is valid to have several <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token annotation punctuation">@Import</span></span></span><span class="token punctuation">}</span>s declared with
	 * different values; the usual process of returning values from the first
	 * meta-annotation on a class is not sufficient.
	 * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>For example, it is common for a <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token annotation punctuation">@Configuration</span></span></span><span class="token punctuation">}</span> class to declare direct
	 * <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token annotation punctuation">@Import</span></span></span><span class="token punctuation">}</span>s in addition to meta-imports originating from an <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token annotation punctuation">@Enable</span></span></span><span class="token punctuation">}</span>
	 * annotation.
	 * 看到所有的bean都以导入的方式被加载进去
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">collectImports</span><span class="token punctuation">(</span><span class="token class-name">SourceClass</span> sourceClass<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">&gt;</span></span> imports<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SourceClass</span><span class="token punctuation">&gt;</span></span> visited<span class="token punctuation">)</span>
			<span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SourceClass</span> annotation <span class="token operator">:</span> sourceClass<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token class-name">String</span> annName <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>annName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Import</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token function">collectImports</span><span class="token punctuation">(</span>annotation<span class="token punctuation">,</span> imports<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			imports<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>sourceClass<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">Import</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>12、继续回到ConfigurationClassParser中的parse方法中的最后一行,继续跟进该方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">this</span><span class="token punctuation">.</span>deferredImportSelectorHandler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DeferredImportSelectorHolder</span><span class="token punctuation">&gt;</span></span> deferredImports <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deferredImportSelectors<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>deferredImportSelectors <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token keyword">try</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>deferredImports <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token class-name">DeferredImportSelectorGroupingHandler</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DeferredImportSelectorGroupingHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					deferredImports<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token constant">DEFERRED_IMPORT_COMPARATOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					deferredImports<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>handler<span class="token operator">::</span><span class="token function">register</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					handler<span class="token punctuation">.</span><span class="token function">processGroupImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">finally</span> <span class="token punctuation">{</span>
				<span class="token keyword">this</span><span class="token punctuation">.</span>deferredImportSelectors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processGroupImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DeferredImportSelectorGrouping</span> grouping <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>groupings<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				grouping<span class="token punctuation">.</span><span class="token function">getImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>entry <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
					<span class="token class-name">ConfigurationClass</span> configurationClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configurationClasses<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>
							entry<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">try</span> <span class="token punctuation">{</span>
						<span class="token function">processImports</span><span class="token punctuation">(</span>configurationClass<span class="token punctuation">,</span> <span class="token function">asSourceClass</span><span class="token punctuation">(</span>configurationClass<span class="token punctuation">)</span><span class="token punctuation">,</span>
								<span class="token function">asSourceClasses</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getImportClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionStoreException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
						<span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
						<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span>
								<span class="token string">&quot;Failed to process import candidates for configuration class [&quot;</span> <span class="token operator">+</span>
										configurationClass<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
    <span class="token doc-comment comment">/**
		 * Return the imports defined by the group.
		 * <span class="token keyword">@return</span> each import with its associated configuration class
		 */</span>
		<span class="token keyword">public</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Group<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&gt;</span></span> <span class="token function">getImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DeferredImportSelectorHolder</span> deferredImport <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deferredImports<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">this</span><span class="token punctuation">.</span>group<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>deferredImport<span class="token punctuation">.</span><span class="token function">getConfigurationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
						deferredImport<span class="token punctuation">.</span><span class="token function">getImportSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>group<span class="token punctuation">.</span><span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
    <span class="token keyword">public</span> <span class="token class-name">DeferredImportSelector</span> <span class="token function">getImportSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>importSelector<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
    <span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">,</span> <span class="token class-name">DeferredImportSelector</span> deferredImportSelector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>deferredImportSelector <span class="token keyword">instanceof</span> <span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">,</span>
					<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;Only %s implementations are supported, got %s&quot;</span><span class="token punctuation">,</span>
							<span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
							deferredImportSelector<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">AutoConfigurationEntry</span> autoConfigurationEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">)</span> deferredImportSelector<span class="token punctuation">)</span>
					<span class="token punctuation">.</span><span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token function">getAutoConfigurationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>autoConfigurationEntries<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> importClassName <span class="token operator">:</span> autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">this</span><span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>importClassName<span class="token punctuation">,</span> annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_48-什么是嵌入式服务器-为什么使用嵌入式服务器" tabindex="-1"><a class="header-anchor" href="#_48-什么是嵌入式服务器-为什么使用嵌入式服务器" aria-hidden="true">#</a> 48.什么是嵌入式服务器，为什么使用嵌入式服务器？</h3><p>​ 在springboot框架中，大家应该发现了有一个内嵌的tomcat，在之前的开发流程中，每次写好代码之后必须要将项目部署到一个额外的web服务器中，只有这样才可以运行，这个明显要麻烦很多，而使用springboot的时候，你会发现在启动项目的时候可以直接按照java应用程序的方式来启动项目，不需要额外的环境支持，也不需要tomcat服务器，这是因为在springboot框架中内置了tomcat.jar，来通过main方法启动容器，达到一键开发部署的方式，不需要额外的任何其他操作。</p><h3 id="_49-spring中的事务是如何实现的" tabindex="-1"><a class="header-anchor" href="#_49-spring中的事务是如何实现的" aria-hidden="true">#</a> 49.Spring中的事务是如何实现的</h3><ol><li><p>Spring事务底层是基于<strong>数据库事务和AOP机制</strong>的</p></li><li><p>⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个<strong>代理对象</strong>作为Bean</p></li><li><p>当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解</p></li><li><p>如果加了，那么则利⽤事务管理器创建⼀个数据库连接</p></li><li><p>并且修改数据库连接的autocommit属性为false，<strong>禁⽌此连接的⾃动提交</strong>，这是实现Spring事务⾮常重要的⼀步</p></li><li><p>然后执⾏当前⽅法，⽅法中会执⾏sql</p></li><li><p>执⾏完当前⽅法后，如果没有出现异常就直接提交事务</p></li><li><p>如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</p></li><li><p>Spring事务的隔离级别对应的就是数据库的隔离级别</p></li><li><p>Spring事务的传播机制是Spring事务⾃⼰实现的，也是Spring事务中最复杂的</p></li><li><p>Spring事务的传播机制是基于数据库连接来做的，⼀个数据库连接⼀个事务，如果传播机制配置为需要新开⼀个事务，那么实际上就是先建⽴⼀个数据库连接，在此新数据库连接上执⾏sql</p></li></ol><h3 id="_50-spring启动流程" tabindex="-1"><a class="header-anchor" href="#_50-spring启动流程" aria-hidden="true">#</a> 50.Spring启动流程</h3><ol><li><p>在创建Spring容器，也就是启动Spring时,⾸先会进⾏扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中</p></li><li><p>然后筛选出<strong>⾮懒加载的单例BeanDefinition</strong>进⾏创建Bean，对于多例Bean不需要在启动过程中去进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建</p></li><li><p>利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推断 构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始化后这⼀步骤中</p></li><li><p>单例Bean创建完了之后，Spring会发布⼀个容器启动事件</p></li><li><p>Spring启动结束</p></li><li><p>在源码中会更复杂，⽐如源码中会提供⼀些模板⽅法，让⼦类来实现，⽐如源码中还涉及到⼀些 BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注⼊就是通过BeanPostProcessor来实现的</p></li><li><p>BenaFactoryPostProcessor来实现的，依赖注⼊</p></li></ol><h3 id="_51-spring-boot中配置文件的加载顺序是怎样的" tabindex="-1"><a class="header-anchor" href="#_51-spring-boot中配置文件的加载顺序是怎样的" aria-hidden="true">#</a> 51.Spring Boot中配置⽂件的加载顺序是怎样的？</h3><p>优先级从⾼到低，⾼优先级的配置覆盖低优先级的配置，所有配置会形成互补配置。</p><ol><li><p>命令⾏参数。所有的配置都可以在命令⾏上进⾏指定；</p></li><li><p>Java系统属性（System.getProperties()）；</p></li><li><p>操作系统环境变量 ；</p></li><li><p>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置⽂件</p></li><li><p>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置⽂件 再来加载不带profile</p></li><li><p>jar包外部的application.properties或application.yml(不带spring.profile)配置⽂件</p></li><li><p>jar包内部的application.properties或applicatio.yml</p></li></ol><h3 id="_52-延迟加载" tabindex="-1"><a class="header-anchor" href="#_52-延迟加载" aria-hidden="true">#</a> 52.延迟加载</h3><p>默认情况下，容器启动之后会将所有作用域为<strong>单例</strong>的 Bean 都创建好，但是有的业务场景我们并不需要它提前都创建好。此时，我们可以在Bean 中设置 <code>lzay-init = &quot;true&quot;</code> 。</p><ul><li>这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。</li><li>而是在获得该 Bean 时，才真正在创建加载。</li></ul><h3 id="_53-restcontroller-和-controller-有什么区别" tabindex="-1"><a class="header-anchor" href="#_53-restcontroller-和-controller-有什么区别" aria-hidden="true">#</a> 53.@RestController 和 @Controller 有什么区别？</h3><p><code>@RestController</code> 注解，在 <code>@Controller</code> 基础上，增加了 <code>@ResponseBody</code> 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。</p><h3 id="_54-requestmapping-注解有什么用" tabindex="-1"><a class="header-anchor" href="#_54-requestmapping-注解有什么用" aria-hidden="true">#</a> 54.@RequestMapping 注解有什么用？</h3><p><code>@RequestMapping</code> 注解，用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p><ul><li>类级别：映射请求的 URL。</li><li>方法级别：映射 URL 以及 HTTP 请求方法。</li></ul><h3 id="_55-requestmapping-和-getmapping-注解的不同之处在哪里" tabindex="-1"><a class="header-anchor" href="#_55-requestmapping-和-getmapping-注解的不同之处在哪里" aria-hidden="true">#</a> 55.@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h3><ul><li><code>@RequestMapping</code> 可注解在类和方法上；<code>@GetMapping</code> 仅可注册在方法上。</li><li><code>@RequestMapping</code> 可进行 GET、POST、PUT、DELETE 等请求方法；<code>@GetMapping</code> 是 <code>@RequestMapping</code> 的 GET 请求方法的特例，目的是为了提高清晰度。</li></ul><h3 id="_56-spring-中有哪些方式可以把-bean-注入-到-ioc-容器" tabindex="-1"><a class="header-anchor" href="#_56-spring-中有哪些方式可以把-bean-注入-到-ioc-容器" aria-hidden="true">#</a> 56.Spring 中有哪些方式可以把 Bean 注入 到 IOC 容器？</h3><p>使用@CompontScan 注解来扫描声明了@Controller、@Service、@Repository、 @Component 注解的类。</p><p>使用@Configuration 注解声明配置类，并使用@Bean 注解实现 Bean 的定义， 这种方式其实是 xml 配置方式的一种演变，是 Spring 迈入到无配置化时代的里 程碑。</p><p>使用@Import 注解，导入配置类或者普通的 Bean</p><p>使 用 FactoryBean 工 厂 bean ， 动 态 构 建 一 个 Bean 实 例 ， Spring Cloud OpenFeign 里面的动态代理实例就是使用 FactoryBean 来实现的。</p><p>实现 ImportBeanDefinitionRegistrar 接口， 可以动态注入 Bean 实例。 这个在 Spring Boot 里面的启动注解有用到。</p><p>实现 ImportSelector 接口，动态批量注入配置类或者 Bean 对象，这个在 Spring Boot 里面的自动装配机制里面有用到。</p><h3 id="_57-spring-中-beanfactory-和-factorybean-的区别" tabindex="-1"><a class="header-anchor" href="#_57-spring-中-beanfactory-和-factorybean-的区别" aria-hidden="true">#</a> 57.Spring 中 BeanFactory 和 FactoryBean 的区别</h3><p>首先，Spring 里面的核心功能是 IOC 容器，所谓 IOC 容器呢，本质上就是一个 Bean 的容器或者是一个 Bean 的工厂。 它能够根据 xml 里面声明的 Bean 配置进行 bean 的加载和初始化， 然后 BeanFactory 来生产我们需要的各种各样的 Bean。 所以我对 BeanFactory 的理解了有两个。</p><p>BeanFactory 是所有 Spring Bean 容器的顶级接口，它为 Spring 的容器定义了 一套规范，并提供像 getBean 这样的方法从容器中获取指定的 Bean 实例。</p><p>BeanFactory 在产生 Bean 的同时，还提供了解决 Bean 之间的依赖注入的能力， 也就是所谓的 DI。</p><p>FactoryBean 是一个工厂 Bean，它是一个接口，<strong>主要的功能是动态生成某一个类型的 Bean 的实例</strong>，也就是说，我们可以自定义一个 Bean 并且加载到 IOC 容 器里面。</p><p>它里面有一个重要的方法叫 getObject() ， 这个方法里面就是用来实现动态构建 Bean 的过程。 Spring Cloud 里 面 的 OpenFeign 组 件 ， 客 户 端 的 代 理 类 ， 就 是 使 用 了 FactoryBean 来实现的。</p><h3 id="_58-介绍下-spring-ioc-的工作流程" tabindex="-1"><a class="header-anchor" href="#_58-介绍下-spring-ioc-的工作流程" aria-hidden="true">#</a> 58.介绍下 Spring IoC 的工作流程</h3><p>IOC 的全称是 Inversion Of Control,也就是控制反转，它的核心思想是把对象的管理权限交给容器。 应用程序如果需要使用到某个对象实例，直接从 IOC 容器中去获取就行，这样设计的好处是降低了程序里面对象与对象之间的耦合性。 使得程序的整个体系结构变得更加灵活。</p><p>Spring 里面很多方式去定义 Bean， 比如 XML 里面的<!---->标签、@Service、 @Component、@Repository、@Configuration 配置类中的@Bean 注解等等。 Spring 在启动的时候，会去解析这些 Bean 然后保存到 IOC 容器里面。</p><p>Spring IOC 的工作流程大致可以分为两个阶段。</p><p>第一个阶段，就是 IOC 容器的初始化这个阶段主要是根据程序中定义的 XML 或者注解等 Bean 的声明方式 通过解析和加载后生成 BeanDefinition， 然后把 BeanDefinition 注册到 IOC 容 器。</p><p>通过注解或者 xml 声明的 bean 都会解析得到一个 BeanDefinition 实体，实体中包含这个 bean 中定义的基本属性。 最后把这个 BeanDefinition 保存到一个 Map 集合里面，从而完成了 IOC 的初始 化。 IoC 容器的作用就是对这些注册的 Bean 的定义信息进行处理和维护，它 IoC 容 器控制反转的核心。</p><p>第二个阶段，完成 Bean 初始化及依赖注入 然后进入到第二个阶段，这个阶段会做两个事情</p><p>通过反射针对没有设置 lazy-init 属性的单例 bean 进行初始化。</p><p>完成 Bean 的依赖注入。</p><p>第三个阶段， Bean 的使用 通常我们会通过@Autowired 或者 BeanFactory.getBean()从 IOC 容器中获取指 定的 bean 实例。 另外，针对设置 layy-init 属性以及非单例 bean 的实例化，是在每次获取 bean 对象的时候，调用 bean 的初始化方法来完成实例化的，并且 Spring IOC 容器 不会去管理这些 Bean。</p><h3 id="_59-过滤器、拦截器、aop的区别" tabindex="-1"><a class="header-anchor" href="#_59-过滤器、拦截器、aop的区别" aria-hidden="true">#</a> 59.过滤器、拦截器、AOP的区别</h3><ol><li>什么是过滤器（Filter） 过滤器，顾名思义就是起到过滤筛选作用的一种事物，只不过相较于现实生活中的过滤器，这里的过滤器过滤的对象是客户端访问的web资源，也可以理解为一种预处理手段，对资源进行拦截后，将其中我们认为的杂质（用户自己定义的）过滤，符合条件的放行，不符合的则拦截下来。</li></ol><figure><img src="https://minio.pigx.top/oss/2022/08/I0cOTk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>1.1 过滤器常见的使用场景</p><ol><li>统一设置编码</li><li>过滤敏感字符</li><li>登录校验</li><li>URL级别的访问权限控制</li><li>数据压缩</li></ol><p>1.2 Springboot 整合过滤器</p><p><strong>Bean注入方式</strong></p><blockquote><p>编写Filter</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;您已进入filter过滤器，您的请求正常，请继续遵规则...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编写Filter配置类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">FilterRegistrationBean</span> <span class="token function">heFilterRegistration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">FilterRegistrationBean</span> registration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HeFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        registration<span class="token punctuation">.</span><span class="token function">addUrlPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> registration<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注解方式</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Component</span>
<span class="token comment">// filterName就是当前类名称，还有一个urlPattens的参数，这个参数表示要过滤的URL上的后缀名，是多参数，可以用数组表示。</span>
<span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span> 或 <span class="token punctuation">(</span>filterName <span class="token operator">=</span> <span class="token string">&quot;f1&quot;</span><span class="token punctuation">,</span> urlPatterns <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;*.html&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;*.jsp&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloFilter2</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">,</span>
                         <span class="token class-name">FilterChain</span> filterChain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;进入到过滤器2啦&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 这里可以进行一些条件判断（假如要做登录验证的话）</span>
        filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span>servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在主启动类上加@ServletComponentScan(“com.pandy.blog.filters”) 指明filter所在位置的包。 若有多个filter，默认根据filter类名的字母倒叙排列，且@WebFilter注解方式的过滤器优先级高于Bean注入方式配置的过滤器。</p><p>1.3 过滤器（Filter）详解</p><p>a) Filter是依赖于Servlet的，需要有Servlet的依赖。</p><p>b) init() 在容器初始化时执行，只执行一次。</p><p>c) doFilter() 目标请求之前拦截执行，拦截之后需要放行才开始执行目标方法。filterChain.doFilter(servletRequest,servletResponse);</p><p>d) destroy() 在容器销毁时执行，只执行一次。</p><p>e) Filter可以拦截所有请求。包括静态资源[css，js…]。</p><p>f) 基于函数回调实现。</p><p>g) 过滤器只能在容器初始化时被调用一次。</p><ol start="2"><li>什么是拦截器（Interceptor）</li></ol><p>拦截器是springmvc提供的，类似于过滤器。主要用于拦截用户请求并作相应的处理。</p><figure><img src="https://minio.pigx.top/oss/2022/08/sYDWvg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2.1 拦截器的使用场景</p><p>a) 日志记录</p><p>b) 权限校验</p><p>c) 登录校验</p><p>d) 性能检测[检测方法的执行时间]</p><p>其实拦截器和过滤器很像，有些使用场景。无论选用谁都能实现。需要注意的使他们彼此的使用范围，触发机制。</p><p>2.2 springboot整合拦截器</p><ul><li>编写自定义拦截器类实现HandlerInterceptor接口或继承其子类【推荐实现的方式，实现可以自动生成preHandle…】</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterceptorDemo</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;拦截器preHandle在控制器方法执行前执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//true：表示放行</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">ModelAndView</span> modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;拦截器postHandle在控制器方法执行后执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;拦截器afterCompletion在请求完成后执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>基于springmvc编写配置类</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token comment">// 老版本呢是继承WebMvcConfigurerAdapter不过新版本已经放弃了，推荐用下面的方式。</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterceptorConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span> 

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">InterceptorDemo</span> interceptorDemo<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ** 表示所有拦截路径</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span>interceptorDemo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 或下面这种写法  【若编写自定义拦截器类没有加@Component注解】</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InterceptorDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.3 拦截器详情 a) 拦截器是依赖于SpringMVC的，需要有mvc的依赖。</p><p>b) preHandle() 在目标请求完成之前执行。有返回值Boolean类型，true：表示放行</p><p>c) postHandle() 在目标请求之完成后执行。</p><p>d) afterCompletion() 在整个请求完成之后【modelAndView已被渲染执行】。</p><p>e) 拦截器只能拦截action请求。不包括静态资源==[css，js…]==。</p><p>f) 基于java反射机制实现。</p><p>g) 在拦截器的生命周期中，可以多次被调用。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>关于拦截器的<span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法的参数说明：
      <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span><span class="token punctuation">{</span>
      
      <span class="token punctuation">}</span>

      <span class="token annotation punctuation">@param</span> request        current <span class="token constant">HTTP</span> request
      <span class="token annotation punctuation">@param</span> response       current <span class="token constant">HTTP</span> response
      <span class="token annotation punctuation">@param</span> handler        chosen handler <span class="token keyword">to</span> <span class="token namespace">execute</span><span class="token punctuation">,</span> <span class="token keyword">for</span> type and<span class="token operator">/</span>or instance evaluation   <span class="token comment">//选择要执行的处理程序，用于类型和/或实例计算</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>拦截器与过滤器的区别</li></ol><figure><img src="https://minio.pigx.top/oss/2022/08/ZdMHZn.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>1、过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。</p><p>2、拦截器可以获取IOC容器中的各个bean，而过滤器就不行，因为拦截器是spring提供并管理的，spring的功能可以被拦截器使用，在拦截器里注入一个service，可以调用业务逻辑。而过滤器是JavaEE标准，只需依赖servlet api ，不需要依赖spring。</p><p>3、过滤器的实现基于回调函数。而拦截器（代理模式）的实现基于反射</p><p>4、Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。</p><p>5、Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理（反射）的方式来执行。</p><p>6、Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。</p><p>7、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用（包括静态资源）。</p><p>【重点】过滤器和拦截器非常相似，但是它们有很大的区别:</p><p>最简单明了的区别就是过滤器可以修改request，而拦截器不能</p><p>过滤器需要在servlet容器中实现，拦截器可以适用于javaEE，javaSE等各种环境</p><p>拦截器可以调用IOC容器中的各种依赖，而过滤器不能</p><p>过滤器只能在请求的前后使用，而拦截器可以详细到每个方法</p><p>当有过滤器和拦截器时的执行流程： <img src="https://minio.pigx.top/oss/2022/08/a8Z0Fj.png" alt="" loading="lazy"></p><p>链接： <a href="https://mp.weixin.qq.com/s/cgAkz7f2uRJURnzr9LSjkA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/cgAkz7f2uRJURnzr9LSjkA<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>4.AOP与过滤器、拦截器的区别</p><p>过滤器，拦截器拦截的是URL。AOP拦截的是类的元数据(包、类、方法名、参数等)。</p><p>过滤器并没有定义业务用于执行逻辑前、后等，仅仅是请求到达就执行。</p><p>拦截器有三个方法，相对于过滤器更加细致，有被拦截逻辑执行前、后等。 AOP针对具体的代码，能够实现更加复杂的业务逻辑。</p><p>三者功能类似，但各有优势，从过滤器–》拦截器–》切面，拦截规则越来越细致。 执行顺序依次是过滤器、拦截器、切面。</p><p>三者的使用场景</p><p>在编写相对比较公用的代码时，优先考虑过滤器，然后是拦截器，最后是aop。</p><p>比如：</p><p>权限校验，一般情况下，所有的请求都需要做登陆校验，此时就应该使用过滤器在最顶层做校验；</p><p>日志记录，一般日志只会针对部分逻辑做日志记录，而且牵扯到业务逻辑完成前后的日志记录，因此使用过滤器不能细致地划分模块，此时应该考虑拦截器，</p><p>然而拦截器也是依据URL做规则匹配，因此相对来说不够细致，因此我们会考虑到使用AOP实现，AOP可以针对代码的方法级别做拦截，很适合日志功能。</p><h3 id="_60-什么情况下会导致-async异步方法会失效" tabindex="-1"><a class="header-anchor" href="#_60-什么情况下会导致-async异步方法会失效" aria-hidden="true">#</a> 60.什么情况下会导致@Async异步方法会失效？</h3><p>1.不要在本类中异步调用。即一个方法是异步方法，然后用另一个方法调用这个异步方法。</p><p>2.不要有返回值，使用void</p><p>3.不能使用本类的私有方法或者非接口化加注@Async,因为代理不到失效</p><p>4.异步方法不能使用static修饰</p><p>5.异步类需使用@Component注解，不然将导致spring无法扫描到异步类</p><p>6.SpringBoot框架必须在启动类中增加@EnableAsync注解</p><p>7.异步方法不要和事物注解同时存在。可以在事物的方法中调用另外一个类中的异步方法。在调用Async方法的方法上标注@Transactional是管理调用方法的事务的,在Async方法上标注@Transactional是管理异步方法的事务,事务因线程隔离</p><p>8.诸如以上几点的情况比如spring中的@Transactional还有cache注解也不能有以上几点情况，否则也会失效的，因为本质都是因为代理的机制导致的</p><h3 id="_61-spring与springboot默认aop采用" tabindex="-1"><a class="header-anchor" href="#_61-spring与springboot默认aop采用" aria-hidden="true">#</a> 61.spring与springboot默认aop采用？</h3><p>Spring 5.x 中 AOP 默认依旧使用 JDK 动态代理。 SpringBoot 2.x 开始，为了解决使用 JDK 动态代理可能导致的类型转化异常而默认使用 CGLIB。 在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项spring.aop.proxy-target-class=false来进行修改，proxyTargetClass配置已无效。</p><h3 id="_62-介绍下spring的初始化过程" tabindex="-1"><a class="header-anchor" href="#_62-介绍下spring的初始化过程" aria-hidden="true">#</a> 62.介绍下Spring的初始化过程</h3><figure><img src="https://minio.pigx.top/oss/2022/08/4xy9j9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每个方法的相关作用</p><figure><img src="https://minio.pigx.top/oss/2022/08/z0NLUq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_63-配置文件的加载解析" tabindex="-1"><a class="header-anchor" href="#_63-配置文件的加载解析" aria-hidden="true">#</a> 63.配置文件的加载解析</h3><p> Spring初始化的时候在obtainFreshBeanFactory方法中完成了配置文件的加载解析，并把解析的bean标签信息封装到了BeanDefinition对象中，所有的解析的BeanDefinition对象都存储在了DefaultListableBeanFactory对象的beanDefinitionMap的Map集合中。</p><h3 id="_64-介绍下spring中常用的注解" tabindex="-1"><a class="header-anchor" href="#_64-介绍下spring中常用的注解" aria-hidden="true">#</a> 64.介绍下Spring中常用的注解</h3><ul><li>@Import注解本身的由来是在Spring3.0的时候由xml文件的方式向注解编程的发展，替换以前在配置文件中的/<code>&lt;import&gt;标签</code> ，也就是可以导入其他的配置类，然后@Import注解还扩展了对应的功能</li></ul><p>​ 静态注入：可以直接把对应的类型注入到容器中:@Import(User.class)</p><p>​ 动态注入：可以实现ImportSelector接口和ImportBeanDefinitionRegistrar接口，然后通过重写对应的方法来实现动态的注入</p><p>​ 当然在ImportSelector接口的实现还可以触发延迟加载的逻辑。DeferredImportSelector，这块在SpringBoot的自动装配中就应用到了</p><ul><li>@indexed注解。默认所有的@compoent注解都加了indexed注解，用于加快索引组件。</li></ul><h3 id="_65-springboot-的自动装配原理" tabindex="-1"><a class="header-anchor" href="#_65-springboot-的自动装配原理" aria-hidden="true">#</a> 65.SpringBoot 的自动装配原理</h3><figure><img src="https://minio.pigx.top/oss/2022/08/H6pAnR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_66-介绍下springboot的启动流程" tabindex="-1"><a class="header-anchor" href="#_66-介绍下springboot的启动流程" aria-hidden="true">#</a> 66.介绍下SpringBoot的启动流程</h3><figure><img src="https://minio.pigx.top/oss/2022/08/lXRpLu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_67-spring-只处理单例模式下得循环依赖" tabindex="-1"><a class="header-anchor" href="#_67-spring-只处理单例模式下得循环依赖" aria-hidden="true">#</a> 67.Spring 只处理单例模式下得循环依赖?</h3><ul><li>对于<strong>单例( Singleton )模式</strong>， Spring 在创建 Bean 的时候并不是等 Bean 完全创建完成后才会将 Bean 添加至缓存中，而是不等 Bean 创建完成就会将创建 Bean 的 ObjectFactory 提早加入到缓存中，这样一旦下一个 Bean 创建的时候需要依赖 bean 时则直接使用 ObjectFactroy 。</li><li>但是<strong>原型( Prototype )模式</strong>，我们知道是没法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理。</li></ul><h3 id="_68-last-modified缓存机制" tabindex="-1"><a class="header-anchor" href="#_68-last-modified缓存机制" aria-hidden="true">#</a> 68.Last-Modified缓存机制？</h3><p>Spring MVC 支持HTTP协议的 Last-Modified 缓存机制。</p><p>在客户端地一次输入URL时，服务器端会返回内容和状态码200， 表示请求成功，同时会添加一个“Last-Modified”属性，表示该请求资源的最后修改时间。</p><p>客户端第二次请求此URL时，客户端会向服务器发送请求头 “IF-Modified-Since”，如果服务端内容没有变化，则自动返回HTTP304状态码（只返回相应头信息，不返回资源文件内容，这样就可以节省网络带宽，提供响应速度和用户体验）</p><p>#DispatcherServlet.doDispatch()首先获取 http 请求的method type。如果method 是 “GET”或“HEAD” 才支持缓存机制</p><h1 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列" aria-hidden="true">#</a> 消息队列</h1><h3 id="_1-为什么要用消息队列" tabindex="-1"><a class="header-anchor" href="#_1-为什么要用消息队列" aria-hidden="true">#</a> 1.为什么要用消息队列？</h3><p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p><ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li><li><strong>削峰/限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol><h3 id="_2-使用消息队列带来的一些问题" tabindex="-1"><a class="header-anchor" href="#_2-使用消息队列带来的一些问题" aria-hidden="true">#</a> 2.使用消息队列带来的一些问题？</h3><ul><li><strong>系统可用性降低：</strong> 在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>**一致性问题：**万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h3 id="_3-什么是jms" tabindex="-1"><a class="header-anchor" href="#_3-什么是jms" aria-hidden="true">#</a> 3.什么是JMS ？</h3><p>JMS（JAVA Message Service,java 消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。</p><p><strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><h3 id="_4-jms-两种消息模型" tabindex="-1"><a class="header-anchor" href="#_4-jms-两种消息模型" aria-hidden="true">#</a> 4.JMS 两种消息模型？</h3><p><strong>① 点到点（P2P）模型</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/nqVNwt.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用<strong>队列（Queue）作为消息通信载体；满足生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p><p><strong>② 发布/订阅（Pub/Sub）模型</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/wc7dCd.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）作为消息通信载体，类似于广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p><h3 id="_5-jms-五种不同的消息正文格式" tabindex="-1"><a class="header-anchor" href="#_5-jms-五种不同的消息正文格式" aria-hidden="true">#</a> 5.JMS 五种不同的消息正文格式</h3><p>JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><ul><li>StreamMessage -- Java 原始值的数据流</li><li>MapMessage--一套名称-值对</li><li>TextMessage--一个字符串对象</li><li>ObjectMessage--一个序列化的 Java 对象</li><li>BytesMessage--一个字节的数据流</li></ul><h3 id="_6-什么是amqp" tabindex="-1"><a class="header-anchor" href="#_6-什么是amqp" aria-hidden="true">#</a> 6.什么是AMQP？</h3><p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><p><strong>RabbitMQ 就是基于 AMQP 协议实现的</strong></p><h3 id="_7-jms-vs-amqp" tabindex="-1"><a class="header-anchor" href="#_7-jms-vs-amqp" aria-hidden="true">#</a> 7.JMS vs AMQP</h3><table><thead><tr><th style="text-align:left;">对比方向</th><th style="text-align:left;">JMS</th><th style="text-align:left;">AMQP</th></tr></thead><tbody><tr><td style="text-align:left;">定义</td><td style="text-align:left;">Java API</td><td style="text-align:left;">协议</td></tr><tr><td style="text-align:left;">跨语言</td><td style="text-align:left;">否</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">跨平台</td><td style="text-align:left;">否</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">支持消息类型</td><td style="text-align:left;">提供两种消息模型：①Peer-2-Peer;②Pub/sub</td><td style="text-align:left;">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td style="text-align:left;">支持消息类型</td><td style="text-align:left;">支持多种消息类型 ，我们在上面提到过</td><td style="text-align:left;">byte[]（二进制）</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li><li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li></ul><h3 id="_8-什么是producer、consumer、broker、topic、partition" tabindex="-1"><a class="header-anchor" href="#_8-什么是producer、consumer、broker、topic、partition" aria-hidden="true">#</a> 8.什么是Producer、Consumer、Broker、Topic、Partition？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/MKxaJO.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p><ol><li><strong>Producer（生产者）</strong> : 产生消息的一方。</li><li><strong>Consumer（消费者）</strong> : 消费消息的一方。</li><li><strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li></ol><p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p><ul><li><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li><li><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。</li></ul><h3 id="_9-kafka-的多副本机制了解吗-带来了什么好处" tabindex="-1"><a class="header-anchor" href="#_9-kafka-的多副本机制了解吗-带来了什么好处" aria-hidden="true">#</a> 9.Kafka 的多副本机制了解吗？带来了什么好处？</h3><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><blockquote><p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p></blockquote><p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p><ol><li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li><li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ol><h3 id="_10-kafka-如何保证消息的消费顺序" tabindex="-1"><a class="header-anchor" href="#_10-kafka-如何保证消息的消费顺序" aria-hidden="true">#</a> 10.Kafka 如何保证消息的消费顺序？</h3><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p><ol><li>更改用户会员等级。</li><li>根据会员等级计算订单价格。</li></ol><p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p><figure><img src="https://minio.pigx.top/oss/2022/07/bMdoVP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p><blockquote><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p></blockquote><p>所以，我们就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p><p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p><ol><li>1 个 Topic 只对应一个 Partition。</li><li>（推荐）发送消息的时候指定 key/Partition。</li></ol><p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的。</p><h3 id="_11-kafka-如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#_11-kafka-如何保证消息不丢失" aria-hidden="true">#</a> 11.Kafka 如何保证消息不丢失？</h3><ul><li><strong>生产者丢失消息的情况</strong></li></ul><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SendResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sendResult <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>sendResult<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;生产者成功发送消息到&quot;</span> <span class="token operator">+</span> sendResult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;-&gt; &quot;</span> <span class="token operator">+</span> sendRe
              sult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token class-name">ListenableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        future<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>result <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;生产者成功发送消息到topic:{} partition:{}的消息&quot;</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                ex <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;生产者发送消失败，原因：{}&quot;</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>另外这里推荐为 Producer 的<code>retries </code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p><ul><li><strong>消费者丢失消息的情况</strong></li></ul><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><figure><img src="https://minio.pigx.top/oss/2022/07/ZClA7L.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><ul><li><strong>Kafka 弄丢了消息</strong></li></ul><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><p><strong>设置 acks = all</strong></p><p>解决办法就是我们设置 <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p><p><strong>设置 replication.factor &gt;= 3</strong></p><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p><p><strong>设置 unclean.leader.election.enable = false</strong></p><blockquote><p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p></blockquote><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong> 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p><h3 id="_12-kafka-如何保证消息不重复消费" tabindex="-1"><a class="header-anchor" href="#_12-kafka-如何保证消息不重复消费" aria-hidden="true">#</a> 12.Kafka 如何保证消息不重复消费？</h3><p><strong>kafka出现消息重复消费的原因：</strong></p><ul><li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li><li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li></ul><p><strong>解决方案：</strong></p><ul><li><p>消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</p></li><li><p>将<code>enable.auto.commit</code>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：</p><p>什么时候提交offset合适？</p><ul><li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li><li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li></ul></li></ul><h3 id="_13-rabbitmq-核心概念" tabindex="-1"><a class="header-anchor" href="#_13-rabbitmq-核心概念" aria-hidden="true">#</a> 13.RabbitMQ 核心概念？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/MuuUQ9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>1.Producer(生产者) 和 Consumer(消费者)</strong></p><ul><li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li><li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li></ul><p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p><p><strong>2.Exchange(交换器)</strong></p><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。<strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p><p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p><p>Exchange(交换器) 示意图如下：</p><figure><img src="https://minio.pigx.top/oss/2022/07/AooJ58.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>生产者将消息发给交换器的时候，一般会指定一个 <strong>RoutingKey(路由键)</strong>，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p><p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p><p>Binding(绑定) 示意图：</p><figure><img src="https://minio.pigx.top/oss/2022/07/zdWcWt.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p><p><strong>3.Queue(消息队列)</strong></p><p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p><p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p><p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做</p><p><strong>4.Broker（消息中间件的服务节点）</strong></p><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p><p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p><figure><img src="https://minio.pigx.top/oss/2022/07/b1jcVs.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p><p><strong>5.Exchange Types(交换器类型)</strong></p><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p><p>① fanout</p><p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p><p>② direct</p><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p><figure><img src="https://minio.pigx.top/oss/2022/07/ShQDBY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为&quot;Info”或者&quot;debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p><p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p><p>③ topic</p><p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p><ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“<em>”和“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/R5kepq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以上图为例：</p><ul><li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;</li><li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li><li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li><li>路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；</li><li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li></ul><p>④ headers(不推荐)</p><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p><h3 id="_14-rocketmq事务消息流程" tabindex="-1"><a class="header-anchor" href="#_14-rocketmq事务消息流程" aria-hidden="true">#</a> 14.RocketMq事务消息流程</h3><figure><img src="https://minio.pigx.top/oss/2022/07/jGQUyJ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/bJDaPm.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_15-rabbitmq如何确保消息发送和消息接收" tabindex="-1"><a class="header-anchor" href="#_15-rabbitmq如何确保消息发送和消息接收" aria-hidden="true">#</a> 15.RabbitMQ如何确保消息发送和消息接收</h3><ul><li><strong>消息发送确认</strong></li></ul><p>​ 发送⽅确认机制：信道需要设置为 confirm 模式，则所有在信道上发布的消息都会分配⼀个唯⼀ ID。 ⼀旦消息被投递到queue（可持久化的消息需要写⼊磁盘），信道会发送⼀个确认给⽣产者（包含消息 唯⼀ ID）。</p><p>​ 1.ConfirmCallback方法</p><p>​ ConfirmCallback 是一个回调接口，消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，也就是只确认是否正确到达 Exchange 中。</p><p>​ 2.ReturnCallback方法</p><p>​ 通过实现 ReturnCallback 接口，启动消息失败返回，此接口是在交换器路由不到队列时触发回调，该方法可以不使用，因为交换器和队列是在代码里绑定的，如果消息成功投递到 Broker 后几乎不存在绑定队列失败，除非你代码写错了。</p><ul><li><strong>消息接收确认</strong></li></ul><p>​ RabbitMQ 消息确认机制（ACK）默认是自动确认的，自动确认会在消息发送给消费者后立即确认，但存在丢失消息的可能，如果消费端消费逻辑抛出异常，假如你用回滚了也只是保证了数据的一致性，但是消息还是丢了，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。</p><p>消息确认模式有：</p><p>AcknowledgeMode.NONE：自动确认。 AcknowledgeMode.AUTO：根据情况确认。 AcknowledgeMode.MANUAL：手动确认。 消费者收到消息后，手动调用 Basic.Ack 或 Basic.Nack 或 Basic.Reject 后，RabbitMQ 收到这些消息后，才认为本次投递完成。</p><p>Basic.Ack 命令：用于确认当前消息。 Basic.Nack 命令：用于否定当前消息（注意：这是AMQP 0-9-1的RabbitMQ扩展） 。 Basic.Reject 命令：用于拒绝当前消息。 Nack,Reject后都有能力要求是否requeue消息或者进入死信队列</p><h3 id="_16-rabbitmq死信队列、延时队列分别是什么" tabindex="-1"><a class="header-anchor" href="#_16-rabbitmq死信队列、延时队列分别是什么" aria-hidden="true">#</a> 16.RabbitMQ死信队列、延时队列分别是什么</h3><p>死信队列</p><p>DLX（Dead Letter Exchange），<strong>死信交换器</strong>。</p><p>当队列中的消息被拒绝、或者过期会变成死信，死信可以被重新发布到另一个交换器，这个交换器就是DLX，与DLX绑定的队列称为死信队列。 造成死信的原因：</p><ul><li>信息被拒绝</li><li>信息超时</li><li>超过了队列的最大长度</li></ul><p>过期消息：</p><pre><code>在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。

队列设置：在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒

单个消息设置：是设置消息属性的 expiration 参数的值，单位为 毫秒
</code></pre><p>延迟队列</p><p>延迟队列存储的是延迟消息</p><p>延迟消息指的是，当消息被发发布出去之后，并不立即投递给消费者，而是在指定时间之后投递。如：</p><p>在订单系统中，订单有30秒的付款时间，在订单超时之后在投递给消费者处理超时订单。</p><p>rabbitMq没有直接支持延迟队列，可以通过死信队列实现。</p><p>在死信队列中，可以为普通交换器绑定多个消息队列，假设绑定过期时间为5分钟，10分钟和30分钟，3个消息队列，然后为每个消息队列设置DLX，为每个DLX关联一个死信队列。</p><p>当消息过期之后，被转存到对应的死信队列中，然后投递给指定的消费者消费。</p><h3 id="_17-简述kafka架构设计是什么样" tabindex="-1"><a class="header-anchor" href="#_17-简述kafka架构设计是什么样" aria-hidden="true">#</a> 17.简述kafka架构设计是什么样？</h3><p>语义概念</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1 broker
Kafka 集群包含一个或多个服务器，服务器节点称为broker。

broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。

如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。

如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。

2 Topic
每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）

类似于数据库的表名

3 Partition
topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。

4 Producer
生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。

5 Consumer
消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。

6 Consumer Group
每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。

7 Leader
每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。

8 Follower
Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。

9 Offset
kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>KAFKA天生是分布式的，满足AKF的XYZ轴特点，扩展性，可靠性，高性能是没得说</p><p>而且，kafka具备自己的特色，比如动态ISR集合，是在强一致性，过半一致性之外的另一个实现手段</p><h3 id="_18-kafka消息丢失的场景有哪些" tabindex="-1"><a class="header-anchor" href="#_18-kafka消息丢失的场景有哪些" aria-hidden="true">#</a> 18.Kafka消息丢失的场景有哪些</h3><p>生产者在生产过程中的消息丢失</p><p>broker在故障后的消息丢失</p><p>消费者在消费过程中的消息丢失</p><h3 id="_19-kafka的ack机制" tabindex="-1"><a class="header-anchor" href="#_19-kafka的ack机制" aria-hidden="true">#</a> 19.kafka的ACK机制</h3><p>ack有3个可选值，分别是1，0，-1。</p><p><strong>ack=0：生产者在生产过程中的消息丢失</strong></p><p>简单来说就是，producer发送一次就不再发送了，不管是否发送成功。</p><p><strong>ack=1：broker在故障后的消息丢失</strong></p><p>简单来说就是，producer只要收到一个分区副本成功写入的通知就认为推送消息成功了。这里有一个地方需要注意，这个副本必须是leader副本。只有leader副本成功写入了，producer才会认为消息发送成功。</p><p>注意，ack的默认值就是1。这个默认值其实就是吞吐量与可靠性的一个折中方案。生产上我们可以根据实际情况进行调整，比如如果你要追求高吞吐量，那么就要放弃可靠性。</p><p><strong>ack=-1：生产侧和存储侧不会丢失数据</strong></p><p>简单来说就是，producer只有收到分区内所有副本的成功写入的通知才认为推送消息成功了。</p><h3 id="_20-offset机制" tabindex="-1"><a class="header-anchor" href="#_20-offset机制" aria-hidden="true">#</a> 20.Offset机制</h3><p>kafka消费者的三种消费语义</p><p>at-most-once：最多一次，可能丢数据</p><p>at-least-once：最少一次，可能重复消费数据</p><p>exact-once message：精确一次</p><h3 id="_21-kafka是pull-push-以及优劣势分析" tabindex="-1"><a class="header-anchor" href="#_21-kafka是pull-push-以及优劣势分析" aria-hidden="true">#</a> 21.Kafka是pull？push？以及优劣势分析</h3><p>Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。</p><p>Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。</p><p>一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。</p><p>这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。</p><p>消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。</p><p>最终Kafka还是选取了传统的pull模式。</p><p>Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。</p><p>Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。</p><p>如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。</p><p>Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。</p><p>Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到达。</p><p>为了避免这点，Kafka有个参数可以让consumer阻塞直到新消息到达(当然也可以阻塞直到消息的数量达到某个特定的量这样就可以批量发送)(长轮询)</p><h3 id="_22-kafka的rebalance机制是什么" tabindex="-1"><a class="header-anchor" href="#_22-kafka的rebalance机制是什么" aria-hidden="true">#</a> 22.kafka的rebalance机制是什么</h3><p><strong>消费者分区分配策略</strong></p><p>Range 范围分区(默认的)</p><p>RoundRobin 轮询分区</p><p>Sticky策略</p><p><strong>触发 Rebalance 的时机</strong></p><p>Rebalance 的触发条件有3个。</p><ul><li>组成员个数发生变化。例如有新的 consumer 实例加入该消费组或者离开组。</li><li>订阅的 Topic 个数发生变化。</li><li>订阅 Topic 的分区数发生变化。</li></ul><p><strong>Coordinator(协调者)协调过程</strong></p><p>Rebalance的过程如下：</p><p>第一步：所有成员都向coordinator发送请求，请求入组。一旦所有成员都发送了请求，coordinator会从中选择一个consumer担任leader的角色，并把组成员信息以及订阅信息发给leader。</p><p>第二步：leader开始分配消费方案，指明具体哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案发给coordinator。coordinator接收到分配方案之后会把方案发给各个consumer，这样组内的所有成员就都知道自己应该消费哪些分区了。</p><p>所以对于Rebalance来说，Coordinator起着至关重要的作用</p><h3 id="_23-kafka的消费者如何消费数据" tabindex="-1"><a class="header-anchor" href="#_23-kafka的消费者如何消费数据" aria-hidden="true">#</a> 23.Kafka的消费者如何消费数据</h3><p>消费者每次消费数据的时候，消费者都会记录消费的物理偏移量（ offset）的位置等到下次消费时，他 会接着上次位置继续消费</p><h3 id="_24-rocketmq的实现原理" tabindex="-1"><a class="header-anchor" href="#_24-rocketmq的实现原理" aria-hidden="true">#</a> 24.RocketMQ的实现原理</h3><p>RocketMQ由NameServer注册中⼼集群、Producer⽣产者集群、Consumer消费者集群和若⼲ Broker（RocketMQ进程）组成，它的架构原理是这样的：</p><ol><li>Broker在启动的时候去向所有的NameServer注册，并保持⻓连接，每30s发送⼀次⼼跳</li><li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择⼀台服务器来发送消息</li><li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li></ol><h3 id="_25-rocketmq为什么速度快" tabindex="-1"><a class="header-anchor" href="#_25-rocketmq为什么速度快" aria-hidden="true">#</a> 25.RocketMQ为什么速度快</h3><p>因为使⽤了顺序存储、Page Cache和异步刷盘。我们在写⼊commitlog的时候是顺序写⼊的，这样⽐ 随机写⼊的性能就会提⾼很多，写⼊commitlog的时候并不是直接写⼊磁盘，⽽是先写⼊操作系统的 PageCache，最后由操作系统异步将缓存中的数据刷到磁盘。</p><h3 id="_26-消息队列如何保证消息可靠传输" tabindex="-1"><a class="header-anchor" href="#_26-消息队列如何保证消息可靠传输" aria-hidden="true">#</a> 26.消息队列如何保证消息可靠传输</h3><p>​ 消息可靠传输代表了两层意思，既不能多也不能少。</p><ol><li>为了保证消息不多，也就是消息不能重复，也就是⽣产者不能重复⽣产消息，或者消费者不能重复消费消息</li><li>⾸先要确保消息不多发，这个不常出现，也⽐较难控制，因为如果出现了多发，很⼤的原因是⽣产者⾃⼰的原因，如果要避免出现问题，就需要在消费端做控制</li><li>要避免不重复消费，最保险的机制就是<strong>消费者实现幂等性</strong>，保证就算重复消费，也不会有问题，通过幂等性，也能解决⽣产者重复发送消息的问题</li><li>消息不能少，意思就是消息不能丢失，⽣产者发送的消息，消费者⼀定要能消费到，对于这个问题，就要考虑两个⽅⾯</li><li>⽣产者发送消息时，要确认broker确实收到并持久化了这条消息，⽐如RabbitMQ的confirm机制，Kafka的ack机制都可以保证⽣产者能正确的将消息发送给broker</li><li>broker要等待消费者真正确认消费到了消息时才删除掉消息，这⾥通常就是消费端ack机制，消费 者接收到⼀条消息后，如果确认没问题了，就可以给broker发送⼀个ack，broker接收到ack后才会 删除消息。</li></ol><h3 id="_27-消息队列有哪些作用" tabindex="-1"><a class="header-anchor" href="#_27-消息队列有哪些作用" aria-hidden="true">#</a> 27.消息队列有哪些作⽤</h3><p>解耦：使⽤消息队列来作为两个系统之间的通讯⽅式，两个系统不需要相互依赖了 。</p><p>异步：系统A给消息队列发送完消息之后，就可以继续做其他事情了 。</p><p>流量削峰：如果使⽤消息队列的⽅式来调⽤某个系统，那么消息将在队列中排队，由消费者⾃⼰控 制消费速度。</p><h3 id="_28-如何保证消息的高效读写" tabindex="-1"><a class="header-anchor" href="#_28-如何保证消息的高效读写" aria-hidden="true">#</a> 28.如何保证消息的⾼效读写？</h3><p>零拷⻉： kafka和RocketMQ都是通过零拷⻉技术来优化⽂件读写。</p><p>传统⽂件复制⽅式： 需要对⽂件在内存中进⾏四次拷⻉。</p><p>零拷⻉： 有两种⽅式， mmap和transfile，Java当中对零拷⻉进⾏了封装， Mmap⽅式通过 MappedByteBuffer对象进⾏操作，⽽transfile通过FileChannel来进⾏操作。Mmap 适合⽐较⼩的⽂件，通常⽂件⼤⼩不要超过1.5G ~2G 之间。Transfile没有⽂件⼤⼩限制。RocketMQ当中使⽤Mmap⽅ 式来对他的⽂件进⾏读写。 在kafka当中，他的index⽇志⽂件也是通过mmap的⽅式来读写</p><h3 id="_29-如何确保消息不丢失" tabindex="-1"><a class="header-anchor" href="#_29-如何确保消息不丢失" aria-hidden="true">#</a> 29.<strong>如何确保消息不丢失</strong></h3><ul><li>rabbitmq：</li></ul><p>生产者： 开启confirm模式（异步非阻塞）</p><p>MQ：1. 开启queue持久化，2. 开启消息持久化，deliveryMode设置为2，</p><p>消费者：关闭rabbitmq的自动ack模式，手动调用ack</p><ul><li>kafka:</li></ul><p>消费者：关闭自动提交offset，在自己处理完毕之后手动提交offset，这样就不会丢失数据</p><p>MQ：</p><ol><li>给topic设置 <strong>replication.factor</strong>参数：这个值必须大于1，表示要求每个partition必须至少有2个副本。</li><li>在kafka服务端设置<strong>min.isync.replicas</strong>参数：这个值必须大于1，表示 要求一个leader至少感知到有至少一个follower在跟自己保持联系正常同步数据，这样才能保证leader挂了之后还有一个follower。</li><li>在生产者端设置<strong>acks=all</strong>：表示 要求每条每条数据，必须是写入所有replica副本之后，才能认为是写入成功了</li><li>在生产者端设置<strong>retries=MAX</strong>(很大的一个值，表示无限重试)：表示 这个是要求一旦写入事败，就无限重试</li></ol><p>生产者：如果按照上面设置了ack=all，则一定不会丢失数据，要求是，你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次</p><h3 id="_30-如何检测消息丢失" tabindex="-1"><a class="header-anchor" href="#_30-如何检测消息丢失" aria-hidden="true">#</a> 30.<strong>如何检测消息丢失</strong></h3><p>每条生产消息都应该配置一个全局唯一ID和消费状态，可以存放在mysql或redis中，作为跟踪检测的依据</p><h3 id="_31-mq怎么解决重复消费的问题" tabindex="-1"><a class="header-anchor" href="#_31-mq怎么解决重复消费的问题" aria-hidden="true">#</a> 31.MQ怎么解决重复消费的问题</h3><p>关键是解决消费的幂等性。每条生产消息都应该配置一个全局唯一ID和消费状态，存放在mysql或redis中。在消费端的业务代码中可以通过中间件或拦截器检查消息表中的状态是否已经被消费过。</p><h3 id="_32-mq消息积压怎么解决" tabindex="-1"><a class="header-anchor" href="#_32-mq消息积压怎么解决" aria-hidden="true">#</a> 32.MQ消息积压怎么解决</h3><p>优先解决线上问题，临时扩容消费端</p><p>通过日志排查，为何会积压消息</p><p>优化业务逻辑，或根据实际情况选择扩容</p><h3 id="_33-rocketmq如何保证顺序消费" tabindex="-1"><a class="header-anchor" href="#_33-rocketmq如何保证顺序消费" aria-hidden="true">#</a> 33.rocketMq如何保证顺序消费</h3><p>我们已经知道了 <strong><code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p><p><strong>为什么会出现乱序 - 负载均衡</strong></p><figure><img src="https://minio.pigx.top/oss/2022/08/33tIbS.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Broker中的每个Topic都有多个Queue，写入消息的时候会平均分配（<strong>负载均衡机制</strong>，默认轮询，也可以自定义）给不同的Queue，假如我们有一个消费者组ComsumerGroup，这个消费组中的每一台机器都会负责一部分Queue，那么就会导致顺序的乱序问题</p><p>如何解决?</p><ol><li><p><strong>保证Producer、Queue、Comsumer是一对一对一的关系</strong></p></li><li><p>缺点</p><p><strong>吞吐量降低</strong> 消息队列的吞吐量降低（绝对不容忍这样的情况发生）</p><p><strong>有阻塞的风险</strong> 如果Comsumer服务炸了，后面的消息就无法消费，被阻塞了</p></li><li><p><strong>把需要保持顺序消费的消息放到同一个Queue中，且让同一台机子处理</strong> 自定义负载均衡模式，把这一批顺序消息有共同的唯一ID，把唯一ID与队列的数量进行hash取余运算，保证这批消息进入到同一个队列</p></li></ol><p>存在的问题 还要考虑Comsumer消费失败的<strong>重试</strong>问题</p><h3 id="_34-rocketmq如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#_34-rocketmq如何保证消息不丢失" aria-hidden="true">#</a> 34.rocketMq如何保证消息不丢失</h3><figure><img src="https://minio.pigx.top/oss/2022/08/olZK1k.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从生产者producer的角度：消息生产之后传递到broker，如果消息未能正确的存储到broker中，算作消息丢失。</p><p>从broker的角度：消息默认保存到broker的内存中，异步保存到磁盘上，如果发生宕机、磁盘崩溃会造成消息丢失。</p><p>从消费者consumer的角度：消息完成了持久化之后，consumer拉取之后未能成功消费且未反馈给broker，这样算作消息丢失，可能消费过程异常或者网络抖动造成消息丢失。</p><ul><li><strong>生产者角度</strong></li></ul><p>从生产者的角度，生产了消息就是要通过网络发送到broker，其实只需要保证一点，就是确认这个消息已经成功发送到broker上了。</p><p>生产者只需要接收发送消息返回的确认响应即可，就可以代表消息发送成功。</p><p>当然，发送消息也分为同步和异步两种，消息发送成功之后会返回下面这四种不同的响应状态</p><p>SendResult定义说明(来自RocketMQ官方)</p><ol><li>SEND_OK 消息发送成功。要注意的是消息发送成功也不意味着它是可靠的。要确保不会丢失任何消息，还应启用同步Master服务器或同步刷盘，即SYNC_MASTER或SYNC_FLUSH。</li><li>FLUSH_DISK_TIMEOUT 消息发送成功但是服务器刷盘超时。此时消息已经进入服务器队列（内存），只有服务器宕机，消息才会丢失。消息存储配置参数中可以设置刷盘方式和同步刷盘时间长度，如果Broker服务器设置了刷盘方式为同步刷盘，即FlushDiskType=SYNC_FLUSH（默认为异步刷盘方式），当Broker服务器未在同步刷盘时间内（默认为5s）完成刷盘，则将返回该状态——刷盘超</li><li>FLUSH_SLAVE_TIMEOUT 消息发送成功，但是服务器同步到Slave时超时。此时消息已经进入服务器队列，只有服务器宕机，消息才会丢失。如果Broker服务器的角色是同步Master，即SYNC_MASTER（默认是异步Master即ASYNC_MASTER），并且从Broker服务器未在同步刷盘时间（默认为5秒）内完成与主服务器的同步，则将返回该状态——数据同步到Slave服务器超时。</li><li>SLAVE_NOT_AVAILABLE 消息发送成功，但是此时Slave不可用。如果Broker服务器的角色是同步Master，即SYNC_MASTER（默认是异步Master服务器即ASYNC_MASTER），但没有配置slave Broker服务器，则将返回该状态——无Slave服务器可用。</li></ol><ul><li><strong>从broker的角度</strong></li></ul><p>消息到了broker之后，默认是优先保存到broker的内存中，然后立刻返回响应给生产者producer，然后broker自己定期将消息批量的异步的保存到硬盘上。</p><p>这样的优点是提高交互的效率，同时减少IO的次数，问题就是会造成消息丢失</p><p>如果我们想要保证消息不丢失，那就需要保证消息成功保存到broker之后才可以返回，只需要将消息的保存机制修改为同步刷盘的方式，也就是只有消息保存到broker的磁盘成功之后，才会返回响应</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## 默认情况为 ASYNC_FLUSH 
flushDiskType = SYNC_FLUSH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果broker未能在规定的同步时间（默认5秒）完成刷盘，将返回FLUSH_DISK_TIMEOUT给生产者</p><p>上面也介绍了这个了FLUSH_DISK_TIMEOUT了</p><p>一般在系统中为了保证可用性，broker通常采用的都是一主master多从slave的部署方式，属于集群部署</p><p>为了保证消息不丢失，消息需要复制到slave节点，其实默认的情况下，消息写入到broker之后就会返回成功</p><p>但是！如果master突然宕机或者磁盘崩溃了，那么这个消息就彻底丢失了，没有备份，所以呢，这里还需要把master和slave的异步复制改成同步复制</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>## master 节点配置
flushDiskType = SYNC_FLUSH
brokerRole=SYNC_MASTER


## slave 节点配置
brokerRole=slave
flushDiskType = SYNC_FLUSH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是只有slave也刷盘到磁盘成功之后，才会给producer返回成功</p><ul><li>消费者角度</li></ul><p>消费者从broker拉取消息，然后进行相应的业务的消费，消费成功会返回一个消费成功的状态给broker，broker如果没收到确认信息，消费者下次拉取重新拉取该消息。</p><p>consumer自身可以维护一个持久化的offset，对应MessageQueue里面的min offset，标记已经成功消费或者已经成功发回到broker的消息下标。</p><p>如果consumer消费失败，会把这个消息发回给broker，发回成功后，更新自己的offset。</p><p>如果发回给broker时，broker挂掉了，那么consumer也会定时重试这个操作。</p><p>即使consumer和broker一起挂掉了，消息也不会丢失，因为consumer里面的offset会定时持久化，重启之后，继续拉取offset之前的消息到本地，重新消费。</p><h3 id="_35-partition的数据文件-offffset-messagesize-data" tabindex="-1"><a class="header-anchor" href="#_35-partition的数据文件-offffset-messagesize-data" aria-hidden="true">#</a> 35.partition的数据文件（offffset，MessageSize，data）</h3><p>partition中的每条Message包含了以下三个属性： offset，MessageSize，data，其中offset表示Message在这个partition中的偏移量，offset不是该Message在partition数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了partition中的一条Message，可以认为offset是partition中Message的 id； MessageSize表示消息内容data的大小；data为Message的具体内容。</p><h3 id="_36-kafka-中的isr-insyncrepli-、osr-outsyncrepli-、ar-allrepli-代表什么" tabindex="-1"><a class="header-anchor" href="#_36-kafka-中的isr-insyncrepli-、osr-outsyncrepli-、ar-allrepli-代表什么" aria-hidden="true">#</a> 36.Kafka 中的ISR(InSyncRepli)、OSR(OutSyncRepli)、AR(AllRepli)代表什么？</h3><p>答：kafka中与leader副本保持一定同步程度的副本（包括leader）组成ISR。与leader滞后太多的副本组成OSR。分区中所有的副本通称为AR。</p><p>ISR : 速率和leader相差低于10秒的follower的集合 OSR : 速率和leader相差大于10秒的follower AR : 全部分区的follower</p><h3 id="_37-kafka的那些设计让它有如此高的性能" tabindex="-1"><a class="header-anchor" href="#_37-kafka的那些设计让它有如此高的性能" aria-hidden="true">#</a> 37.Kafka的那些设计让它有如此高的性能?</h3><p>1.kafka是分布式的消息队列 2.对log文件进行了segment,并对segment创建了索引 3.(对于单节点)使用了顺序读写,速度能够达到600M/s 4.引用了zero拷贝,在os系统就完成了读写操做</p><p>5.使用拉模式进行消息的获取消费，与消费端处理能力相符。</p><h3 id="_38-rocketmq如何保证高可用" tabindex="-1"><a class="header-anchor" href="#_38-rocketmq如何保证高可用" aria-hidden="true">#</a> 38.rocketMq如何保证高可用</h3><p>1）master和slave 配合，master 支持读、写，slave 只读，producer 只能和 master 连接写入消息，consumer 可以连接 master 和 slave。</p><p>2）当 master 不可用或者繁忙时，consumer 会被自动切换到 slave 读。即使 master 出现故障，consumer 仍然可以从 slave 读消息，不受影响。</p><p>3）创建 topic 时，把 message queue 创建在多个 broker 组上（brokerName 一样，brokerId 不同），当一个 broker 组的 master 不可用后，其他组的 master 仍然可以用，producer 可以继续发消息。</p><h3 id="_39-rocketmq消费者消费模式有几种" tabindex="-1"><a class="header-anchor" href="#_39-rocketmq消费者消费模式有几种" aria-hidden="true">#</a> 39.RocketMq消费者消费模式有几种</h3><ol><li>集群消费</li></ol><p>​ 一条消息只会投递到一个 Consumer Group 下面的一个实例。</p><ol start="2"><li>广播消费</li></ol><p>​ 消息将对一个Consumer Group 下的各个 Consumer 实例都投递一遍。即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p><h3 id="_40-rocketmq延迟消息-如何实现的" tabindex="-1"><a class="header-anchor" href="#_40-rocketmq延迟消息-如何实现的" aria-hidden="true">#</a> 40.RocketMq延迟消息？如何实现的</h3><p>RocketMQ 支持定时消息，但是不支持任意时间精度，仅支持特定的 level，例如定时 5s， 10s， 1m 等。其中，level=0 级表示不延时，level=1 表示 1 级延时，level=2 表示 2 级延时。默认的配置是messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h。</p><h3 id="_41-rocketmq是推模型还是拉模型" tabindex="-1"><a class="header-anchor" href="#_41-rocketmq是推模型还是拉模型" aria-hidden="true">#</a> 41.RocketMq是推模型还是拉模型</h3><p>rocketmq不管是推模式还是拉模式底层都是拉模式，推模式也是在拉模式上做了一层封装.。</p><p>消息存储在broker中，通过topic和tags区分消息队列。producer在发送消息时不关心consumer对应的topic和tags，只将消息发送到对应broker的对应topic和tags中。</p><p>推模式中broker则需要知道哪些consumer拥有哪些topic和tags，但在consumer重启或更换topic时，broker无法及时获取信息，可能将消息推送到旧的consumer中。对应consumer主动获取topic，这样确保每次主动获取时他对应的topic信息都是最新的。</p><h3 id="_42-kafka-的零拷贝原理" tabindex="-1"><a class="header-anchor" href="#_42-kafka-的零拷贝原理" aria-hidden="true">#</a> 42.kafka 的零拷贝原理?</h3><p>在实际应用中，如果我们需要把磁盘中的某个文件内容发送到远程服务器上，如 图 那么它必须要经过几个拷贝的过程，如图。 从磁盘中读取目标文件内容拷贝到内核缓冲区 CPU 控制器再把内核缓冲区的数据赋值到用户空间的缓冲区中</p><p>接着在应用程序中，调用 write() 方法，把用户空间缓冲区中的数据拷贝到内核下 的 Socket Buffer 中。 最后，把在内核模式下的 SocketBuffer 中的数据赋值到网卡缓冲区（NIC Buffer) 网卡缓冲区再把数据传输到目标服务器上。</p><figure><img src="https://minio.pigx.top/oss/2022/08/VvmL33.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在这个过程中我们可以发现，数据从磁盘到最终发送出去，要经历 4 次拷贝，而 在这四次拷贝过程中，有两次拷贝是浪费的，分别是： 从内核空间赋值到用户空间 从用户空间再次复制到内核空间</p><p>除此之外，由于用户空间和内核空间的切换会带来CPU的上线文切换，对于CPU 性能也会造成性能影响。</p><p>而零拷贝，就是把这两次多于的拷贝省略掉，应用程序可以直接把磁盘中的数据 从内核中直接传输给 Socket，而不需要再经过应用程序所在的用户空间，如下 图所示。</p><p>零拷贝通过 DMA（Direct Memory Access）技术把文件内容复制到内核空间中 的 Read Buffer，</p><p>接着把包含数据位置和长度信息的文件描述符加载到 Socket Buffer 中，DMA 引 擎直接可以把数据从内核空间中传递给网卡设备。</p><p>在这个流程中，数据只经历了两次拷贝就发送到了网卡中，并且减少了 2 次 cpu 的上下文切换，对于效率有非常大的提高。</p><figure><img src="https://minio.pigx.top/oss/2022/08/iZfWOl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以，所谓零拷贝，并不是完全没有数据赋值，只是相对于用户空间来说，不再 需要进行数据拷贝。对于前面说的整个流程来说，零拷贝只是减少了不必要的拷 贝次数而已。</p><p>在程序中如何实现零拷贝呢？</p><p>在 Linux 中，零拷贝技术依赖于底层的 sendfile()方法实现 在 Java 中， FileChannal.transferTo()方法的底层实现就是 sendfile()方法。</p><p>除此之外，还有一个 mmap 的文件映射机制 它的原理是：将磁盘文件映射到内存,用户通过修改内存就能修改磁盘文件。使 用这种方式可以获取很大的 I/O 提升，省去了用户空间到内核空间复制的开销。</p><h1 id="网络编程" tabindex="-1"><a class="header-anchor" href="#网络编程" aria-hidden="true">#</a> 网络编程</h1><h3 id="_1-为什需要websocket" tabindex="-1"><a class="header-anchor" href="#_1-为什需要websocket" aria-hidden="true">#</a> 1. 为什需要websocket</h3><p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p><p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><h3 id="_2-什么是websocket" tabindex="-1"><a class="header-anchor" href="#_2-什么是websocket" aria-hidden="true">#</a> 2.什么是websocket</h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><figure><img src="https://cdn.staticaly.com/gh/fxzbiz/img@url/2022/12/14/o0CAiT.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><blockquote><div class="language-markup line-numbers-mode" data-ext="markup"><pre class="language-markup"><code>ws://example.com:80/some/path
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><figure><img src="https://cdn.staticaly.com/gh/fxzbiz/img@url/2022/12/14/MAaRyZ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-websocket如何从http协议转化为websocket协议" tabindex="-1"><a class="header-anchor" href="#_3-websocket如何从http协议转化为websocket协议" aria-hidden="true">#</a> 3.WebSocket如何从HTTP协议转化为WebSocket协议？</h3><p>WebSocket依赖于HTTP连接，那么它如何从连接的HTTP协议转化为WebSocket协议？</p><p>每个WebSocket连接都始于一个HTTP请求。 具体来说，WebSocket协议在第一次握手连接时，通过HTTP协议在传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Version: 13
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，关键的地方是，这里面有个Upgrade首部，用来把当前的HTTP请求升级到WebSocket协议，这是HTTP协议本身的内容，是为了扩展支持其他的通讯协议。 如果服务器支持新的协议，则必须返回101：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，HTTP请求物尽其用，如果成功出发onopen事件，否则触发onerror事件，<strong>后面的传输则不再依赖HTTP协议</strong>，仅仅是借助 HTTP 协议完成握手。</p><h3 id="_4-websocket为什么依赖于http连接" tabindex="-1"><a class="header-anchor" href="#_4-websocket为什么依赖于http连接" aria-hidden="true">#</a> 4.WebSocket为什么依赖于HTTP连接</h3><p>第一，WebSocket设计上就是天生为HTTP增强通信（全双工通信等），所以在HTTP协议连接的基础上是很自然的一件事，并因此而能获得HTTP的诸多便利。</p><p>第二，这诸多便利中有一条很重要，基于HTTP连接将获得最大的一个兼容支持，比如即使服务器不支持WebSocket也能建立HTTP通信，只不过返回的是onerror而已，这显然比服务器无响应要好的多。</p><h3 id="_5-如何保证消息一定送达给用户" tabindex="-1"><a class="header-anchor" href="#_5-如何保证消息一定送达给用户" aria-hidden="true">#</a> 5.如何保证消息一定送达给用户</h3><p>我们在一起考虑下边界场景，客户端网络环境较差，特别是在移动端场景下，出现网络<strong>闪断</strong>，可能会出现连接实际已经断开，而服务端以为客户端处于在线的情况。此时，服务端会将消息发给客户端，那么消息实际就发送到“空气”中，产生丢失的情况。要解决这种情况下的问题，需要引入客户端的 ACK 消息机制。目前，主流的有两种做法。</p><p>第一种，基于每一条消息编号 ACK 。整体流程如下：</p><ul><li>无论客户端是否在线，服务端都先把接收到的消息持久化到数据库中。如果客户端此时在线，服务端将<strong>完整消息</strong>推送给客户端。</li><li>客户端在接收到消息之后，发送 ACK 消息编号给服务端，告知已经收到该消息。服务端在收到 ACK 消息编号的时候，标记该消息已经发送成功。</li><li>服务端定时轮询，在线的客户端，是否有超过 N 秒未 ACK 的消息。如果有，则重新发送消息给对应的客户端。</li></ul><p>这种方案，因为客户端逐条 ACK 消息编号，所以会导致客户端和服务端交互次数过多。当然，客户端可以异步批量 ACK 多条消息，从而减少次数。</p><p>不过因为服务端仍然需要定时轮询，也会导致服务端压力较大。所以，这种方案基本已经不采用了。</p><p>第二种，基于滑动窗口 ACK 。整体流程如下：</p><ul><li>无论客户端是否在线，服务端都先把接收到的消息持久化到数据库中。如果客户端此时在线，服务端将<strong>消息编号</strong>推送给客户端。</li><li>客户端在接收到<strong>消息编号</strong>之后，和本地的消息编号进行比对。如果比本地的小，说明该消息已经收到，忽略不处理；如果比本地的大，使用<strong>本地的</strong>消息编号，向服务端拉取<strong>大于</strong>本地的消息编号的消息列表，即增量消息列表。拉取完成后，更新消息列表中最大的消息编号为<strong>新的本地的</strong>消息编号。</li><li>服务端在收到客户端拉取增量的消息列表时，将请求的编号记录到数据库中，用于知道客户端此时本地的最新消息编号。</li><li>考虑到服务端将<strong>消息编号</strong>推送给客户端，也会存在丢失的情况，所以客户端会每 N 秒定时向服务端拉取<strong>大于</strong>本地的消息编号的消息列表。</li></ul><p>这种方式，在业务被称为<strong>推拉结合</strong>的方案，在分布式消息队列、配置中心、注册中心实现实时的数据同步，经常被采用。</p><p>并且，采用这种方案的情况下，客户端和服务端不一定需要使用<strong>长连接</strong>，也可以使用<strong>长轮询</strong>所替代。客户端发送带有消息版本号的 HTTP 请求到服务端。</p><ul><li>如果服务端<strong>已有</strong>比客户端新的消息编号，则直接返回增量的消息列表。</li><li>如果服务端<strong>没有</strong>比客户端新的消息编号，则 HOLD 住请求，直到有新的消息列表可以返回，或者 HTTP 请求超时。</li><li>客户端在收到 HTTP 请求超时时，立即又重新发起带有消息版本号的 HTTP 请求到服务端。如此反复循环，通过消息编号作为<strong>增量标识</strong>，达到实时获取消息的目的。</li></ul><h3 id="_6-bio-是什么" tabindex="-1"><a class="header-anchor" href="#_6-bio-是什么" aria-hidden="true">#</a> 6.BIO 是什么？</h3><p>🦅 <strong>概念</strong></p><ul><li>BIO ，全称 Block-IO ，是一种<strong>阻塞</strong> + <strong>同步</strong>的通信模式。</li><li>是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。</li></ul><p>🦅 <strong>原理</strong></p><ul><li>服务器通过一个 Acceptor 线程，负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的<strong>一请求一应答模式</strong>。</li><li>若客户端数量增多，频繁地创建和销毁线程会给服务器打开很大的压力。后改良为用线程池的方式代替新增线程，被称为伪异步 IO 。</li></ul><p>🦅 <strong>小结</strong></p><p>BIO 模型中，通过 Socket 和 ServerSocket 实现套接字通道的通信。阻塞，同步，建立连接耗时。</p><h3 id="_7-nio-是什么" tabindex="-1"><a class="header-anchor" href="#_7-nio-是什么" aria-hidden="true">#</a> 7.NIO 是什么？</h3><p>🦅 <strong>概念</strong></p><ul><li>NIO ，全称 New IO ，也叫 Non-Block IO ，是一种<strong>非阻塞</strong> + 同步的通信模式。</li></ul><p>🦅 <strong>原理</strong></p><ul><li>NIO 相对于 BIO 来说一大进步。客户端和服务器之间通过 Channel 通信。NIO 可以在 Channel 进行读写操作。这些 Channel 都会被注册在 Selector 多路复用器上。Selector 通过一个线程不停的轮询这些 Channel 。找出已经准备就绪的 Channel 执行 IO 操作。</li><li>NIO 通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞 NIO 的特点。 <ul><li>缓冲区 Buffer ：它是 NIO 与 BIO 的一个重要区别。 <ul><li>BIO 是将数据直接写入或读取到流 Stream 对象中。</li><li>NIO 的数据操作都是在 Buffer 中进行的。Buffer 实际上是一个数组。Buffer 最常见的类型是ByteBuffer，另外还有 CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。</li></ul></li><li>通道 Channel ：和流 Stream 不同，通道是双向的。NIO可以通过 Channel 进行数据的读、写和同时读写操作。 <ul><li>通道分为两大类：一类是网络读写（SelectableChannel），一类是用于文件操作（FileChannel）。我们使用的是前者 SocketChannel 和 ServerSocketChannel ，都是SelectableChannel 的子类。</li></ul></li><li>多路复用器 Selector ：NIO 编程的基础。多路复用器提供选择已经就绪的任务的能力：就是 Selector 会不断地轮询注册在其上的通道（Channel），如果某个通道处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以取得就绪的Channel集合，从而进行后续的 IO 操作。 <ul><li>服务器端只要提供一个线程负责 Selector 的轮询，就可以接入成千上万个客户端，这就是 JDK NIO 库的巨大进步。</li></ul></li></ul></li></ul><p>🦅 <strong>小结</strong></p><p>NIO 模型中通过 SocketChannel 和 ServerSocketChannel 实现套接字通道的通信。非阻塞，同步，避免为每个 TCP 连接创建一个线程。</p><h3 id="_8-bio、nio-有什么区别" tabindex="-1"><a class="header-anchor" href="#_8-bio、nio-有什么区别" aria-hidden="true">#</a> 8.BIO、NIO 有什么区别？</h3><ul><li>线程模型不同 <ul><li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。所以，线程开销大。可改良为用线程池的方式代替新创建线程，被称为伪异步 IO 。</li><li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有新的 I/O 请求时，才启动一个线程进行处理。可改良为一个线程处理多个请求，基于 <a href="http://svip.iocoder.cn/Netty/EventLoop-1-Reactor-Model/" target="_blank" rel="noopener noreferrer">多 Reactor 模型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</li></ul></li><li>BIO 是面向流( Stream )的，而 NIO 是面向缓冲区( Buffer )的。</li><li>BIO 的各种操作是阻塞的，而 NIO 的各种操作是非阻塞的。</li><li>BIO 的 Socket 是单向的，而 NIO 的 Channel 是双向的</li></ul><figure><img src="https://cdn.staticaly.com/gh/fxzbiz/img@url/2022/12/14/oduKXO.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.staticaly.com/gh/fxzbiz/img@url/2022/12/14/0ovTZe.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_9-aio-是什么" tabindex="-1"><a class="header-anchor" href="#_9-aio-是什么" aria-hidden="true">#</a> 9.AIO 是什么？</h3><p>🦅 <strong>概念</strong></p><ul><li>AIO ，全称 Asynchronous IO ，也叫 NIO<strong>2</strong> ，是一种<strong>非阻塞</strong> + <strong>异步</strong>的通信模式。在 NIO 的基础上，引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。</li><li>原理：</li><li>AIO 并没有采用 NIO 的多路复用器，而是使用异步通道的概念。其 read，write 方法的返回类型，都是 Future 对象。而 Future 模型是异步的，其核心思想是：<strong>去主函数等待时间</strong>。</li></ul><h3 id="_10-direct-buffer-和-non-direct-buffer-的区别" tabindex="-1"><a class="header-anchor" href="#_10-direct-buffer-和-non-direct-buffer-的区别" aria-hidden="true">#</a> 10.Direct Buffer 和 Non-Direct Buffer 的区别</h3><p><strong>Direct Buffer:</strong></p><ul><li>所分配的内存不在 JVM 堆上, 不受 GC 的管理.(但是 Direct Buffer 的 Java 对象是由 GC 管理的, 因此当发生 GC, 对象被回收时, Direct Buffer 也会被释放)</li><li>因为 Direct Buffer 不在 JVM 堆上分配, 因此 Direct Buffer 对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存, 但是 JVM 不好统计到非 JVM 管理的内存.)</li><li>申请和释放 Direct Buffer 的开销比较大. 因此正确的使用 Direct Buffer 的方式是在初始化时申请一个 Buffer, 然后不断复用此 buffer, 在程序结束后才释放此 buffer.</li><li>使用 Direct Buffer 时, 当进行一些底层的系统 IO 操作时, 效率会比较高, 因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中.</li></ul><p><strong>Non-Direct Buffer:</strong></p><ul><li>直接在 JVM 堆上进行内存的分配, 本质上是 byte[] 数组的封装.</li><li>因为 Non-Direct Buffer 在 JVM 堆中, 因此当进行操作系统底层 IO 操作中时, 会将此 buffer 的内存复制到中间临时缓冲区中. 因此 Non-Direct Buffer 的效率就较低.</li></ul><h1 id="elasticsearch" tabindex="-1"><a class="header-anchor" href="#elasticsearch" aria-hidden="true">#</a> Elasticsearch</h1><h3 id="_1-elasticsearch-的倒排索引是什么" tabindex="-1"><a class="header-anchor" href="#_1-elasticsearch-的倒排索引是什么" aria-hidden="true">#</a> 1.elasticsearch 的倒排索引是什么</h3><p>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。 而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。有了 倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了检索效率。</p><figure><img src="https://minio.pigx.top/oss/2022/08/lHauLz.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>学术的解答方式： 倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表。</p><p>加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构。</p><p>lucene 从 4+版本后开始大量使用的数据结构是 FST。</p><p>FST 有两个优点：</p><p>（1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</p><p>（2）查询速度快。O(len(str))的查询时间复杂度。</p><h3 id="_2-elasticsearch-的-master-选举流程" tabindex="-1"><a class="header-anchor" href="#_2-elasticsearch-的-master-选举流程" aria-hidden="true">#</a> 2.Elasticsearch 的 master 选举流程？</h3><ol><li><p>Elasticsearch 的选举是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个 RPC 来发现彼此） 和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分</p></li><li><p>对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排序，每次选举每个节点都把自 己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</p></li><li><p>如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n/2+1）并且该节点自己也选举自己， 那这个节点就是 master。否则重新选举一直到满足上述条件。</p></li><li><p>master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data 节点可以关闭 http 功能。</p></li></ol><h3 id="_3-为什么要使用-elasticsearch" tabindex="-1"><a class="header-anchor" href="#_3-为什么要使用-elasticsearch" aria-hidden="true">#</a> 3.为什么要使用 Elasticsearch?</h3><p>系统中的数据，随着业务的发展，时间的推移，将会非常多，而业务中往往采用模糊查询进行数据的 搜索，而模糊查询会<strong>导致查询引擎放弃索引，导致系统查询数据时都是全表扫描</strong>，在百万级别的数据库中， 查询效率是非常低下的，而我们使用 ES 做一个全文索引，将经常查询的系统功能的某些字段，比如说电 商系统的商品表中商品名，描述、价格还有 id 这些字段我们放入 ES 索引库里，可以提高查询速度。</p><h3 id="_4-elasticsearch-集群脑裂问题" tabindex="-1"><a class="header-anchor" href="#_4-elasticsearch-集群脑裂问题" aria-hidden="true">#</a> 4.Elasticsearch 集群脑裂问题？</h3><p><strong>“脑裂”问题可能的成因:</strong></p><ol><li><p>网络问题 ：集群间的网络延迟导致一些节点访问不到 master ，认为 master 挂掉了从而选举出新的master，并对 master 上的分片和副本标红，分配新的主分片</p></li><li><p>节点负载：主节点的角色既为 master 又为 data，访问量较大时可能会导致 ES 停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</p></li><li><p>内存回收：data 节点上的 ES 进程占用的内存较大，引发 JVM 的大规模内存回收，造成 ES 进程失去响应。</p></li></ol><p><strong>脑裂问题解决方案：</strong></p><ol><li><p>减少误判：discovery.zen.ping_timeout 节点状态的响应时间，默认为 3s，可以适当调大，如果 master在该响应时间的范围内没有做出响应应答， 判断该节点已经挂掉了。 调大参数（如 6s ，discovery.zen.ping_timeout:6），可适当减少误判。</p></li><li><p>选举触发: discovery.zen.minimum_master_nodes:1</p></li></ol><p>​ 该参数是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个数大于等于该参数的值， 且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为（n/2）+1，n 为主节点个数 （即有资格成为主节点的节点个数）</p><ol start="3"><li>角色分离：即 master 节点与 data 节点分离，限制角色</li></ol><p>​ 主节点配置为：node.master: true node.data: false</p><p>​ 从节点配置为：node.master: false node.data: true</p><h3 id="_5-elasticsearch-索引文档的流程" tabindex="-1"><a class="header-anchor" href="#_5-elasticsearch-索引文档的流程" aria-hidden="true">#</a> 5.Elasticsearch 索引文档的流程？</h3><p>这里的索引文档应该理解为文档写入 ES，创建索引的过程。 文档写入包含：单文档写入和批量 bulk 写入。</p><figure><img src="https://minio.pigx.top/oss/2022/08/P9EQnq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片： shard = hash(document_id) % (num_of_primary_shards)</p></li><li><p>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认 是每隔 1 秒）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 refresh；</p></li><li><p>当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</p></li><li><p>在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点， 并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</p></li><li><p>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</p></li><li><p>分片所在的节点 在主分片上执行写操作，如果成功，则将请求并行转发到其他节点的副本分片 上，等待结果返回。所有的副本分片都报告成功，节点将向协调节点报告成功，协调节点向请求客户端报告写入成功。</p></li></ol><h3 id="_6-elasticsearch-更新和删除文档的流程" tabindex="-1"><a class="header-anchor" href="#_6-elasticsearch-更新和删除文档的流程" aria-hidden="true">#</a> 6.Elasticsearch 更新和删除文档的流程？</h3><ol><li><p>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</p></li><li><p>磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在 .del 文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</p></li><li><p>在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结 果中被过滤掉。</p></li></ol><h3 id="_7-elasticsearch-搜索的流程" tabindex="-1"><a class="header-anchor" href="#_7-elasticsearch-搜索的流程" aria-hidden="true">#</a> 7.Elasticsearch 搜索的流程？</h3><figure><img src="https://minio.pigx.top/oss/2022/08/7lz47k.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</p></li><li><p>在初始查询阶段时，查询会广播到索引中<strong>每一个分片拷贝（主分片或者副本分片）</strong>。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。 PS ：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。</p></li><li><p>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队 列中来产生一个全局排序后的结果列表。 接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每 个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了， 协调节点返回结果给客户端。</p></li><li><p>Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少 的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</p></li></ol><h3 id="_8-在并发情况下-elasticsearch-如果保证读写一致" tabindex="-1"><a class="header-anchor" href="#_8-在并发情况下-elasticsearch-如果保证读写一致" aria-hidden="true">#</a> 8.在并发情况下，Elasticsearch 如果保证读写一致？</h3><ol><li><p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p></li><li><p>另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故 障，分片将会在一个不同的节点上重建。</p></li><li><p>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回； 如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片， 确保文档是最新版本。</p></li></ol><h3 id="_9-elasticsearch-中的集群、节点、索引、文档、类型是什么" tabindex="-1"><a class="header-anchor" href="#_9-elasticsearch-中的集群、节点、索引、文档、类型是什么" aria-hidden="true">#</a> 9.Elasticsearch 中的集群、节点、索引、文档、类型是什么？</h3><ol><li><p>集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。集群由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置为按名称加入集群，则该节点只能是集群的一部分。</p></li><li><p>节点是属于集群一部分的单个服务器。它存储数据并参与集群索引和搜索功能。</p></li><li><p>索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一 个或多个主分片，并且可以有零个或多个副本分片。 MySQL =&gt;数据库 Elasticsearch =&gt;索引</p></li><li><p>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构（字段），但 是对于通用字段应该具有相同的数据类型。 MySQL =&gt; Databases =&gt; Tables =&gt; Columns / Rows Elasticsearch =&gt; Indices =&gt; Types =&gt;具有属性的文档</p></li><li><p>类型是索引的逻辑类别/分区，其语义完全取决于用户。</p></li></ol><h3 id="_10-说说分段存储的思想" tabindex="-1"><a class="header-anchor" href="#_10-说说分段存储的思想" aria-hidden="true">#</a> 10.说说分段存储的思想</h3><p>Lucene 是著名的搜索开源软件，ElasticSearch 和 Solr 底层用的都是它。</p><p>分段存储是 Lucene 的思想。 早期，都是一个整个文档建立一个大的倒排索引。简单，快速，但是问题随之而来。 文档有个很小的改动，整个索引需要重新建立，速度慢，成本高，为了提高速度，定期更新那么时 效性就差。 现在一个索引文件，拆分为多个子文件，每个子文件是段。修改的数据不影响的段不必做处理。</p><h3 id="_11-谈谈你对段合并的策略思想的认识" tabindex="-1"><a class="header-anchor" href="#_11-谈谈你对段合并的策略思想的认识" aria-hidden="true">#</a> 11.谈谈你对段合并的策略思想的认识</h3><p>分段的思想大大的提高了维护索引的效率。但是随之就有了新的问题。 每次新增数据就会新增加一个段，时间久了，一个文档对应的段非常多。段多了，也就影响检索性 能了。 检索过程：</p><ol><li><p>查询所有短中满足条件的数据</p></li><li><p>对每个段的结果集合并</p></li></ol><p>所以，定期的对段进行合理是很必要的。真是天下大势，分久必合合久必分。 策略：将段按大小排列分组，大到一定程度的不参与合并。小的组内合并。整体维持在一个合理的 大小范围。当然这个大到底应该是多少，是用户可配置的。这也符合设计的思想。</p><h3 id="_12-熟悉elasticsearch-性能优化" tabindex="-1"><a class="header-anchor" href="#_12-熟悉elasticsearch-性能优化" aria-hidden="true">#</a> 12.熟悉ElasticSearch 性能优化？</h3><ol><li><strong>批量提交</strong></li></ol><p>背景是大量的写操作，每次提交都是一次网络开销。网络永久是优化要考虑的重点。</p><ol start="2"><li><strong>优化硬盘</strong></li></ol><p>索引文件需要落地硬盘，段的思想又带来了更多的小文件，磁盘 IO 是 ES 的性能瓶颈。一个固态硬 盘比普通硬盘好太多。</p><ol start="3"><li><strong>减少副本数量</strong></li></ol><p>副本可以保证集群的可用性，但是严重影响了 写索引的效率。写索引时不只完成写入索引，还要完 成索引到副本的同步。ES 不是存储引擎，不要考虑数据丢失，性能更重要。 如果是批量导入，建 议就关闭副本。</p><h3 id="_13-node一般设置几个分片" tabindex="-1"><a class="header-anchor" href="#_13-node一般设置几个分片" aria-hidden="true">#</a> 13.node一般设置几个分片？</h3><p>我们遵循官方建议，一般node不多于3个分片。</p><h1 id="mongodb" tabindex="-1"><a class="header-anchor" href="#mongodb" aria-hidden="true">#</a> MongoDB</h1><h3 id="_1-什么是mongodb" tabindex="-1"><a class="header-anchor" href="#_1-什么是mongodb" aria-hidden="true">#</a> 1.什么是MongoDB</h3><p>MongoDB是一个文档数据库，提供好的性能，领先的非关系型数据库。采用BSON存储文档数据。 BSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON. 相对于json多了date类型和二进制数组。</p><h3 id="_2-mongodb的优势有哪些" tabindex="-1"><a class="header-anchor" href="#_2-mongodb的优势有哪些" aria-hidden="true">#</a> 2.MongoDB的优势有哪些</h3><ul><li>面向文档的存储：以 JSON 格式的文档保存数据。</li><li>任何属性都可以建立索引。</li><li>复制以及高可扩展性。</li><li>自动分片。</li><li>丰富的查询功能。</li><li>快速的即时更新。</li></ul><h3 id="_3-什么是集合-表" tabindex="-1"><a class="header-anchor" href="#_3-什么是集合-表" aria-hidden="true">#</a> 3.什么是集合(表)</h3><p>集合就是一组 MongoDB 文档。它相当于关系型数据库（RDBMS）中的表这种概念。集合位于单独的一个数据库中。 一个集合内的多个文档可以有多个不同的字段。一般来说，集合中的文档都有着相同或相关的目的。</p><h3 id="_4-什么是文档-记录" tabindex="-1"><a class="header-anchor" href="#_4-什么是文档-记录" aria-hidden="true">#</a> 4.什么是文档(记录)</h3><p>文档由一组key value组成。文档是动态模式,这意味着同一集合里的文档不需要有相同的字段和结构。在关系型 数据库中table中的每一条记录相当于MongoDB中的一个文档。</p><figure><img src="https://minio.pigx.top/oss/2022/08/8qeKGQ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_5-什么是非关系型数据库" tabindex="-1"><a class="header-anchor" href="#_5-什么是非关系型数据库" aria-hidden="true">#</a> 5.什么是非关系型数据库</h3><p>非关系型数据库的显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格模式。</p><h3 id="_6-为什么用mongodb" tabindex="-1"><a class="header-anchor" href="#_6-为什么用mongodb" aria-hidden="true">#</a> 6.为什么用MongoDB</h3><ul><li>架构简单</li><li>没有复杂的连接</li><li>深度查询能力,MongoDB支持动态查询。</li><li>容易调试</li><li>容易扩展</li><li>不需要转化/映射应用对象到数据库对象</li><li>使用内部内存作为存储工作区,以便更快的存取数据。</li></ul><h3 id="_7-在哪些场景使用mongodb" tabindex="-1"><a class="header-anchor" href="#_7-在哪些场景使用mongodb" aria-hidden="true">#</a> 7.在哪些场景使用MongoDB</h3><ul><li>大数据</li><li>内容管理系统</li><li>移动端Apps</li><li>数据管理</li></ul><h3 id="_8-mongodb中的命名空间是什么意思" tabindex="-1"><a class="header-anchor" href="#_8-mongodb中的命名空间是什么意思" aria-hidden="true">#</a> 8.MongoDB中的命名空间是什么意思?</h3><p>mongodb存储bson对象在丛集(collection)中.数据库名字和丛集名字以句点连结起来叫做名字空间(namespace).</p><p>集合命名空间里存储着集合的元数据，比如集合名称，集合的第一个数据域和最后一个数据域的位置等等。</p><p>一个集合命名空间又有多个数据域(extent)，而一个数据域由若干条文档(document)组成，每个数据域都有一个头部，记录着第一条文档和最后一条文档的位置，以及该数据域的一些元数据。extent之间，document之间通过双向链表连接。</p><p>索引的存储数据结构是B树，索引命名空间存储着对B树的根节点的指针。</p><h3 id="_9-monogodb-中的分片什么意思" tabindex="-1"><a class="header-anchor" href="#_9-monogodb-中的分片什么意思" aria-hidden="true">#</a> 9.monogodb 中的分片什么意思</h3><p>分片是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加以及读写操作的要求。</p><h3 id="_10-为什么要在mongodb中使用分析器" tabindex="-1"><a class="header-anchor" href="#_10-为什么要在mongodb中使用分析器" aria-hidden="true">#</a> 10.为什么要在MongoDB中使用分析器</h3><p>mongodb中包括了一个可以显示数据库中每个操作性能特点的数据库分析器.通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息,比如,可以确定是否需要添加索引。</p><h3 id="_11-mongodb支持主键外键关系吗" tabindex="-1"><a class="header-anchor" href="#_11-mongodb支持主键外键关系吗" aria-hidden="true">#</a> 11.MongoDB支持主键外键关系吗</h3><p>默认MongoDB不支持主键和外键关系。 用Mongodb本身的API需要硬编码才能实现外键关联，不够直观且难度较大。</p><h3 id="_12-mongodb支持哪些数据类型" tabindex="-1"><a class="header-anchor" href="#_12-mongodb支持哪些数据类型" aria-hidden="true">#</a> 12.MongoDB支持哪些数据类型</h3><ul><li>String</li><li>Integer</li><li>Double</li><li>Boolean</li><li>Object</li><li>Object ID</li><li>Arrays</li><li>Min/Max Keys</li><li>Datetime</li><li>Code</li><li>Regular Expression等</li></ul><h3 id="_13-在mongodb中什么是副本集" tabindex="-1"><a class="header-anchor" href="#_13-在mongodb中什么是副本集" aria-hidden="true">#</a> 13.在MongoDB中什么是副本集</h3><p>在MongoDB中副本集由一组MongoDB实例组成，包括一个主节点多个次节点，MongoDB客户端的所有数据都写入主节点(Primary),副节点从主节点同步写入数据，以保持所有复制集内存储相同的数据，提高数据可用性。</p><h1 id="dubbo" tabindex="-1"><a class="header-anchor" href="#dubbo" aria-hidden="true">#</a> Dubbo</h1><h3 id="_1-何为-rpc" tabindex="-1"><a class="header-anchor" href="#_1-何为-rpc" aria-hidden="true">#</a> 1.何为 RPC?</h3><p>​ <strong>RPC（Remote Procedure Call）</strong> 即远程过程调用。</p><p>​ <strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。</p><p>​ <strong>RPC 能帮助我们做什么呢？</strong> 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且我们不需要了解底层网络编程的具体细节。</p><p>​ 一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p><h3 id="_2-rpc-的原理是什么" tabindex="-1"><a class="header-anchor" href="#_2-rpc-的原理是什么" aria-hidden="true">#</a> 2.RPC 的原理是什么?</h3><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。</li><li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/wErJLd.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li><li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。</li></ol><h3 id="_3-有哪些常见的-rpc-框架" tabindex="-1"><a class="header-anchor" href="#_3-有哪些常见的-rpc-框架" aria-hidden="true">#</a> 3.有哪些常见的 RPC 框架？</h3><p>​ 我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如 Dubbo、Motan、gRPC这些。 如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p><h3 id="_4-什么是-dubbo" tabindex="-1"><a class="header-anchor" href="#_4-什么是-dubbo" aria-hidden="true">#</a> 4.什么是 Dubbo?</h3><p>​ Apache Dubbo是一款高性能、轻量级的开源 Java RPC 框架。</p><p>​ 根据 <a href="https://dubbo.apache.org/zh/" target="_blank" rel="noopener noreferrer">Dubbo 官方文档<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>的介绍，Dubbo 提供了六大核心能力</p><ol><li>面向接口代理的高性能RPC调用。</li><li>智能容错和负载均衡。</li><li>服务自动注册和发现。</li><li>高度可扩展能力。</li><li>运行期流量调度。</li><li>可视化的服务治理与运维。</li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/jGc2Dn.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>简单来说就是： <strong>Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。</strong></p><h3 id="_5-为什么要用-dubbo" tabindex="-1"><a class="header-anchor" href="#_5-为什么要用-dubbo" aria-hidden="true">#</a> 5.为什么要用 Dubbo?</h3><ol><li><strong>负载均衡</strong> ： 同一个服务部署在不同的机器时该调用哪一台机器上的服务。</li><li><strong>服务调用链路生成</strong> ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li><li><strong>服务访问压力以及时长统计、资源调度和治理</strong> ：基于访问压力实时管理集群容量，提高集群利用率。</li></ol><h3 id="_6-什么是分布式" tabindex="-1"><a class="header-anchor" href="#_6-什么是分布式" aria-hidden="true">#</a> 6.什么是分布式?</h3><p>​ 分布式或者说 SOA 分布式重要的就是面向服务，就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。</p><h3 id="_7-dubbo-架构中的核心角色有哪些" tabindex="-1"><a class="header-anchor" href="#_7-dubbo-架构中的核心角色有哪些" aria-hidden="true">#</a> 7.Dubbo 架构中的核心角色有哪些？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/WRS1VQ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上述节点简单介绍以及他们之间的关系：</p><ul><li><strong>Container：</strong> 服务运行容器，负责加载、运行服务提供者。必须。</li><li><strong>Provider：</strong> 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。</li><li><strong>Consumer：</strong> 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。</li><li><strong>Registry：</strong> 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。</li><li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。</li></ul><h3 id="_8-dubbo-中的-invoker-概念了解么" tabindex="-1"><a class="header-anchor" href="#_8-dubbo-中的-invoker-概念了解么" aria-hidden="true">#</a> 8.Dubbo 中的 Invoker 概念了解么？</h3><p>​ <code>Invoker</code> 是 Dubbo 领域模型中非常重要的一个概念。简单来说，<code>Invoker</code> 就是 Dubbo 对远程调用的抽象。</p><figure><img src="https://minio.pigx.top/oss/2022/07/rVofRS.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>按照 Dubbo 官方的话来说，<code>Invoker</code> 分为</p><ul><li>服务提供 <code>Invoker</code></li><li>服务消费 <code>Invoker</code></li></ul><p>假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的 <code>Invoker</code> 实现， <code>Invoker</code> 实现了真正的远程服务调用。</p><h3 id="_9-dubbo-的工作原理了解么" tabindex="-1"><a class="header-anchor" href="#_9-dubbo-的工作原理了解么" aria-hidden="true">#</a> 9.Dubbo 的工作原理了解么？</h3><p>下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。</p><blockquote><p>左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</p></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/oRZkPk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>config 配置层</strong>：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心。</li><li><strong>proxy 服务代理层</strong>：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 <code>ServiceProxy</code> 为中心。</li><li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现。</li><li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心。</li><li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心。</li><li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心。</li><li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心。</li><li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心。</li><li><strong>serialize 数据序列化层</strong> ：对需要在网络传输的数据进行序列化。</li></ul><h3 id="_10-dubbo-的-spi-机制了解么-如何扩展-dubbo-中的默认实现" tabindex="-1"><a class="header-anchor" href="#_10-dubbo-的-spi-机制了解么-如何扩展-dubbo-中的默认实现" aria-hidden="true">#</a> 10.Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？</h3><p>SPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。</p><p>SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。</p><p>Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java原生的 SPI机制进行了增强，以便更好满足自己的需求。</p><p><strong>那我们如何扩展 Dubbo 中的默认实现呢？</strong></p><p>比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 <code>XxxLoadBalance</code> 实现 <code>LoadBalance</code> 接口或者 <code>AbstractLoadBalance</code> 类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>xxx</span><span class="token punctuation">;</span>
 
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span></span><span class="token class-name">LoadBalance</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span></span><span class="token class-name">Invoker</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span></span><span class="token class-name">Invocation</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span></span><span class="token class-name">RpcException</span></span><span class="token punctuation">;</span> 
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XxxLoadBalance</span> <span class="token keyword">implements</span> <span class="token class-name">LoadBalance</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> invokers<span class="token punctuation">,</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将这个实现类的路径写入到<code>resources</code> 目录下的 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance</code>文件中即可。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>src
 <span class="token operator">|</span><span class="token operator">-</span>main
    <span class="token operator">|</span><span class="token operator">-</span>java
        <span class="token operator">|</span><span class="token operator">-</span>com
            <span class="token operator">|</span><span class="token operator">-</span>xxx
                <span class="token operator">|</span><span class="token operator">-</span><span class="token class-name">XxxLoadBalance</span><span class="token punctuation">.</span>java <span class="token punctuation">(</span>实现<span class="token class-name">LoadBalance</span>接口<span class="token punctuation">)</span>
    <span class="token operator">|</span><span class="token operator">-</span>resources
        <span class="token operator">|</span><span class="token operator">-</span><span class="token constant">META</span><span class="token operator">-</span><span class="token constant">INF</span>
            <span class="token operator">|</span><span class="token operator">-</span>dubbo
                <span class="token operator">|</span><span class="token operator">-</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span></span>LoadBalance</span> <span class="token punctuation">(</span>纯文本文件，内容为：xxx<span class="token operator">=</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span></span>XxxLoadBalance</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>org.apache.dubbo.rpc.cluster.LoadBalance</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>xxx=com.xxx.XxxLoadBalance
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其他还有很多可供扩展的选择，你可以在<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/impls/" target="_blank" rel="noopener noreferrer">官方文档@SPI扩展实现<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>这里找到</p><h3 id="_11-dubbo-的微内核架构了解吗" tabindex="-1"><a class="header-anchor" href="#_11-dubbo-的微内核架构了解吗" aria-hidden="true">#</a> 11.Dubbo 的微内核架构了解吗？</h3><p>Dubbo 采用 微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。</p><p>微内核架构包含两类组件：<strong>核心系统（core system）</strong> 和 <strong>插件模块（plug-in modules）</strong>。</p><figure><img src="https://minio.pigx.top/oss/2022/07/l1O3W5.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。</p><p>正是因为Dubbo基于微内核架构，才使得我们可以随心所欲替换Dubbo的功能点。比如你觉得Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！</p><p>通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自己造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件 ：<strong>JDK 标准的 SPI 扩展机制</strong> （<code>java.util.ServiceLoader</code>）。</p><h3 id="_12-dubbo-提供的负载均衡策略有哪些" tabindex="-1"><a class="header-anchor" href="#_12-dubbo-提供的负载均衡策略有哪些" aria-hidden="true">#</a> 12.Dubbo 提供的负载均衡策略有哪些？</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。</p><p>在 Dubbo 中，所有负载均衡实现类均继承自 <code>AbstractLoadBalance</code>，该类实现了 <code>LoadBalance</code> 接口，并封装了一些公共的逻辑。</p><p>1.<strong>RandomLoadBalance</strong></p><p>根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。</p><p><code>RandomLoadBalance</code> 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p><p>我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。</p><p>2.<strong>LeastActiveLoadBalance</strong></p><p><code>LeastActiveLoadBalance</code> 直译过来就是<strong>最小活跃数负载均衡</strong>。</p><p>初始状态下所有服务提供者的活跃数均为 0，每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。</p><p>因此，<strong>Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。</strong></p><p><strong>如果有多个服务提供者的活跃数相等怎么办？</strong></p><p>很简单，那就再走一遍 <code>RandomLoadBalance</code> 。</p><p>3.<strong>ConsistentHashLoadBalance</strong></p><p><code>ConsistentHashLoadBalance</code> 即<strong>一致性Hash负载均衡策略</strong>。 <code>ConsistentHashLoadBalance</code> 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。</p><p>另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。</p><p>4.<strong>RoundRobinLoadBalance</strong></p><p>加权轮询负载均衡。</p><p>轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。如果我们有 10 次请求，那么 7 次会被 S1处理，3次被 S2处理。</p><h3 id="_13-说一下dubbo服务注册流程" tabindex="-1"><a class="header-anchor" href="#_13-说一下dubbo服务注册流程" aria-hidden="true">#</a> 13.说一下Dubbo服务注册流程?</h3><ol><li><p>服务容器负责启动，加载，运行服务提供者。</p></li><li><p>服务提供者在启动时，向注册中心注册自己提供的服务。</p></li><li><p>服务消费者在启动时，向注册中心订阅自己所需的服务。</p></li><li><p>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p></li><li><p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失 败，再选另一台调用。</p></li><li><p>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中 心。</p></li></ol><h3 id="_14-怎么实现动态感知服务下线的呢" tabindex="-1"><a class="header-anchor" href="#_14-怎么实现动态感知服务下线的呢" aria-hidden="true">#</a> 14.怎么实现动态感知服务下线的呢？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/sdG9KF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>服务订阅通常有 pull 和 push 两种方式：</p><ol><li><p>pull 模式需要客户端定时向注册中心拉取配置；</p></li><li><p>push 模式采用注册中心主动推送数据给客户端。</p></li></ol><p>Dubbo ZooKeeper 注册中心采用是事件通知与客户端拉取方式。服务第一次订阅的时候将会拉取 对应目录下全量数据，然后在订阅的节点注册一个 watcher。一旦目录节点下发生任何数据变化， ZooKeeper 将会通过 watcher 通知客户端。客户端接到通知，将会重新拉取该目录下全量数据， 并重新注册 watcher。利用这个模式，Dubbo 服务就可以做到服务的动态发现。</p><p>注意：ZooKeeper 提供了“心跳检测”功能，它会定时向各个服务提供者发送一个请求（实际上建立 的是一个 socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除。</p><h3 id="_15-dubbo-容错策略" tabindex="-1"><a class="header-anchor" href="#_15-dubbo-容错策略" aria-hidden="true">#</a> 15.Dubbo 容错策略?</h3><ul><li>failover cluster 模式</li></ul><p>​ provider 宕机重试以后，请求会分到其他的 provider 上，默认两次，可以手动设置重试次数，建议把写操作重试次数设置成 0。</p><ul><li>failback 模式</li></ul><p>​ 失败自动恢复会在调用失败后，返回一个空结果给服务消费者。并通过定时任务对失败的调用进行 重试，适合执行消息通知等操作。</p><ul><li>failfast cluster 模式</li></ul><p>​ 快速失败只会进行一次调用，失败后立即抛出异常。适用于幂等操作、写操作，类似于 failover cluster 模式中重试次数设置为 0 的情况。</p><ul><li>failsafe cluster 模式</li></ul><p>​ 失败安全是指，当调用过程中出现异常时，仅会打印异常，而不会抛出异常。适用于写入审计日志 等操作。</p><ul><li>forking cluster 模式</li></ul><p>​ 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多 服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</p><ul><li>broadcacst cluster 模式</li></ul><p>​ 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志 等本地资源信息。</p><h3 id="_16-dubbo-框架源码最重要的设计原则是什么" tabindex="-1"><a class="header-anchor" href="#_16-dubbo-框架源码最重要的设计原则是什么" aria-hidden="true">#</a> 16.Dubbo 框架源码最重要的设计原则是什么？</h3><p><strong>Dubbo 在设计时具有两大很大的设计原则：</strong></p><ul><li><p>“微内核+插件”的设计模式。内核只负责组装插件（扩展点），Dubbo 的功能都是由插件实现的，也就是 Dubbo 的所有功能点都可被用户自定义扩展类所替换。Dubbo 的高扩展性、开放性在这里被充分体现。</p></li><li><p>采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。简单来说就是，在 Dubbo 中，所有重要资源都是以 URL 的形式来描述的。</p></li></ul><h3 id="_17-dubbo-官方给出了四大组件的概念-请谈一下你对它们的认识。" tabindex="-1"><a class="header-anchor" href="#_17-dubbo-官方给出了四大组件的概念-请谈一下你对它们的认识。" aria-hidden="true">#</a> 17.Dubbo 官方给出了四大组件的概念，请谈一下你对它们的认识。</h3><p>Dubbo 的四大组件为：Consuer、Provider、Registry 与 Monitor。</p><p>它们间的关系可以描 述为如下几个过程：</p><ol><li><p>start：Dubbo 服务启动，Spring 容器首先会创建服务提供者。</p></li><li><p>register：服务提供者创建好后，马上会注册到服务注册中心 Registry，这个注册过程称为服务暴露。服务暴露的本质是将服务名称（接口）与服务提供者主机写入到注册中心 Registry 的服务映射表中。</p></li><li><p>subscribe：服务消费者启动后，首先会向服务注册中心订阅相关服务。</p></li><li><p>notify：消费者可能订阅的服务在注册中心还没有相应的提供者。当相应的提供者在注册中心注册后，注册中心会马上通知订阅该服务的消费者。</p></li><li><p>invoke：消费者以同步或异步的方式调用提供者提供的请求。消费者通过远程注册中心获取到提供者列表，然后消费者会基于负载均衡算法选一台提供者处理消费者的请求。</p></li><li><p>count：每个消费者对各个服务的累计调用次数、调用时间；每个提供者被消费者调用的累计次数和时间，消费者与调用者都会定时发送到监控中心，由监控中心记录。这些统计数据可以在 Dubbo 的可视化界面看到。</p></li></ol><h3 id="_18-什么是-spi-请简单描述一下-spi-要解决的问题。" tabindex="-1"><a class="header-anchor" href="#_18-什么是-spi-请简单描述一下-spi-要解决的问题。" aria-hidden="true">#</a> 18.什么是 SPI？请简单描述一下 SPI 要解决的问题。</h3><p>SPI，Service Provider Interface，服务提供者接口，是一种服务发现机制。其主要是解决面向抽象编程中上层对下层接口实现类的依赖问题，可以实现这两层间的解耦合。</p><h3 id="_19-jdk-的-spi-机制存在什么问题" tabindex="-1"><a class="header-anchor" href="#_19-jdk-的-spi-机制存在什么问题" aria-hidden="true">#</a> 19.JDK 的 SPI 机制存在什么问题？</h3><p>JDK 的 SPI 机制将所有配置文件中的实现类全部实例化，无论是否能够用到，浪费了 宝贵的系统资源。</p><h3 id="_20-dubbo-框架的-adaptive-类都有哪些-adaptive-类与-adaptive-方法的区别是什么-或者说-各自的应用场景有什么不同" tabindex="-1"><a class="header-anchor" href="#_20-dubbo-框架的-adaptive-类都有哪些-adaptive-类与-adaptive-方法的区别是什么-或者说-各自的应用场景有什么不同" aria-hidden="true">#</a> 20.Dubbo 框架的 Adaptive 类都有哪些？Adaptive 类与 Adaptive 方法的区别是什么？ 或者说，各自的应用场景有什么不同？</h3><p>Dubbo 中的 Adaptive 类共有两个：AdaptiveExtensionFactory 与 AdaptiveCompiler。</p><p>Adaptive 类主要是用于限定其 SPI 扩展类的获取方式：必须按照该类中指定的方式获取。 Adaptive 类允许程序员在其中自行定义扩展实例的获取逻辑。 在获取 SPI 扩展实例时若采用自适应方式获取，系统会首先查找其 Adaptive 类，若没有找到， 则会查看该 SPI 接口中的 Adaptive 方法，然后根据 Adaptive 方法自动为该 SPI 接口动态生成 一个 Adaptive 扩展类，并自动将其编译。由于 Adaptive 方法生成的 Adaptive 类的逻辑是固定的，所以无法实现程序员自己想要的获取逻辑，但非常方便。若没有特殊需求，Adaptive 方法使用更方便。</p><h3 id="_21-简述-dubbo-的-wrapper-机制" tabindex="-1"><a class="header-anchor" href="#_21-简述-dubbo-的-wrapper-机制" aria-hidden="true">#</a> 21.简述 Dubbo 的 Wrapper 机制？</h3><p>Wrapper 机制，即扩展类的包装机制。就是对扩展类中的 SPI 接口方法进行增强，进行包装，是AOP 思想的体现，是 Wrapper 设计模式的应用。一个 SPI 可以包含多个 Wrapper， 即可以通过多个 Wrapper 对同一个扩展类进行增强，增强出不现的功能。Wrapper 机制不是 通过注解实现的，而是通过一套 Wrapper 规范实现的。</p><h3 id="_22-dubbo-的-wrapper-类是否属于扩展类" tabindex="-1"><a class="header-anchor" href="#_22-dubbo-的-wrapper-类是否属于扩展类" aria-hidden="true">#</a> 22.Dubbo 的 Wrapper 类是否属于扩展类？</h3><p>wrapper 类仅仅是对现有的扩展类功能上的增强，并不是一个独立的扩展类，所以其不属于扩展类范畴。</p><h3 id="_23-简述-dubbo-的-active-机制" tabindex="-1"><a class="header-anchor" href="#_23-简述-dubbo-的-active-机制" aria-hidden="true">#</a> 23.简述 Dubbo 的 Active 机制？</h3><p>Activate 机制，即扩展类的激活机制。通过指定的条件来实现一次激活多个扩展类的目的。激活机制没有增强扩展类，也没有增加扩展类，其仅仅是为原有的扩展类添加了更多 的识别标签，而不像之前的，每个扩展类仅有一个“功能性扩展名”识别标签。其是通过 @Active 注解实现的。</p><h3 id="_24-dubbo-的-activate-类是否属于扩展类" tabindex="-1"><a class="header-anchor" href="#_24-dubbo-的-activate-类是否属于扩展类" aria-hidden="true">#</a> 24.Dubbo 的 Activate 类是否属于扩展类？</h3><p>Activate 机制仅用于为扩展类添加激活标识的，其是通过在扩展类上添加 @Activate 注解来实现的，所以 Activate 类本身就是扩展类。</p><h3 id="_25-请对-dubbo-的普通扩展类、adaptive-类、wrapper-类-及-activate-类的实现方式、-个数-及是否属于扩展类等进行一个总结。" tabindex="-1"><a class="header-anchor" href="#_25-请对-dubbo-的普通扩展类、adaptive-类、wrapper-类-及-activate-类的实现方式、-个数-及是否属于扩展类等进行一个总结。" aria-hidden="true">#</a> 25.请对 Dubbo 的普通扩展类、Adaptive 类、Wrapper 类，及 Activate 类的实现方式、 个数，及是否属于扩展类等进行一个总结。</h3><p>在 Dubbo 的扩展类配置文件中可能会存在四种类：普通扩展类，Adaptive 类，Wrapper 类，及 Activate 类。</p><p>它们的共同点是，都实现了 SPI 接口。 Adaptive 类与 Activate 类都是通过注解定义的。 一个 SPI 接口的 Adaptive 类（无论是否是自动生成的）只会有一个，而 Wrapper 类与Activate 类可以有多个。 只有普通扩展类与 Activate 属于扩展类，Adaptive 类与 Wrapper 类均不属于扩展类范畴。因为它们都是依附于扩展类的，无法独立使用。</p><h3 id="_26-简述-dubbo-的-extensionloader-实例的组成。" tabindex="-1"><a class="header-anchor" href="#_26-简述-dubbo-的-extensionloader-实例的组成。" aria-hidden="true">#</a> 26.简述 Dubbo 的 ExtensionLoader 实例的组成。</h3><p>ExtensionLoader 实例用于加载并创建指定类型的扩展类实例。所以这个 loader 实例 由两个成员变量组成。一个是 Class 类型的 type，用于标识这个 loader 可以加载的 SPI 类型； 一个是 ExtensionFactory，用于创建这个指定 SPI 类型的扩展类实例。</p><h3 id="_27-dubbo-在查找指定扩展类时-其会查找哪些目录中的扩展类配置文件-对于这些目录中的配置文件-其是查找了所有这些目录-在一个目录中找到了就不再找其它目录了-其是仅加载了这一个扩展类还是加载了全部该-spi-的所有扩展类" tabindex="-1"><a class="header-anchor" href="#_27-dubbo-在查找指定扩展类时-其会查找哪些目录中的扩展类配置文件-对于这些目录中的配置文件-其是查找了所有这些目录-在一个目录中找到了就不再找其它目录了-其是仅加载了这一个扩展类还是加载了全部该-spi-的所有扩展类" aria-hidden="true">#</a> 27.Dubbo 在查找指定扩展类时，其会查找哪些目录中的扩展类配置文件？对于这些目录中的配置文件，其是查找了所有这些目录，在一个目录中找到了就不再找其它目录了？ 其是仅加载了这一个扩展类还是加载了全部该 SPI 的所有扩展类？</h3><p>Dubbo 在查找指定扩展类时，其会依次查找三个目录：META-INF/dubbo/internal 目录； META-INF/dubbo 目录；META-INF/services 目录。 其会将这三个目录中所有的该类型的 SPI 扩展类全部加载到内存，但仅会创建并初始化 指定扩展名的实例。</p><h3 id="_28-dubbo-源码中是如何判断一个类是否是-wrapper-类的" tabindex="-1"><a class="header-anchor" href="#_28-dubbo-源码中是如何判断一个类是否是-wrapper-类的" aria-hidden="true">#</a> 28.Dubbo 源码中是如何判断一个类是否是 Wrapper 类的？</h3><p>Dubbo 源码中对于 Wrapper 类的判断仅是判断其是否包含一个这样的构造器：只包 含一个参数，且这个参数是 SPI 接口类型。即 Wrapper 实例中用于增强的 SPI 扩展类实例， 是通过带参构造器传入的。</p><h3 id="_29-从-dubbo-源码中可以看出-一个-spi-接口的实现类有什么要求" tabindex="-1"><a class="header-anchor" href="#_29-从-dubbo-源码中可以看出-一个-spi-接口的实现类有什么要求" aria-hidden="true">#</a> 29.从 Dubbo 源码中可以看出，一个 SPI 接口的实现类有什么要求？</h3><p>从 Dubbo 源码中可以看出，一个 SPI 接口的实现类除了其要实现 SPI 接口外，还必须 具有无参构造器。</p><h3 id="_30-extensionloader-实例中包含一个-extensionfactory-实例-objectfactory-该实例用于-创建指定扩展名的扩展类实例-简述-objectfactory-创建扩展类实例的过程。" tabindex="-1"><a class="header-anchor" href="#_30-extensionloader-实例中包含一个-extensionfactory-实例-objectfactory-该实例用于-创建指定扩展名的扩展类实例-简述-objectfactory-创建扩展类实例的过程。" aria-hidden="true">#</a> 30.ExtensionLoader 实例中包含一个 ExtensionFactory 实例 objectFactory，该实例用于 创建指定扩展名的扩展类实例，简述 objectFactory 创建扩展类实例的过程。</h3><p>ExtensionFactory 创建实例的方式有两种：SPI 与 Spring 容器。</p><p>objectFactory 通过调 用 getExtension(type, name)方法来获取指定类型与名称的扩展类实例。getExtension()方法首 先会尝试通过 SPI 方式来获取；若没有找到，则再从 Spring 容器中去尝试获取指定名称的实 例；若没有找到，则再从 Spring 容器中去尝试获取指定类型的实例。若还没有，则抛出异常。</p><h3 id="_31-请简述一个指定功能性扩展名的扩展类实例的创建、setter-及-wrapper-的顺序与过-程" tabindex="-1"><a class="header-anchor" href="#_31-请简述一个指定功能性扩展名的扩展类实例的创建、setter-及-wrapper-的顺序与过-程" aria-hidden="true">#</a> 31.请简述一个指定功能性扩展名的扩展类实例的创建、setter 及 wrapper 的顺序与过 程？</h3><p>一个扩展类实例的创建与初始化过程是：在获取该 SPI 接口的 loader 时会首先将当 前 SPI 接口的所有扩展类（四类）全部加载并缓存。然后通过 getExtension()方法获取该实例 时，其会从缓存中获取到该扩展名对应的扩展类，然后调用其无参构造器创建实例。然后调用该实例的 setter 进行注入初始化。若该 SPI 还存在 Wrapper，则会按照这些 Wrapper 的注册顺序逐层将这个实例进行包装。当然，在调用执行时，其一定是从最外层的 Wrapper 开 始逐层向内执行，直至执行到该扩展类实例的方法。</p><h1 id="seata" tabindex="-1"><a class="header-anchor" href="#seata" aria-hidden="true">#</a> Seata</h1><h3 id="_1-seata-at模式原理流程" tabindex="-1"><a class="header-anchor" href="#_1-seata-at模式原理流程" aria-hidden="true">#</a> 1.Seata AT模式原理流程</h3><p>​ Seata 是一款阿里开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案，github地址：<a href="https://github.com/seata/seata%E3%80%82" target="_blank" rel="noopener noreferrer">https://github.com/seata/seata。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>RM</strong>：资源管理者（Resource Manager ），对应微服务架构中小型服务的业务数据库，业务数据库代表了一个分支事务。RM管理分支事务并与 TC 进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。</p><p><strong>TC</strong>：事务协调者（Transaction Coordinator），负责管理整个分布式事务，每个节点的分支事务在执行之前，都会在事务协调者上注册，本地事务执行结束后，还会向协调者汇报。当事务需要提交或回滚时，也协调者负责推送给各个RM。每个节点的分支事务在执行之前，使用XID向TC注册分支事务并接收TC的提交或回滚指令。</p><p><strong>TM</strong>：事务管理者（Transaction Manager）,分布式事务的发起者，负责向TC申请全局事务XID。TM在调用其他服务提供的API执行本地分支事务时会向各分支事务传递XID。</p><figure><img src="https://minio.pigx.top/oss/2022/08/pQictL.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>关于分布式事务模式，seata可分为如下几种：</p><p><strong>AT</strong>：Auto Transaction，基于支持本地ACID事务的关系型数据库，对业务无侵入；</p><p><strong>MT</strong>：Manual Transaction，不依赖于底层数据资源的事务支持，需自定义prepare/commit/rollback操作，对业务有侵入；</p><p><strong>XA</strong>：基于数据库的XA实现，目前最新版seata已实现该模式。</p><p><strong>TCC</strong>：TCC模式，对业务有侵入。</p><p>由于目前seata场景中使用AT模式较多，因此本文主要分析AT模式流程。</p><p>AT模式的前提是基于支持本地 ACID 事务的关系型数据库和Java应用基于JDBC访问数据库。<strong>AT模式是二阶段提交协议的演变</strong>：</p><p><strong>一阶段</strong>：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</p><p><strong>二阶段</strong>：commit异步化快速完成；rollback通过一阶段的回滚日志进行反向补偿。</p><p><strong>读写隔离</strong> 写隔离保证是通过<strong>全局锁</strong>来保证的，一阶段事务提交前<strong>必须要拿到全局锁</strong>，否则不能提交本地事务，<strong>获取全局锁过程中不能无限等待，超时后放弃，并回滚本地事务，释放本地锁（避免产生死锁）。</strong></p><p>​ 比如两个全局事务tx1和tx2，分别对a表的m字段做更新操作，m初始值1000。</p><p>​ tx1先开始，开启本地事务拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的全局锁 ，本地提交释放本地锁。</p><p>​ tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的全局锁 ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待全局锁 。</p><p>​ 此时会有以下两种情况：</p><pre><code>	1. tx1 二阶段全局提交，释放全局锁 。tx2 拿到 全局锁 提交本地事务。
	1. 如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。此时，如果 tx2 仍在等待该数据的 全局锁，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 全局锁 等锁超时，放弃 全局锁 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功（回滚时获取本地锁是没有超时机制的）。因为整个过程 全局锁 在 tx1 结束前一直是被 tx1 持有的，所以不会发生脏写的问题。
</code></pre><p><strong>隔离级别</strong> 在数据库本地事务隔离级别 读已提交（Read Committed） 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交</strong>（Read Uncommitted），因为分支事务在阶段一就已经提交了，如果其他分支事务还未提交，那么从已提交事务的数据库读取数据能看到更新后的数据，因为此时全局事务还未全部提交，所以是未提交读。</p><p>如果应用在特定场景下，必须要求全局的 读已提交 ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理：</p><figure><img src="https://minio.pigx.top/oss/2022/08/0BM7df.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>SELECT FOR UPDATE 语句的执行会申请 全局锁 ，如果 全局锁 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 全局锁 拿到，即读取的相关数据是 已提交 的，才返回。出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。 <strong>工作机制</strong> 一阶段：</p><ol><li><p>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = &#39;TXC&#39;）等相关的信息。</p></li><li><p>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</p></li><li><p>执行业务 SQL：执行业务更新SQL。</p></li><li><p>查询后镜像：根据前镜像的结果，通过 主键 定位数据。</p></li><li><p>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。</p></li><li><p>提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。</p></li><li><p>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</p></li><li><p>将本地事务提交的结果上报给 TC。</p></li></ol><p>一阶段在分支事务提交前向TC注册分支，进行一次通信。</p><p>二阶段-回滚：</p><ol><li><p>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</p></li><li><p>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p></li><li><p>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</p></li><li><p>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句。</p></li><li><p>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</p></li></ol><p>二阶段-提交：</p><ol><li><p>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</p></li><li><p>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</p></li></ol><p>UNDO_LOG Table，MySQL示例如下：</p><p>DROP TABLE IF EXISTS <code>undo_log</code>; -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log CREATE TABLE <code>undo_log</code> ( <code>id</code> bigint(20) NOT NULL AUTO_INCREMENT, <code>branch_id</code> bigint(20) NOT NULL, <code>xid</code> varchar(100) NOT NULL, <code>context</code> varchar(128) NOT NULL, <code>rollback_info</code> longblob NOT NULL, <code>log_status</code> int(11) NOT NULL, <code>log_created</code> datetime NOT NULL, <code>log_modified</code> datetime NOT NULL, PRIMARY KEY (<code>id</code>), UNIQUE KEY <code>ux_undo_log</code> (<code>xid</code>,<code>branch_id</code>) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; <strong>关于seata事务的思考</strong> 一般的事务操作有插入、更新、删除几种，下面分别看下个各情况的执行流程：</p><p>插入操作：查询前镜像为空，查询后镜像非空，回滚时直接删除新插入数据即可。</p><p>更新操作：查询前后镜像都非空，回滚直接恢复到查询前镜像即可；</p><p>删除操作：查询前镜像非空，查询后镜像为空，回滚时直接插入原来数据即可，因为二阶段未执行完成时全局锁未释放，所以该过程中其他业务不会插入具有相同id的记录。</p><p>注意：回滚数据时，会对比当前数据和undolog是否一致，如果不一致表示有其他事务进行了数据更新操作，此时时不能直接进行回滚数据的。</p><h1 id="sentinel" tabindex="-1"><a class="header-anchor" href="#sentinel" aria-hidden="true">#</a> sentinel</h1><h3 id="_1-什么是sentinel" tabindex="-1"><a class="header-anchor" href="#_1-什么是sentinel" aria-hidden="true">#</a> 1.什么是sentinel？</h3><p>sentinel顾名思义：卫兵；在Redis中叫做哨兵，用于监控主从切换，但是在微服务中叫做流量防卫兵。</p><p>Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>Sentinel 具有以下特征:</p><p>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p><p>完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p><p>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。</p><p>完善的 SPI 扩展机制：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p><p>Sentinel 的主要特性如下图： <img src="https://minio.pigx.top/oss/2022/08/QrBsmb.png" alt="" loading="lazy"></p><p>Sentinel 分为两个部分:</p><p>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</p><p>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</p><h3 id="_2-sentinel和hystrix有何区别" tabindex="-1"><a class="header-anchor" href="#_2-sentinel和hystrix有何区别" aria-hidden="true">#</a> 2.sentinel和Hystrix有何区别？</h3><figure><img src="https://minio.pigx.top/oss/2022/08/417wi8.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-流量控制如何配置" tabindex="-1"><a class="header-anchor" href="#_3-流量控制如何配置" aria-hidden="true">#</a> 3.流量控制如何配置？</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p><strong>QPS</strong>：每秒请求数，即在不断向服务器发送请求的情况下，服务器每秒能够处理的请求数量。</p><p><strong>并发线程数</strong>：指的是施压机施加的同时请求的线程数量。</p><p>同一个资源可以创建多条限流规则，一条限流规则由以下元素组成：</p><p><strong>resource</strong>：资源名，即限流规则的作用对象。</p><p><strong>count</strong>： 限流阈值</p><p><strong>grade</strong>：限流阈值类型（1：QPS 0：并发线程数），默认值QPS</p><p><strong>limitApp</strong>：流控针对的调用来源，若为 default 则不区分调用来源，默认值default</p><p><strong>strategy</strong>：判断的根据是资源自身**(0)，还是根据其它关联资源 (1)，还是根据链路入口(2)**，默认值根据资源本身。</p><p><strong>controlBehavior</strong>： 流控效果（直接拒绝(0) / 排队等待(2) / 预热冷启动(1))，默认值直接拒绝。 以上元素限流元素对应的类是<code>com.alibaba.csp.sentinel.slots.block.flow.FlowRule</code>，各元素如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/MoBikl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/08/MJsrak.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-三种流控效果" tabindex="-1"><a class="header-anchor" href="#_4-三种流控效果" aria-hidden="true">#</a> 4.三种流控效果</h3><p>流控效果总共分为三种，对应元素controlBehavior，分别如下：</p><ol><li><strong>快速失败</strong></li></ol><p>默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。</p><ol start="2"><li><strong>warm up</strong></li></ol><p>即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p><p>注意：这一效果只针对QPS流控，并发线程数流控不支持。 预热底层是根据令牌桶算法实现的，源码对应得类在com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController。</p><p><strong>算法中有一个冷却因子coldFactor，默认值是3，即请求 QPS 从 threshold(阈值) / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。</strong></p><p>比如设定QPS阈值为3，流控效果为warm up，预热时长为5秒，如下图： <img src="https://minio.pigx.top/oss/2022/08/3xhE93.png" alt="" loading="lazy"></p><ol start="3"><li><strong>排队等待</strong></li></ol><p>匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。源码对应得类：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController</p><p>注意：这一效果只针对QPS流控，并发线程数流控不支持。</p><p>简单举个栗子：你去大学食堂吃饭，只有一个阿姨在打饭，那么所有人都要排队打饭，每次只有一个人打到饭，其他人都在排队等待。</p><p>不同的是sentinel有个超时等待时间，一旦超过这个预定设置的时间将会被限流。 <img src="https://minio.pigx.top/oss/2022/08/DlqbSj.png" alt="" loading="lazy"></p><blockquote><p>这种方式适合用于请求以突刺状来到，这个时候我们不希望一下子把所有的请求都通过，这样可能会把系统压垮；同时我们也期待系统以稳定的速度，逐步处理这些请求，以起到“<strong>削峰填谷</strong>”的效果，而不是拒绝所有请求。</p></blockquote><p>比如设置QPS阈值为1，超时等待时间为10000毫秒，如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/JNrJWZ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_5-三种流控模式" tabindex="-1"><a class="header-anchor" href="#_5-三种流控模式" aria-hidden="true">#</a> 5. 三种流控模式</h3><p>流控模式总共分为三种，对应元素strategy，分别如下：</p><ol><li><p>直接拒绝：接口达到限流条件时，直接限流</p></li><li><p>关联：当关联的资源达到阈值时，就限流自己</p></li><li><p>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就可以限流）</p></li></ol><p>下面来详细介绍下以上三种流控模式。</p><p><strong>直接拒绝</strong></p><p>顾名思义：默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。上面的几个例子都是配置了直接拒绝这个模式，这里不再详细介绍。</p><p><strong>关联</strong></p><p>典型的使用场景：一个是支付接口，一个是下单接口，此时一旦支付接口达到了阈值，那么订单接口就应该被限流，不然这边还在下单，消费者等待或者直接被拒绝支付将会极大的影响用户体验。</p><p>简而言之：A关联B，一旦B达到阈值，则A被限流</p><h3 id="_6-两种统计类型" tabindex="-1"><a class="header-anchor" href="#_6-两种统计类型" aria-hidden="true">#</a> 6.两种统计类型</h3><p>流控分为两种统计类型，分别是<strong>QPS</strong>，<strong>并发线程数</strong></p><p><strong>举个栗子</strong>：陈某带了一个亿去银行存钱，但是银行大门保安要查健康码，每秒最多只能同时进入4个人，并且银行中只有两个工作人员工作，如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/hky6e9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>此时的QPS含义</strong>：从保安到银行这一段，即是保安放行进入银行的人数。</p><p><strong>此时并发线程数的含义</strong>：银行只有两个工作人员在工作，那么最多只能同时处理两个任务，这里并发线程数的阈值就是2。</p><h3 id="_7-降级规则如何配置" tabindex="-1"><a class="header-anchor" href="#_7-降级规则如何配置" aria-hidden="true">#</a> 7.降级规则如何配置？</h3><p>熔断降级在日常生活中也是比较常见的，场景如下：</p><ul><li>股票市场的熔断，当价格触发到了熔点之后，会暂停交易一段时间，或者交易可以继续进行，但是报价会限制在一定的范围。</li><li>电压过高导致保险丝触发熔断保护</li></ul><p>在大型的分布式系统中，一个请求的依赖如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/WkV9VB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果这个时候，某个服务出现一些异常，比如：</p><ol><li><p>服务提供者不可用(硬件故障、程序bug、网络故障、用户请求量较大)</p></li><li><p>重试导致的流量过大</p></li><li><p>服务调用者使用同步调用，产生大量的等待线程占用系统资源，一旦线程资源被耗尽，调用者提供的服务也会变成不可用状态</p></li></ol><p>那么将会导致整个服务不可用，用古话来讲就是：千里之堤毁于蚁穴。</p><p>所谓编程源于生活，架构师们根据生活的经验设计出了服务的熔断降级策略，很好的解决了这类问题。</p><p>熔断降级规则对应sentinel控制台的降级规则这一栏，如下图： <img src="https://minio.pigx.top/oss/2022/08/C2nqFn.png" alt="" loading="lazy"></p><p>熔断降级涉及到的几个属性如下表：</p><figure><img src="https://minio.pigx.top/oss/2022/08/4rRDtE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>源码中对应得类为：com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule。</p><h3 id="_8-三种熔断策略" tabindex="-1"><a class="header-anchor" href="#_8-三种熔断策略" aria-hidden="true">#</a> 8.三种熔断策略</h3><p>Sentinel 提供以下几种熔断策略：</p><ol><li><p>平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。</p></li><li><p>异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p></li><li><p>异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p></li></ol><h3 id="_9-热点参数如何限流" tabindex="-1"><a class="header-anchor" href="#_9-热点参数如何限流" aria-hidden="true">#</a> 9.热点参数如何限流？</h3><p>顾名思义：热点就是经常访问的数据，很多时候肯定是希望统计某个访问频次Top K数据并对其进行限流。</p><p>比如秒杀系统中的商品ID，对于热点商品那一瞬间的并发量是非常可怕的，因此必须要对其进行限流。</p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。</p><p>注意：热点参数限流只针对QPS。 <img src="https://minio.pigx.top/oss/2022/08/zSTkks.png" alt="" loading="lazy"></p><p>规则对应得源码在<code>com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule</code>这个类中，各种属性含义如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/08/57vYA3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_10-系统自适应如何限流" tabindex="-1"><a class="header-anchor" href="#_10-系统自适应如何限流" aria-hidden="true">#</a> 10.系统自适应如何限流？</h3><p>前面热点参数、普通流量限流都是针对的某个接口，这里系统自适应限流针对是整个系统的入口流量，从单台机器的 <strong>load</strong>、<strong>CPU 使用率</strong>、<strong>平均 RT</strong>、<strong>入口 QPS</strong> 和<strong>并发线程数</strong>等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><figure><img src="https://minio.pigx.top/oss/2022/08/7wXzIl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>阈值类型有五种，分别如下：</p><p>Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。</p><p>CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</p><p>平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</p><p>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p><p>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</p><h1 id="eureka" tabindex="-1"><a class="header-anchor" href="#eureka" aria-hidden="true">#</a> Eureka</h1><h3 id="_1-eureka-server-数据存储" tabindex="-1"><a class="header-anchor" href="#_1-eureka-server-数据存储" aria-hidden="true">#</a> 1.Eureka Server 数据存储</h3><p>Eureka Server 的数据存储分了二层：<strong>数据层和缓存层</strong> 数据层记录的是注册到Eureka Server 上的服务信息，缓存层记录包装以后的数据，可以直接在 Eureka Client 调用时返回。 Eureka Server 的数据层是<strong>二层 ConcurrentHashMap</strong>， ConcurrentHashMap 是线程安全高效的 Map 集合。 第一层的 ConcurrentHashMap 的 key=spring.application.name也就是客户端实例注册的应用名。 第二层嵌套的 ConcurrentHashMap 的 key=instanceId 也就是服务的唯一实例 ID，value 为 Lease 对象，Lease 对象存储着这个实例的所有注册信息，包括 ip 、端口、属性等。 根据这个存储结构我们可以发现，Eureka Server 第一层都是存储着所有的服务名，以及服务名对应的实例信息</p><p><strong>Eureka Server 缓存机制</strong></p><p>Eureka Server 为了提供响应效率，提供了两层的缓存结构，将 Eureka Client 所需要的注册信息，直接存储在缓存结构中。 第一层缓存：readOnlyCacheMap，本质上是 ConcurrentHashMap，依赖定时从 readWriteCacheMap 同步数据，默认时间为 30 秒。 readOnlyCacheMap ： 是一个 CurrentHashMap 只读缓存，这个主要是为了供客户端获取注册信息时使用，其缓存更新，依赖于定时器的更新，通过和 readWriteCacheMap 的值做对比，如果数据不一致，则以 readWriteCacheMap 的数据为准。 第二层缓存：readWriteCacheMap，本质上是 Guava 缓存。 eadWriteCacheMap：readWriteCacheMap 的数据主要同步存储层的数据，当请求获取缓存时判断缓存中是否没有数据，如果不存在此数据，则通过 CacheLoader 的 load 方法去加载，加载成功之后将数据放入缓存，同时返回数据。 readWriteCacheMap 缓存过期时间，默认为 180 秒，当服务下线、过期、注册、状态变更，都会来清除此缓存中的数据。 Eureka Client 获取全量或者增量的数据时，会先从一级缓存中获取；如果一级缓存中不存在，再从二级缓存中获取；如果二级缓存也不存在，这时候先将存储层的数据同步到缓存中，再从缓存中获取。</p><p>通过 Eureka Server 的二层缓存机制，可以非常有效地提升 Eureka Server 的响应时间，通过数据存储层和缓存层的数据切割，根据使用场景来提供不同的数据支持。</p><p><strong>其它缓存设计</strong></p><p>Eureka Server 端存在缓存外，Eureka Client 也同样存在着缓存机制，Eureka Client <strong>启动时会全量拉取服务列表</strong>，启动后每隔 30 秒从 Eureka Server 增量获取服务列表信息，并保持在本地缓存中。</p><p>Eureka Client 增量拉取失败，或者增量拉取之后对比 hashcode 发现不一致，就会执行全量拉取，这样避免了网络某时段分片带来的问题，同样会更新到本地缓存。 同时对于服务调用，如果涉及到 ribbon 负载均衡，那么 ribbon 对于这个实例列表也有自己的缓存，这个缓存定时(默认30秒)从 Eureka Client 的缓存更新。 这么多的缓存机制可能就会造成一些问题，一个服务启动后可能最长需要 90s 才能被其它服务感知到: 1、首先，Eureka Server 维护每 30s 更新的响应缓存</p><p>2、Eureka Client 对已经获取到的注册信息也做了 30s 缓存</p><p>3、负载均衡组件 Ribbon 也有 30s 缓存</p><p>这三个缓存加起来，就有可能导致服务注册最长延迟 90s ，这个需要我们在特殊业务场景中注意其产生的影响。</p><h1 id="分布式" tabindex="-1"><a class="header-anchor" href="#分布式" aria-hidden="true">#</a> 分布式</h1><h3 id="_1-什么是cap理论" tabindex="-1"><a class="header-anchor" href="#_1-什么是cap理论" aria-hidden="true">#</a> 1.什么是CAP理论？</h3><p>CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本。</li><li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><h3 id="_2-什么是网络分区" tabindex="-1"><a class="header-anchor" href="#_2-什么是网络分区" aria-hidden="true">#</a> 2.<strong>什么是网络分区？</strong></h3><blockquote><p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/GPld9p.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-不是所谓的-3-选-2" tabindex="-1"><a class="header-anchor" href="#_3-不是所谓的-3-选-2" aria-hidden="true">#</a> 3.不是所谓的“3 选 2”？</h3><p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。</p><blockquote><p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p><p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p></blockquote><p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p><p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p><p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p><p>另外，需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p><h3 id="_4-base-理论" tabindex="-1"><a class="header-anchor" href="#_4-base-理论" aria-hidden="true">#</a> 4.BASE 理论？</h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p></blockquote><p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p><p>AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p><h3 id="_5-base-理论三要素" tabindex="-1"><a class="header-anchor" href="#_5-base-理论三要素" aria-hidden="true">#</a> 5.BASE 理论三要素？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/1ZQ6v4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>1. 基本可用</strong></p><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p><p><strong>什么叫允许损失部分可用性呢？</strong></p><ul><li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><p><strong>2. 软状态</strong></p><p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><p><strong>3.最终一致性</strong></p><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><blockquote><p>分布式一致性的 3 种级别：</p><ol><li><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</li><li><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ol><p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p></blockquote><p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p><h3 id="_6-paxos算法" tabindex="-1"><a class="header-anchor" href="#_6-paxos算法" aria-hidden="true">#</a> 6.Paxos算法？</h3><p><strong>Paxos 不是一致性算法而是共识算法</strong></p><p><strong>Basic Paxos 算法</strong></p><p>Basic Paxos 中存在 3 个重要的角色：</p><ol><li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端发起的提议，然后尝试让接受者接受该提议，同时保证即使多个提议者的提议之间产生了冲突，那么算法都能进行下去；</li><li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提议投票，同时需要记住自己的投票历史；</li><li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/2VSwYG.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>Multi Paxos 思想</strong></p><p>⚠️<strong>注意</strong> ： Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。</p><p>二阶段提交是达成共识常用的方式，Basic Paxos 就是通过二阶段提交的方式来达成共识。Basic Paxos 还支持容错，少于一般的节点出现故障时，集群也能正常工作</p><h3 id="_6-分布式幂等性如何设计" tabindex="-1"><a class="header-anchor" href="#_6-分布式幂等性如何设计" aria-hidden="true">#</a> 6.分布式幂等性如何设计？</h3><p>解决方案</p><p>1，查询和删除不在幂等讨论范围，查询肯定没有幂等的说，删除：第一次删除成功后，后面来删 除直接返回0，也是返回成功。</p><p>2，建唯一索引：唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发 时新增异常时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。</p><p>3，token机制：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交。前端 在数据提交前要向后端服务的申请token，token放到 Redis 或 JVM 内存，token有效时间。提交后 后台校验token，同时删除token，生成新的token返回。redis要用删除操作来判断token，删除成 功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用。</p><p>4，悲观锁 select id ,name from table_# where id=&#39;##&#39; for update;</p><p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用（另外还要考 虑id是否为主键，如果id不是主键或者不是 InnoDB 存储引擎，那么就会出现锁全表）。</p><p>5，乐观锁，给数据库表增加一个version字段，可以通过这个字段来判断是否已经被修改了</p><p>update table_xxx set name=#name#,version=version+1 where version=#version#</p><p>6，分布式锁，比如单号为key，然后给Key设置有效期（防止支付失败后，锁一直不释放），来一个请求使用订单号生成一把锁，业务代码执行完成后再释放锁。</p><p>7，保底方案，先查询是否存在此单，不存在进行支付，存在就直接返回支付结果。</p><h3 id="_7-简单一次完整的-http-请求所经历的步骤" tabindex="-1"><a class="header-anchor" href="#_7-简单一次完整的-http-请求所经历的步骤" aria-hidden="true">#</a> 7.简单一次完整的 HTTP 请求所经历的步骤？</h3><p>1、 DNS 解析(通过访问的域名找出其 IP 地址，递归搜索)。</p><p>2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手。</p><p>3.1、客户端向服务器发送请求命令（一般是 GET 或 POST 请求）。</p><p>客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何 到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，就是通过查找路由表决定通过那个路径到达服务器。</p><p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地 址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换 的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。</p><p>3.2、客户端发送请求头信息和数据。</p><p>4.1、服务器发送应答头信息。</p><p>4.2、服务器向客户端发送数据。</p><p>5、服务器关闭 TCP 连接（4次挥手）。</p><p>这里是否关闭 TCP 连接，也根据 HTTP Keep-Alive 机制有关。 同时，客户端也可以主动发起关闭 TCP 连接。</p><p>6、客户端根据返回的HTML、CSS、JS进行渲染。</p><h3 id="_8-你知道哪些分布式事务解决方案" tabindex="-1"><a class="header-anchor" href="#_8-你知道哪些分布式事务解决方案" aria-hidden="true">#</a> 8.你知道哪些分布式事务解决方案？</h3><p>我目前知道的有五种：</p><ol><li><p>两阶段提交(2PC)</p></li><li><p>三阶段提交(3PC)</p></li><li><p>补偿事务(TCC=Try-Conﬁrm-Cancel)</p></li><li><p>本地消息队列表(MQ)</p></li><li><p>Sagas事务模型(最终一致性)</p></li></ol><h3 id="_9-什么是二阶段提交" tabindex="-1"><a class="header-anchor" href="#_9-什么是二阶段提交" aria-hidden="true">#</a> 9.什么是二阶段提交？</h3><p>两阶段提交2PC是分布式事务中最强大的事务类型之一，两段提交就是分两个阶段提交：</p><p>第一阶段询问各个事务数据源是否准备好。</p><p>第二阶段才真正将数据提交给事务数据源。</p><p>为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者 （Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。</p><p>处理流程如下：</p><figure><img src="https://minio.pigx.top/oss/2022/07/hEbiN3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>阶段一</p><p>a) 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。</p><p>b) 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</p><p>c) 如参与者执行成功，给协调者反馈 yes，否则反馈 no。</p><p>阶段二 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则， 发送提交(commit)消息。</p><p>两种情况处理如下：</p><p>情况1：当所有参与者均反馈 yes，提交事务</p><p>a) 协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。</p><p>b) 参与者执行 commit 请求，并释放整个事务期间占用的资源。</p><p>c) 各参与者向协调者反馈 ack(应答)完成的消息。</p><p>d) 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</p><p>情况2：当有一个参与者反馈 no，回滚事务</p><p>a) 协调者向所有参与者发出回滚请求（即 rollback 请求）。</p><p>b) 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</p><p>c) 各参与者向协调者反馈 ack 完成的消息。</p><p>d) 协调者收到所有参与者反馈的 ack 消息后，即完成事务。</p><figure><img src="https://minio.pigx.top/oss/2022/09/Af5B3M.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>缺点：</p><ol><li>性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li></ol><ol start="2"><li><p>可靠性问题：如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。</p></li><li><p>数据一致性问题：如果发⽣局部⽹络问题，⼀部分事务参与者收到了提交消 息，另⼀部分事务参与者没收到提交消息，那么就会导致节点间数据的不 ⼀致问题。</p></li></ol><p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证 强一致）。</p><h3 id="_10-什么是三阶段提交" tabindex="-1"><a class="header-anchor" href="#_10-什么是三阶段提交" aria-hidden="true">#</a> 10.什么是三阶段提交？</h3><p>三阶段提交是在二阶段提交上的改进版本，3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交。 处理流程如下 ：</p><figure><img src="https://minio.pigx.top/oss/2022/07/UUXAPI.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>阶段一</p><p>a) 协调者向所有参与者发出包含事务内容的canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</p><p>b) 参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈no。</p><p>阶段二 协调者根据参与者响应情况，有以下两种可能。</p><p>情况1：所有参与者均反馈 yes，协调者预执行事务。</p><p>a) 协调者向所有参与者发出 preCommit 请求，进入准备阶段。</p><p>b) 参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</p><p>c) 各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。</p><p>情况2：只要有一个参与者反馈 no，或者等待超时后协调者尚无法收到所有提供者的反馈，即中断事务。</p><p>a) 协调者向所有参与者发出 abort 请求。</p><p>b) 无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事 务。</p><p>阶段三 该阶段进行真正的事务提交，也可以分为以下两种情况。</p><p>情况 1：所有参与者均反馈 ack 响应，执行真正的事务提交。</p><p>a) 如果协调者处于工作状态，则向所有参与者发出 do Commit 请求。</p><p>b) 参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</p><p>c) 各参与者向协调者反馈 ack 完成的消息。</p><p>d) 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</p><p>情况2：只要有一个参与者反馈 no，或者等待超时后协调组尚无法收到所有提供者的反馈，即回滚 事务。</p><p>a) 如果协调者处于工作状态，向所有参与者发出 rollback 请求。</p><p>b) 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。</p><p>c) 各参与者向协调组反馈 ack 完成的消息。</p><p>d) 协调组收到所有参与者反馈的 ack 消息后，即完成事务回滚。</p><figure><img src="https://minio.pigx.top/oss/2022/09/dwpR59.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>优点：相比二阶段提交，三阶段提交<strong>降低了阻塞范围</strong>，在<strong>等待超时</strong>后协调者或参与者会中断事务。 避免了协调者单点问题。阶段 3 中协调者出现问题时，参与者会继续提交事务。</p><p>缺点：数据不一致问题依然存在，当在参与者收到 <strong>preCommit 请求后等待 do commite 指令时</strong>， 此时如果协调者请求中断事务，而<strong>协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</strong></p><p><strong>2PC和3PC的区别：</strong></p><p>三阶段提交协议在协调者和参与者中都引⼊ 超时机制，并且把两阶段提交 协议的第⼀个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。 三阶段提交的三个阶段分别为：can_commit，pre_commit，do_commit。相对于2PC，3PC主要解决的单点故障问题，并减少阻塞， 因为⼀旦参与 者⽆法及时收到来⾃协调者的信息之后，他会默认执⾏commit。⽽不会⼀ 直持有事务资源并处于阻塞状态。</p><p><strong>3PC相对于2PC⽽⾔到底优化了什么地⽅呢</strong></p><p>相⽐较2PC⽽⾔，3PC对于协调者（Coordinator）和参与者（Partcipant） 都设置了超时时间，⽽2PC只有协调者才拥有超时机制。这解决了⼀个什 么问题呢？</p><p>这个优化点，主要是避免了参与者在⻓时间⽆法与协调者节点通讯（协调 者挂掉了）的情况下，⽆法释放资源的问题，因为参与者⾃身拥有超时机 制会在超时后，⾃动进⾏本地commit从⽽进⾏释放资源。⽽这种机制也侧 ⾯降低了整个事务的阻塞时间和范围。</p><p>另外，通过CanCommit、PreCommit、DoCommit三个阶段的设计，相较 于2PC⽽⾔，多设置了⼀个缓冲阶段保证了在最后提交阶段之前各参与节 点的状态是⼀致的。</p><h3 id="_11-什么是补偿事务" tabindex="-1"><a class="header-anchor" href="#_11-什么是补偿事务" aria-hidden="true">#</a> 11.什么是补偿事务？</h3><p>TCC</p><p>（Try Conﬁrm Cancel）是服务化的二阶段编程模型，采用的补偿机制：</p><figure><img src="https://minio.pigx.top/oss/2022/07/eGyLVY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。</p><p>它分为三个步骤：</p><p>Try 阶段主要是对业务系统做检测及资源预留。</p><p>Conﬁrm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Conﬁrm阶段时，默 认 Conﬁrm阶段是不会出错的。即：只要Try成功，Conﬁrm一定成功。</p><p>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p><p>优点：</p><p>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</p><p>数据最终一致性：基于 Conﬁrm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据 的一致性。</p><p>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动 管理器也变成多点，引入集群。</p><p>缺点：TCC 的 Try、Conﬁrm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开 发成本。</p><h3 id="_12-消息队列是怎么实现事务的" tabindex="-1"><a class="header-anchor" href="#_12-消息队列是怎么实现事务的" aria-hidden="true">#</a> 12.消息队列是怎么实现事务的？</h3><p><strong>本地消息表（异步确保）</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/MBAVps.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>基本思路就是：</p><p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。</p><p>然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经 处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个 业务补偿消息，通知生产方进行回滚等操作。</p><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。</p><p>这种方案遵循BASE理论，采用的是最终一致性，不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像 TCC那样可能出现确认或者回滚不了的情况。</p><p>优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。</p><p>缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p><p>MQ 事务消息 有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用 的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不 支持。</p><p>以阿里的 RocketMQ 中间件为例，其思路大致为：</p><figure><img src="https://minio.pigx.top/oss/2022/07/ujz4Ko.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/lPbG1N.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/bvEKSy.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>优点： 实现了最终一致性，不需要依赖本地数据库事务。</p><p>缺点： 实现难度大，主流MQ不支持 ，RocketMQ事务消息部分代码也未开源。</p><h3 id="_13-你知道哪些限流算法" tabindex="-1"><a class="header-anchor" href="#_13-你知道哪些限流算法" aria-hidden="true">#</a> 13.你知道哪些限流算法？</h3><p>限流算法有四种常见算法：</p><ul><li><p>计数器算法（固定窗口）</p></li><li><p>滑动窗口</p></li><li><p>漏桶算法</p></li><li><p>令牌桶算法</p></li></ul><h3 id="_14-说说什么是计数器-固定窗口-算法" tabindex="-1"><a class="header-anchor" href="#_14-说说什么是计数器-固定窗口-算法" aria-hidden="true">#</a> 14.说说什么是计数器（固定窗口）算法？</h3><p>计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个 周期开始时，进行清零，重新计数。</p><p>此算法在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性和线程安全即可轻松 实现。</p><figure><img src="https://minio.pigx.top/oss/2022/07/NczOFy.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个算法通常用于QPS限流和统计总访问量，对于秒级以上的时间周期来说，会存在一个非常严重 的问题，那就是临界问题，如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/07/OroT12.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>假设1min内服务器的负载能力为100，因此一个周期的访问量限制在100，然而在第一个周期的最 后5秒和下一个周期的开始5秒时间段内，分别涌入100的访问量，虽然没有超过每个周期的限制 量，但是整体上10秒内已达到200的访问量，已远远超过服务器的负载能力，由此可见，计数器算 法方式限流对于周期比较长的限流，存在很大的弊端。</p><h3 id="_15-说说什么是滑动窗口算法" tabindex="-1"><a class="header-anchor" href="#_15-说说什么是滑动窗口算法" aria-hidden="true">#</a> 15.说说什么是滑动窗口算法？</h3><p>滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。</p><p>如下图，假设时间周期为1min，将1min再分为2个小周期，统计每个小周期的访问数量，则可以看 到，第一个时间周期内，访问数量为75，第二个时间周期内，访问数量为100，超过100的访问则 被限流掉了</p><figure><img src="https://minio.pigx.top/oss/2022/07/3jpseM.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p>此算法可以很好的解决固定窗口算法的临界问题。</p><h3 id="_16-说说什么是漏桶算法" tabindex="-1"><a class="header-anchor" href="#_16-说说什么是漏桶算法" aria-hidden="true">#</a> 16.说说什么是漏桶算法？</h3><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发 限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。</p><figure><img src="https://minio.pigx.top/oss/2022/07/EyTWQQ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_17-说说什么是令牌桶算法" tabindex="-1"><a class="header-anchor" href="#_17-说说什么是令牌桶算法" aria-hidden="true">#</a> 17.说说什么是令牌桶算法？</h3><p>令牌桶算法是程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略</p><figure><img src="https://minio.pigx.top/oss/2022/07/8dYXzV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_18-分布式id生成方案有哪些" tabindex="-1"><a class="header-anchor" href="#_18-分布式id生成方案有哪些" aria-hidden="true">#</a> 18.分布式id生成方案有哪些？</h3><p>UUID,数据库主键自增，Redis自增ID，雪花算法。</p><table><thead><tr><th></th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>UUID</td><td>UUID是通用唯一标识码的缩写，其目的是让分布式系统中的所有元素都有唯一的辨识信息，而不需要通过中央控制器来指定唯一标识。</td><td>1. 降低全局节点的压力，使得主键生成速度更快；<br>2. 生成的主键全局唯一；<br>3. 跨服务器合并数据方便。</td><td>1. UUID占用16个字符，空间占用较多；<br>2. 不是递增有序的数字，数据写入IO随机性很大，且索引效率下降</td></tr><tr><td>数据库主键自增</td><td>MySQL数据库设置主键且主键自动增长</td><td>1. INT和BIGINT类型占用空间较小；<br>2. 主键自动增长，IO写入连续性好；<br>3. 数字类型查询速度优于字符串</td><td>1. 并发性能不高，受限于数据库性能；<br>2. 分库分表，需要改造，复杂；<br>3. 自增：数据和数据量泄露</td></tr><tr><td>Redis自增</td><td>Redis计数器，原子性自增</td><td>使用内存，并发性能好</td><td>1. 数据丢失；<br>2. 自增：数据量泄露</td></tr><tr><td>雪花算法（snowflake）</td><td>大名鼎鼎的雪花算法，分布式ID的经典解决方案</td><td>1. 不依赖外部组件；<br>2. 性能好</td><td>时钟回拨</td></tr></tbody></table><h3 id="_19-雪花算法生成的id由哪些部分组成" tabindex="-1"><a class="header-anchor" href="#_19-雪花算法生成的id由哪些部分组成" aria-hidden="true">#</a> 19.雪花算法生成的ID由哪些部分组成?</h3><ol><li>符号位，占用1位。</li><li>时间戳，占用41位，可以支持69年的时间跨度。</li><li>机器ID，占用10位。</li><li>序列号，占用12位。一毫秒可以生成4095个ID。</li></ol><figure><img src="https://minio.pigx.top/oss/2022/08/MbFGD0.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_20-分布锁有哪些解决方案" tabindex="-1"><a class="header-anchor" href="#_20-分布锁有哪些解决方案" aria-hidden="true">#</a> 20.分布锁有哪些解决方案？</h3><ol><li><p>Reids的分布式锁，很多大公司会基于Reidis做扩展开发。setnx key value ex 10s，Redisson。</p><p>watch dog.</p></li><li><p>基于Zookeeper。临时节点，顺序节点。</p></li><li><p>基于数据库，比如Mysql。主键或唯一索引的唯一性。</p></li></ol><h3 id="_21-redis做分布式锁用什么命令" tabindex="-1"><a class="header-anchor" href="#_21-redis做分布式锁用什么命令" aria-hidden="true">#</a> 21.Redis做分布式锁用什么命令？</h3><p>SETNX 格式：setnx key value 将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作,操作失败。</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>加锁：set key value nx ex 10s</p><p>释放锁：delete key</p><h3 id="_22-redis做分布式锁死锁有哪些情况-如何解决" tabindex="-1"><a class="header-anchor" href="#_22-redis做分布式锁死锁有哪些情况-如何解决" aria-hidden="true">#</a> 22.Redis做分布式锁死锁有哪些情况，如何解决？</h3><p>情况1：加锁，没有释放锁。需要加释放锁的操作。比如delete key。</p><p>情况2：加锁后，程序还没有执行释放锁，程序挂了。需要用的key的过期机制。</p><h3 id="_23-你设计微服务时遵循什么原则" tabindex="-1"><a class="header-anchor" href="#_23-你设计微服务时遵循什么原则" aria-hidden="true">#</a> 23.你设计微服务时遵循什么原则？</h3><ol><li>单一职责原则：让每个服务能独立，有界限的工作，每个服务只关注自己的业务。做到高内聚。</li><li>服务自治原则：每个服务要能做到独立开发、独立测试、独立构建、独立部署，独立运行。与其他服务进行解耦。</li><li>轻量级通信原则：让每个服务之间的调用是轻量级，并且能够跨平台、跨语言。比如采用RESTful风格，利用消息队列进行通信等。</li><li>粒度进化原则：对每个服务的粒度把控，其实没有统一的标准，这个得结合我们解决的具体业务问题。不要过度设计。服务的粒度随着业务和用户的发展而发展。</li></ol><p>​ 总结一句话，软件是为业务服务的，好的系统不是设计出来的，而是进化出来的。</p><h3 id="_24-cookie-和-session-有什么区别-如何使用session进行身份验证" tabindex="-1"><a class="header-anchor" href="#_24-cookie-和-session-有什么区别-如何使用session进行身份验证" aria-hidden="true">#</a> 24.Cookie 和 Session 有什么区别？如何使用Session进行身份验证？</h3><p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><p>那么，如何使用Session进行身份验证？</p><p>很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：</p><figure><img src="https://minio.pigx.top/oss/2022/08/z8FI8O.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用户向服务器发送用户名和密码用于登陆系统。 服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。 服务器向用户返回一个 SessionID，写入用户的 Cookie。 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。 使用 Session 的时候需要注意下面几个点：</p><p>依赖Session的关键业务一定要确保客户端开启了Cookie。 注意Session的过期时间</p><h3 id="_25-为什么cookie-无法防止csrf攻击-而token可以" tabindex="-1"><a class="header-anchor" href="#_25-为什么cookie-无法防止csrf攻击-而token可以" aria-hidden="true">#</a> 25.为什么Cookie 无法防止CSRF攻击，而token可以？</h3><p>**CSRF（Cross Site Request Forgery）**一般被翻译为 跨站请求伪造 。那么什么是 跨站请求伪造 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：</p><p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p><p>&lt;a src=<a href="http://www.mybank.com/Transfer?bankId=11&amp;money=10000" target="_blank" rel="noopener noreferrer">http://www.mybank.com/Transfer?bankId=11&amp;money=10000<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>&gt;科学理财，年盈利率过万&lt;/&gt; 进行Session 认证的时候，我们一般使用 Cookie 来存储 SessionId,当我们登陆后后端生成一个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储工具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个人。如果别人通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。</p><p>Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p><p>但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。</p><h3 id="_26-什么是-token-什么是-jwt-如何基于token进行身份验证" tabindex="-1"><a class="header-anchor" href="#_26-什么是-token-什么是-jwt-如何基于token进行身份验证" aria-hidden="true">#</a> 26.什么是 Token?什么是 JWT?如何基于Token进行身份验证？</h3><p>我们知道 Session 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 Session 信息服务器的可用性、不适合移动端（依赖Cookie）等等。</p><p>有没有一种不需要自己存放 Session 信息就能实现身份验证的方式呢？使用 Token 即可！JWT （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 Session 数据了，只用在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。</p><p>JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。</p><p>下面是 RFC 7519 对 JWT 做的较为正式的定义。</p><p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——JSON Web Token (JWT)</p><p>JWT 由 3 部分构成:</p><p>Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。 Payload（负载）:用来存放实际需要传递的数据 Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。 在基于 Token 进行身份验证的的应用程序中，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: Bearer Token。</p><p>用户向服务器发送用户名和密码用于登陆系统。 身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。 用户以后每次向后端发请求都在Header中带上 JWT。 服务端检查 JWT 并从中获取用户相关信息。</p><h3 id="_27-springcloud核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#_27-springcloud核心组件有哪些" aria-hidden="true">#</a> 27.springcloud核心组件有哪些？</h3><p>服务注册与发现——Netflix Eureka、Nacos、Zookeeper</p><p>客户端负载均衡——Netflix Ribbon、SpringCloud LoadBalancer</p><p>服务熔断器——Netflix Hystrix、Alibaba Sentinel、Resilience4J</p><p>服务网关——Netflix Zuul、SpringCloud Gateway</p><p>服务接口调用——Netflix Feign、 Resttemplate、Openfeign</p><p>链路追踪——Netflix Sleuth、Skywalking、Pinpoint</p><p>聚合Hystrix监控数据——Netflix Turbine</p><p>监控中心---- SpringBoot Admin</p><p>配置中心——Spring Cloud Config 、Apollo、nacos</p><h3 id="_28-分布式锁的使用场景是什么-有哪些实现方案" tabindex="-1"><a class="header-anchor" href="#_28-分布式锁的使用场景是什么-有哪些实现方案" aria-hidden="true">#</a> 28.分布式锁的使⽤场景是什么？有哪些实现⽅案？</h3><p>在单体架构中，多个线程都是属于同⼀个进程的，所以在线程并发执⾏时，遇到资源竞争时，可以利⽤ ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使⽤。</p><p>⽽在分布式架构中，多个线程是可能处于不同进程中的，⽽这些线程并发执⾏遇到资源竞争时，利⽤ ReentrantLock、synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思 就是，需要⼀个分布式锁⽣成器，分布式系统中的应⽤程序都可以来使⽤这个⽣成器所提供的锁，从⽽ 达到多个进程中的线程使⽤同⼀把锁。</p><p>⽬前主流的分布式锁的实现⽅案有两种：</p><ol><li>zookeeper：利⽤的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式 锁的特点是⾼⼀致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱</li><li>redis：利⽤redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是⾼可⽤， 因为redis保证的是AP，所以由它实现的分布式锁可能不可</li></ol><h3 id="_29-如果没有cookie-session还能进行身份验证吗" tabindex="-1"><a class="header-anchor" href="#_29-如果没有cookie-session还能进行身份验证吗" aria-hidden="true">#</a> 29.如果没有Cookie,Session还能进⾏身份验证吗？</h3><p>当服务器tomcat第⼀次接收到客户端的请求时，会开辟⼀块独⽴的session空间，建⽴⼀个session对 象，同时会⽣成⼀个session id，通过响应头的⽅式保存到客户端浏览器的cookie当中。以后客户端的 每次请求，都会在请求头部带上这个session id，这样就可以对应上服务端的⼀些会话的相关信息，⽐ 如⽤户的登录状态。</p><p>如果没有客户端的Cookie，Session是⽆法进⾏身份验证的。</p><p>当服务端从单体应⽤升级为分布式之后，cookie+session这种机制要怎么扩展？</p><ol><li>session黏贴： 在负载均衡中，通过⼀个机制保证同⼀个客户端的所有请求都会转发到同⼀个 tomcat实例当中。问题： 当这个tomcat实例出现问题之后，请求就会被转发到其他实例，这时候⽤户的session信息就丢了。</li><li>session复制： 当⼀个tomcat实例上保存了session信息后，主动将session 复制到集群中的其他实例。问题： 复制是需要时间的，在复制过程中，容易产⽣session信息丢失。</li><li>session共享： 就是将服务端的session信息保存到⼀个第三⽅中，⽐如Redis。</li></ol><h3 id="_30-什么是oauth2-0协议-有哪几种认证方式" tabindex="-1"><a class="header-anchor" href="#_30-什么是oauth2-0协议-有哪几种认证方式" aria-hidden="true">#</a> 30.什么是OAuth2.0协议？有哪⼏种认证⽅式？</h3><p>OAuth2.0是⼀个开放标准，允许⽤户授权第三⽅应⽤程序访问他们存储在另外的服务提供者上的信息， ⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。 OAuth2.0协议的认证流程，简单理解，就是允许我们将之前的授权和认证过程交给⼀个独⽴的第三⽅进 ⾏担保。 OAuth2.0协议有四种认证⽅式：</p><ol><li><p>授权码模式</p></li><li><p>简化模式</p></li><li><p>密码模式</p></li><li><p>客户端模式</p></li></ol><h3 id="_31-什么是sso-与oauth2-0有什么关系" tabindex="-1"><a class="header-anchor" href="#_31-什么是sso-与oauth2-0有什么关系" aria-hidden="true">#</a> 31.什么是SSO？与OAuth2.0有什么关系？</h3><p>OAuth2.0的使⽤场景通常称为联合登录， ⼀处注册，多处使⽤</p><p>SSO Single Sign On 单点登录。 ⼀处登录，多处同时登录</p><p>SSO的实现关键是将Session信息集中存储</p><h3 id="_32-epoll和poll的区别" tabindex="-1"><a class="header-anchor" href="#_32-epoll和poll的区别" aria-hidden="true">#</a> 32.epoll和poll的区别</h3><ol><li>select模型，使⽤的是数组来存储Socket连接⽂件描述符，容量是固定的，需要通过轮询来判断是否发⽣了IO事件</li><li>poll模型，使⽤的是链表来存储Socket连接⽂件描述符，容量是不固定的，同样需要通过轮询来判断是否发⽣了IO事件</li><li>epoll模型，epoll和poll是完全不同的，epoll是⼀种事件通知模型，当发⽣了IO事件时，应⽤程序才 进⾏IO操作，不需要像poll模型那样主动去轮询</li></ol><h3 id="_33-谈谈你对seata的理解" tabindex="-1"><a class="header-anchor" href="#_33-谈谈你对seata的理解" aria-hidden="true">#</a> 33.谈谈你对seata的理解</h3><p>在微服务架构下，由于数据库和应用服务的拆分，导致原本一个事务单元中的多 个 DML 操作，变成了跨进程或者跨数据库的多个事务单元的多个 DML 操作，而传统的数据库事务无法解决这类的问题，所以就引出了分布式事务的概念。</p><p>分布式事务本质上要解决的就是跨网络节点的多个事务的数据一致性问题，业内 常见的解决方法有两种</p><p>强一致性，就是所有的事务参与者要么全部成功，要么全部失败，全局事务协调 者需要知道每个事务参与者的执行状态，再根据状态来决定数据的提交或者回滚！</p><p>最终一致性，也叫弱一致性，也就是多个网络节点的数据允许出现不一致的情况， 但是在最终的某个时间点会达成数据一致。</p><p>基于 CAP 定理我们可以知道，强一致性方案对于应用的性能和可用性会有影响， 所以对于数据一致性要求不高的场景，就会采用最终一致性算法。</p><p>在分布式事务的实现上，对于强一致性，我们可以通过基于 XA 协议下的二阶段 提交来实现，对于弱一致性，可以基于 TCC 事务模型、可靠性消息模型等方案 来实现。</p><p>市面上有很多针对这些理论模型实现的分布式事务框架，我们可以在应用中集成 这些框架来实现分布式事务。</p><p>而 Seata 就是其中一种，它是阿里开源的分布式事务解决方案，提供了高性能 且简单易用的分布式事务服务。</p><p>Seata 中封装了四种分布式事务模式，分别是：</p><p>AT 模式，是一种基于本地事务+二阶段协议来实现的最终数据一致性方案，也是 Seata 默认的解决方案</p><figure><img src="https://minio.pigx.top/oss/2022/08/LYNiAh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>TCC 模式， TCC 事务是 Try、Confirm、Cancel 三个词语的缩写，简单理解就 是把一个完整的业务逻辑拆分成三个阶段，然后通过事务管理器在业务逻辑层面 根据每个分支事务的执行情况分别调用该业务的 Confirm 或者 Cacel 方法。</p><figure><img src="https://minio.pigx.top/oss/2022/08/9pt9xJ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Saga 模式，Saga 模式是 SEATA 提供的长事务解决方案，在 Saga 模式中，业 务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经 成功的参与者。</p><figure><img src="https://minio.pigx.top/oss/2022/08/fwrF43.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>XA 模式，XA 可以认为是一种强一致性的事务解决方法，它利用事务资源（数 据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一 种事务模式。</p><figure><img src="https://minio.pigx.top/oss/2022/08/Iyd9kY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从这四种模型中不难看出，在不同的业务场景中，我们可以使用 Seata 的不同 事务模型来解决不同业务场景中的分布式事务问题，因此我们可以认为 Seata 是一个一站式的分布式事务解决方案。</p><h3 id="_34-什么是数据一致性" tabindex="-1"><a class="header-anchor" href="#_34-什么是数据一致性" aria-hidden="true">#</a> 34.什么是数据⼀致性？</h3><p>数据⼀致性分为强⼀致性、弱⼀致性、最终⼀致性。</p><p>如果时刻保证客户端看到的数据都是⼀致的， 那么称之为强⼀致性。</p><p>如果允许存在中间状态，只要求经过⼀段时间后，数据最终是⼀致的， 则称之为最终⼀致性。</p><p>如果允许存在部分数据不⼀致，那么就称之为弱⼀致性。</p><h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h1><h3 id="_1-面向对象编程中-都有哪些设计原则" tabindex="-1"><a class="header-anchor" href="#_1-面向对象编程中-都有哪些设计原则" aria-hidden="true">#</a> 1.面向对象编程中，都有哪些设计原则</h3><ol><li><p>开闭原则 对扩展开放，对修改关闭。就是如果要修改原有的功能或者是扩展功能，尽量去扩展原有的代码，而不是修改原来已有的代码。</p></li><li><p>里氏替换原则 任何子类对象都应该可以替换其派生的超类对象 。即子类可以扩展父类的功能，但不要修改父类原有的功能。 也就是说，当一个子类继承父类后，尽量不要去重写它原有的方法。</p></li><li><p>依赖转置（依赖倒置）原则 要面向接口编程，不要面向实现编程。两个模块交互时，都访问各自接口，而不是具体的实现类。</p></li><li><p>单一职责原则 一个对象要专注于一种事情，不要让它担任太多责任。</p></li><li><p>接口隔离原则 一个接口尽量只包含用户关心的内容。就是一个接口不要太庞大。</p></li><li><p>迪米特法则 如果两个软件实体之间不是特别必要，尽量不要让他们直接通信。而是找个第三方进行转发，比如使用MQ（消息队列）。</p></li><li><p>合成复用原则 如果在“组合/聚合”和“继承”之间做抉择时，优先选择“组合/聚合”。</p></li></ol><figure><img src="https://minio.pigx.top/oss/2022/08/tiN4Rk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-设计模式的分类" tabindex="-1"><a class="header-anchor" href="#_2-设计模式的分类" aria-hidden="true">#</a> 2.设计模式的分类</h3><p>设计模式分为：</p><p><strong>创建型模式</strong>：</p><p>​ 用于创建对象的设计模式。一般可以简化用户创建对象的过程。其次可以降低耦合度，用户不需要关心对象具体的创建过程。 ​ 包含：单例模式、原型模型、工厂模式、建造者模式 <strong>结构型模型</strong>：</p><p>​ 组织对象之间的结构。使其易于扩展等。通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。 ​ 包括：代理模式、适配器模式、桥接模式、装饰器模式、外观模式、享元模式、组合模式。 <strong>行为模型</strong>：</p><p>​ 主要用于决定对象如何做出行为 ​ 包括：模板方法模式、策略模式、命令模式、责任链、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式、解释器模式。</p><h3 id="_3-你知道哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_3-你知道哪些设计模式" aria-hidden="true">#</a> 3.你知道哪些设计模式？</h3><figure><img src="https://minio.pigx.top/oss/2022/08/5I6vTQ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="nginx" tabindex="-1"><a class="header-anchor" href="#nginx" aria-hidden="true">#</a> Nginx</h1><h3 id="_1-什么是nginx" tabindex="-1"><a class="header-anchor" href="#_1-什么是nginx" aria-hidden="true">#</a> 1.什么是Nginx？</h3><p>Nginx是一个 轻量级/高性能的反向代理Web服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发。</p><h3 id="_2-nginx-有哪些优点" tabindex="-1"><a class="header-anchor" href="#_2-nginx-有哪些优点" aria-hidden="true">#</a> 2.<strong>Nginx 有哪些优点？</strong></h3><ul><li>跨平台、配置简单。</li><li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发。</li><li>内存消耗小：开启 10 个 Nginx 才占 150M 内存。</li><li>成本低廉，且开源。</li><li>稳定性高，宕机的概率非常小。</li><li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上</li></ul><h3 id="_3-nginx应用场景" tabindex="-1"><a class="header-anchor" href="#_3-nginx应用场景" aria-hidden="true">#</a> 3.<strong>Nginx应用场景？</strong></h3><ul><li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li><li>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。</li><li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。</li><li>nginz 中也可以配置安全管理、比如可以使用Nginx搭建API接口网关,对每个接口服务进行拦截。</li></ul><h3 id="_4-nginx怎么处理请求的" tabindex="-1"><a class="header-anchor" href="#_4-nginx怎么处理请求的" aria-hidden="true">#</a> 4.<strong>Nginx怎么处理请求的？</strong></h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server {         # 第一个Server区块开始，表示一个独立的虚拟主机站点
   listen       80； # 提供服务的端口，默认80
   server_name  localhost; # 提供服务的域名主机名
   location / { # 第一个location区块开始
     root   html; # 站点的根目录，相当于Nginx的安装目录
     index  index.html index.html;  # 默认的首页文件，多个用空格分开
} # 第一个location区块结果
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket(创建 Socket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。</li><li>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。</li><li>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与nginx进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</li><li>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</li><li>最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</li></ul><h3 id="_5-什么是正向代理" tabindex="-1"><a class="header-anchor" href="#_5-什么是正向代理" aria-hidden="true">#</a> 5.<strong>什么是正向代理？</strong></h3><p>一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p>客户端才能使用正向代理。正向代理总结就一句话：代理端代理的是客户端。例如说：我们使用的OpenVPN 等等。</p><h3 id="_6-什么是反向代理" tabindex="-1"><a class="header-anchor" href="#_6-什么是反向代理" aria-hidden="true">#</a> 6.<strong>什么是反向代理？</strong></h3><p>反向代理（Reverse Proxy）方式，是指以代理服务器来接受 Internet上的连接请求，然后将请求，发给内部网络上的服务器并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><blockquote><p>反向代理总结就一句话：代理端代理的是服务端。</p></blockquote><h3 id="_7-反向代理服务器的优点是什么" tabindex="-1"><a class="header-anchor" href="#_7-反向代理服务器的优点是什么" aria-hidden="true">#</a> 7.<strong>反向代理服务器的优点是什么?</strong></h3><p>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。</p><h3 id="_8-nginx负载均衡的算法怎么实现的-策略有哪些" tabindex="-1"><a class="header-anchor" href="#_8-nginx负载均衡的算法怎么实现的-策略有哪些" aria-hidden="true">#</a> 8.<strong>Nginx负载均衡的算法怎么实现的?策略有哪些?</strong></h3><p>为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。</p><p>Nginx负载均衡实现的策略有以下五种：</p><p><strong>1 .轮询(默认)</strong></p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</p><figure><img src="https://minio.pigx.top/oss/2022/08/YchGWN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li><strong>权重 weight</strong></li></ol><p>weight的值越大，分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</p><figure><img src="https://minio.pigx.top/oss/2022/08/Vi0Lxq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>3. ip_hash( IP绑定)</strong></p><p>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题</p><figure><img src="https://minio.pigx.top/oss/2022/08/XTv3Cb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>4. fair(第三方插件)</strong></p><p>必须安装upstream_fair模块。</p><p>对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</p><figure><img src="https://minio.pigx.top/oss/2022/08/AtEGtN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>5.url_hash(第三方插件)</strong></p><p>必须安装Nginx的hash软件包</p><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</p><figure><img src="https://minio.pigx.top/oss/2022/08/zvYS6H.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_9-限流怎么做的" tabindex="-1"><a class="header-anchor" href="#_9-限流怎么做的" aria-hidden="true">#</a> 9.<strong>限流怎么做的？</strong></h3><p>Nginx限流就是限制用户请求速度，防止服务器受不了</p><p>限流有3种</p><ul><li>正常限制访问频率（正常流量）</li><li>突发限制访问频率（突发流量）</li><li>限制并发连接数</li></ul><p>Nginx的限流都是基于漏桶流算法</p><blockquote><p>实现三种限流算法</p></blockquote><p>1、正常限制访问频率（正常流量）：</p><p>限制一个用户发送的请求，我Nginx多久接收一个请求。</p><p>Nginx中使用<code>ngx_http_limit_req_module</code>模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用<code>limit_req_zone</code>命令及<code>limit_req</code>命令限制单个IP的请求处理频率。</p><figure><img src="https://minio.pigx.top/oss/2022/08/NfCDfo.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>1r/s代表1秒一个请求，1r/m一分钟接收一个请求， 如果Nginx这时还有别人的请求没有处理完，Nginx就会拒绝处理该用户请求。</p><p>2、突发限制访问频率（突发流量）：</p><p>限制一个用户发送的请求，我Nginx多久接收一个。</p><p>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？</p><p>Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加burst参数以及nodelay参数：</p><figure><img src="https://minio.pigx.top/oss/2022/08/wLaPqP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求</p><p>3、 限制并发连接数</p><p>Nginx中的<code>ngx_http_limit_conn_module</code>模块提供了限制并发连接数的功能，可以使用<code>limit_conn_zone</code>指令以及<code>limit_conn</code>执行进行配置。接下来我们可以通过一个简单的例子来看下</p><figure><img src="https://minio.pigx.top/oss/2022/08/qLHlsf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上面配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的header被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过Nginx是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。</p><h3 id="_10-生产中如何设置worker进程的数量呢" tabindex="-1"><a class="header-anchor" href="#_10-生产中如何设置worker进程的数量呢" aria-hidden="true">#</a> 10.<strong>生产中如何设置worker进程的数量呢？</strong></h3><p>在有多个cpu的情况下，可以设置多个worker，worker进程的数量可以设置到和cpu的核心数一样多，如果在单个cpu上起多个worker进程，那么操作系统会在多个worker之间进行调度，这种情况会降低系统性能，如果只有一个cpu，那么只启动一个worker进程就可以了。</p><h3 id="_11-nginx-如何开启压缩" tabindex="-1"><a class="header-anchor" href="#_11-nginx-如何开启压缩" aria-hidden="true">#</a> 11.<strong>Nginx 如何开启压缩？</strong></h3><p>开启nginx gzip压缩后，网页、css、js等静态资源的大小会大大的减少，从而可以节约大量的带宽，提高传输效率，给用户快的体验。虽然会消耗cpu资源，但是为了给用户更好的体验是值得的。</p><p>开启的配置如下：</p><p>将以上配置放到nginx.conf的<code>http{ … }</code>节点中。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>http {
  # 开启gzip
  gzip on;
 
  # 启用gzip压缩的最小文件；小于设置值的文件将不会被压缩
  gzip_min_length 1k;
 
  # gzip 压缩级别 1-10 
  gzip_comp_level 2;
 
  # 进行压缩的文件类型。
 
  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
 
  # 是否在http header中添加Vary: Accept-Encoding，建议开启
  gzip_vary on;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保存并重启nginx，刷新页面（为了避免缓存，请强制刷新）就能看到效果了。</p><h3 id="_12-请解释nginx服务器上的master和worker进程分别是什么" tabindex="-1"><a class="header-anchor" href="#_12-请解释nginx服务器上的master和worker进程分别是什么" aria-hidden="true">#</a> 12.请解释Nginx服务器上的Master和Worker进程分别是什么?</h3><p>主程序 Master process 启动后，通过一个 for 循环来 接收 和 处理外部信号 ； 主进程通过 fork() 函数产生 worker 子进程 ，每个子进程执行一个 for循环来实现Nginx服务器 对事件的接收和处理 。</p><h1 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络" aria-hidden="true">#</a> 计算机网络</h1><h3 id="_1-应用层有哪些常见的协议" tabindex="-1"><a class="header-anchor" href="#_1-应用层有哪些常见的协议" aria-hidden="true">#</a> 1.应用层有哪些常见的协议？</h3><ul><li><strong>HTTP:超文本传输协议</strong></li></ul><p>​ 超文本传输协议主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p><figure><img src="https://minio.pigx.top/oss/2022/07/b5YwuN.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​ HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p><p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p><ul><li><strong>SMTP:简单邮件传输(发送)协议</strong></li></ul><p>​ <strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p><p>​ 注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p><p>​ SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p><p>​ 1.电子邮件的发送过程</p><p>​ 2.如何判断邮箱是真正存在的？</p><p><strong>电子邮件的发送过程：</strong></p><p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li><li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li><li>qq邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li></ol><p><strong>如何判断邮箱是真正存在的？</strong></p><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol><ul><li><strong>POP3/IMAP:邮件接收的协议</strong></li></ul><p>​ 这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。</strong></p><p>​ IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p><ul><li><strong>FTP:文件传输协议</strong></li></ul><p>​ <strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>​ FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li>控制连接：用于传送控制信息（命令和响应）</li><li>数据连接：用于数据传送；</li></ol><p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率</p></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/5ScnnA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>Telnet:远程登陆协议</strong></li></ul><p>​ <strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p><ul><li><strong>SSH:安全的网络传输协议</strong></li></ul><p>​ <strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p><p>​ <strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p><h3 id="_2-tcp-三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#_2-tcp-三次握手和四次挥手" aria-hidden="true">#</a> 2.TCP 三次握手和四次挥手？</h3><p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p><figure><img src="https://minio.pigx.top/oss/2022/07/9DXihZ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/07/WUYXd8.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><figure><img src="https://minio.pigx.top/oss/2022/07/JcFFym.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>为什么要三次握手？</strong></p><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双方收发功能都正常，缺一不可。</p><p><strong>第 2 次握手传回了 ACK，为什么还要传回 SYN？</strong></p><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><p><strong>为什么要四次挥手？</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/8s1yZZ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ul><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><h3 id="_3-tcp-udp-协议的区别" tabindex="-1"><a class="header-anchor" href="#_3-tcp-udp-协议的区别" aria-hidden="true">#</a> 3.TCP, UDP 协议的区别？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/qYWkHK.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h3 id="_4-tcp-如何保证可靠性" tabindex="-1"><a class="header-anchor" href="#_4-tcp-如何保证可靠性" aria-hidden="true">#</a> 4.TCP 如何保证可靠性？</h3><p><strong>序列号和确认号机制：</strong></p><p>TCP 发送端发送数据包的时候会选择一个 seq 序列号，接收端收到数据包后会检测数据包的完整性，如果检测通过会响应一个 ack 确认号表示收到了数据包。</p><p><strong>超时重发机制：</strong></p><p>TCP 发送端发送了数据包后会启动一个定时器，如果一定时间没有收到接受端的确认后，将会重新发送该数据包。</p><p><strong>对乱序数据包重新排序：</strong></p><p>从 IP 网络层传输到 TCP 层的数据包可能会乱序，TCP 层会对数据包重新排序再发给应用层。</p><p><strong>丢弃重复数据：</strong></p><p>从 IP 网络层传输到 TCP 层的数据包可能会重复，TCP 层会丢弃重复的数据包。</p><p><strong>流量控制：</strong></p><p>TCP 发送端和接收端都有一个固定大小的缓冲空间，为了防止发送端发送数据的速度太快导致接收 端缓冲区溢出，发送端只能发送接收端可以接纳的数据，为了达到这种控制效果，TCP 用了流量控 制协议（可变大小的滑动窗口协议）来实现。</p><h3 id="_5-osi-七层模型" tabindex="-1"><a class="header-anchor" href="#_5-osi-七层模型" aria-hidden="true">#</a> 5.OSI 七层模型？</h3><figure><img src="https://minio.pigx.top/oss/2022/07/UyJthk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p><figure><img src="https://minio.pigx.top/oss/2022/07/XzQlLL.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p><ol><li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li><li>OSI 的协议实现起来过分复杂，而且运行效率很低</li><li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场</li><li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li></ol><p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p><figure><img src="https://minio.pigx.top/oss/2022/07/cNSRI6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-tcp-ip-四层模型" tabindex="-1"><a class="header-anchor" href="#_6-tcp-ip-四层模型" aria-hidden="true">#</a> 6.TCP/IP 四层模型？</h3><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示</p><figure><img src="https://minio.pigx.top/oss/2022/07/vJ8edm.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>应用层（Application layer）</strong></p><p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p><figure><img src="https://minio.pigx.top/oss/2022/07/j343uq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><figure><img src="https://minio.pigx.top/oss/2022/07/D1uWqv.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>传输层（Transport layer）</strong></p><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><p><strong>传输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/tZewcP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>网络层（Network layer）</strong></p><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p><p>⚠️注意 ：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p><p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p><figure><img src="https://minio.pigx.top/oss/2022/07/fQxpUt.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>网络接口层（Network interface layer）</strong></p><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><ol><li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li><li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li></ol><figure><img src="https://minio.pigx.top/oss/2022/07/hWjmPF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_7-为什么网络要分层" tabindex="-1"><a class="header-anchor" href="#_7-为什么网络要分层" aria-hidden="true">#</a> 7.为什么网络要分层？</h3><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p><ol><li>Repository（数据库操作）</li><li>Service（业务操作）</li><li>Controller（前后端数据交互）</li></ol><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li></ol><h3 id="_8-http-协议介绍" tabindex="-1"><a class="header-anchor" href="#_8-http-协议介绍" aria-hidden="true">#</a> 8.HTTP 协议介绍?</h3><p>HTTP 协议，全称超文本传输协议。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p><p>HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。</p><h3 id="_9-http-协议通信过程" tabindex="-1"><a class="header-anchor" href="#_9-http-协议通信过程" aria-hidden="true">#</a> 9.HTTP 协议通信过程？</h3><p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p><ol><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li><li>服务器接收来自浏览器的 TCP 连接。</li><li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li><li>关闭 TCP 连接。</li></ol><h3 id="_10-http-协议优点" tabindex="-1"><a class="header-anchor" href="#_10-http-协议优点" aria-hidden="true">#</a> 10.HTTP 协议优点？</h3><p>扩展性强、速度快、跨平台支持性好。</p><h3 id="_11-https-协议介绍" tabindex="-1"><a class="header-anchor" href="#_11-https-协议介绍" aria-hidden="true">#</a> 11.HTTPS 协议介绍？</h3><p>HTTPS 协议，是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443。</p><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p><h3 id="_12-https-协议优点" tabindex="-1"><a class="header-anchor" href="#_12-https-协议优点" aria-hidden="true">#</a> 12.HTTPS 协议优点?</h3><p>保密性好、信任度高。</p><h3 id="_13-ssl-tls-的工作原理" tabindex="-1"><a class="header-anchor" href="#_13-ssl-tls-的工作原理" aria-hidden="true">#</a> 13.SSL/TLS 的工作原理?</h3><p><strong>非对称加密</strong></p><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p><figure><img src="https://minio.pigx.top/oss/2022/07/LWXL0I.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。</p><p><strong>对称加密</strong></p><p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p><blockquote><p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p></blockquote><figure><img src="https://minio.pigx.top/oss/2022/07/2cOX0h.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，<strong>使用非对称加密，对对称加密的密钥进行加密</strong>，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p><h3 id="_14-http与https区别" tabindex="-1"><a class="header-anchor" href="#_14-http与https区别" aria-hidden="true">#</a> 14.HTTP与HTTPS区别？</h3><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，**加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。**所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP <strong>耗费更多服务器资源</strong>。</li></ul><h3 id="_15-forward-和-redirect-的区别" tabindex="-1"><a class="header-anchor" href="#_15-forward-和-redirect-的区别" aria-hidden="true">#</a> 15.Forward 和 Redirect 的区别？</h3><p>浏览器 URL 地址：Forward 是服务器内部的重定向，服务器内部请求某个 servlet，然后获取 响应的内容，浏览器的 URL 地址是不会变化的；Redirect 是客户端请求服务器，然后服务器给 客户端返回了一个 <strong>302</strong> 状态码和新的 <strong>location</strong>，客户端重新发起 HTTP 请求，服务器给客户端 响应 location 对应的 URL 地址，浏览器的 URL 地址发生了变化。</p><p>数据的共享：Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的， request 中的信息在 servlet 间是共享的。Redirect 发起了两次 HTTP 请求分别使用不同的 request。</p><p>请求的次数：Forward 只有一次请求；Redirect 有两次请求。</p><h3 id="_16-说一下http的长连接与短连接的区别" tabindex="-1"><a class="header-anchor" href="#_16-说一下http的长连接与短连接的区别" aria-hidden="true">#</a> 16.说一下HTTP的长连接与短连接的区别？</h3><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p><strong>短连接</strong></p><p>​ 在HTTP/1.0中默认使用短链接,也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端访问的某个HTML或其他类型的Web资源，如 JavaScript 文件、图像文件、 CSS 文件等。当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p><strong>长连接</strong></p><p>​ 从HTTP/1.1起，默认使用长连接，用以保持连接特性。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭。如果客户端再次访问这个服务 器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时 间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><h1 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h1><h3 id="_1-什么是操作系统" tabindex="-1"><a class="header-anchor" href="#_1-什么是操作系统" aria-hidden="true">#</a> 1.什么是操作系统？</h3><ol><li><p><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></p></li><li><p><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong></p></li><li><p><strong>操作系统存在屏蔽了硬件层的复杂性。</strong></p></li><li><p><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。</p></li></ol><h3 id="_2-什么是系统调用呢" tabindex="-1"><a class="header-anchor" href="#_2-什么是系统调用呢" aria-hidden="true">#</a> 2.<strong>什么是系统调用呢？</strong></h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态</strong>(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li><li><strong>系统态</strong>(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h3 id="_3-操作系统的内存管理主要是做什么" tabindex="-1"><a class="header-anchor" href="#_3-操作系统的内存管理主要是做什么" aria-hidden="true">#</a> 3.<strong>操作系统的内存管理主要是做什么？</strong></h3><p>​ 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p><h3 id="_4-操作系统的内存管理机制了解吗-内存管理有哪几种方式" tabindex="-1"><a class="header-anchor" href="#_4-操作系统的内存管理机制了解吗-内存管理有哪几种方式" aria-hidden="true">#</a> 4.<strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></h3><p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。</p><p>连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p><ol><li><strong>块式管理</strong> ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li></ol><p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p><ol start="4"><li><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</li></ol><h1 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis" aria-hidden="true">#</a> Mybatis</h1><h3 id="_1-和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1-和-的区别是什么" aria-hidden="true">#</a> 1.#{}和${}的区别是什么？</h3><ul><li><code>${}</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc. Driver</code>。</li><li><code>#{}</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#{}</code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#{item.name}</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li></ul><h3 id="_2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签" tabindex="-1"><a class="header-anchor" href="#_2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签" aria-hidden="true">#</a> 2.Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h3><p>还有很多其他的标签， <code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p><h3 id="_3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" tabindex="-1"><a class="header-anchor" href="#_3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" aria-hidden="true">#</a> 3.通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code> ， 在 MyBatis 中，每一个 <code>&lt;select&gt;</code> 、 <code>&lt;insert&gt;</code> 、 <code>&lt;update&gt;</code> 、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p><p>Dao 接口里的方法可以重载，但是 Mybatis 的 XML 里面的 ID 不允许重复。<strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回</p><h3 id="_4-mybatis-是如何进行分页的-分页插件的原理是什么" tabindex="-1"><a class="header-anchor" href="#_4-mybatis-是如何进行分页的-分页插件的原理是什么" aria-hidden="true">#</a> 4.MyBatis 是如何进行分页的？分页插件的原理是什么？</h3><p><strong>(1)</strong> MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；</p><p><strong>(2)</strong> 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能;</p><p><strong>(3)</strong> 也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>举例： <code>select _ from student</code> ，拦截 sql 后重写为： <code>select t._ from （select \* from student）t limit 0，10</code></p><h3 id="_5-说说mybatis的缓存机制" tabindex="-1"><a class="header-anchor" href="#_5-说说mybatis的缓存机制" aria-hidden="true">#</a> 5.说说Mybatis的缓存机制:</h3><p>Mybatis整体：<img src="https://minio.pigx.top/oss/2022/07/tB17CF.png" alt="" loading="lazy"></p><p>一级缓存localCache</p><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的 SQL， MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的 SQL 语句，会优先命中一级缓存， 避免直接对数据库进行查询，提高性能。 每个 SqlSession 中持有了 Executor，每个 Executor 中有一个 LocalCache。当用户发起查询时， MyBatis 根据当前执行的语句生成 MappedStatement，在 Local Cache 进行查询，如果缓存命中 的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入 Local Cache，最后 返回结果给用户。具体实现类的类关系图如下图所示：</p><figure><img src="https://minio.pigx.top/oss/2022/07/wh5Lie.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p>MyBatis 一级缓存的生命周期和 SqlSession 一致。</p></li><li><p>MyBatis 一级缓存内部设计简单，只是一个没有容量限定的 HashMap，在缓存的功能性上有 所欠缺。</p></li><li><p>MyBatis 的一级缓存最大范围是 SqlSession 内部，有多个 SqlSession 或者分布式的环境下， 数据库写操作会引起脏数据，建议设定缓存级别为 Statement。</p></li></ol><p>二级缓存</p><p>在上文中提到的一级缓存中，其最大的共享范围就是一个 SqlSession 内部，如果多个 SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询，具体的工作 流程如下所示。</p><figure><img src="https://minio.pigx.top/oss/2022/07/7pixkg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>二级缓存开启后，同一个 namespace 下的所有操作语句，都影响着同一个 Cache，即二级缓存被 多个 SqlSession 共享，是一个全局的变量。</p><p>当开启缓存后，数据的查询执行的流程为：</p><p>二级缓存 -&gt; 一级缓存 -&gt; 数据库</p><ol><li><p>MyBatis 的二级缓存相对于一级缓存来说，实现了 SqlSession 之间缓存数据的共享，同时粒度 更加细，能够到 namespace 级别，通过 Cache 接口实现类不同的组合，对 Cache 的可控性 也更强。</p></li><li><p>MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件 比较苛刻。</p></li><li><p>在分布式环境下，由于默认的 MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现 读取到脏数据，需要使用集中式缓存将 MyBatis 的 Cache 接口实现，有一定的开发成本，直 接使用 Redis、Memcached 等分布式缓存可能成本更低，安全性也更高。</p></li></ol><h3 id="_6-什么是-mybatis" tabindex="-1"><a class="header-anchor" href="#_6-什么是-mybatis" aria-hidden="true">#</a> 6.什么是 Mybatis？</h3><p>1、Mybatis 是一个半 ORM（对象关系映射）框架， 它内部封装了 JDBC， 开发时 只需要关注 SQL 语句本身， 不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 程序员直接编写原生态 sql， 可以严格控制 sql 执行性 能， 灵活度高。</p><p>2、MyBatis 可以使用 XML 或注解来配置和映射原生信息， 将 POJO 映射成数 据库中的记录， 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>3、通过 xml 文件或注解的方式将要执行的各种 statement 配置起来， 并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句， 最 后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 （从执行 sql 到返 回 result 的过程）。</p><h3 id="_7-mybatis-编程步骤" tabindex="-1"><a class="header-anchor" href="#_7-mybatis-编程步骤" aria-hidden="true">#</a> 7.MyBatis 编程步骤</h3><ol><li>创建 SqlSessionFactory 对象。</li><li>通过 SqlSessionFactory 获取 SqlSession 对象。</li><li>通过 SqlSession 获得 Mapper 代理对象。</li><li>通过 Mapper 代理对象，执行数据库操作。</li><li>执行成功，则使用 SqlSession 提交事务。</li><li>执行失败，则使用 SqlSession 回滚事务。</li><li>最终，关闭会话。</li></ol><h3 id="_8-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理吗" tabindex="-1"><a class="header-anchor" href="#_8-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理吗" aria-hidden="true">#</a> 8.Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h3><ul><li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li><li>Mybatis 提供了 9 种动态 SQL 标签：<code>&lt;if /&gt;</code>、<code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code>、<code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code>、<code>&lt;foreach /&gt;</code>、<code>&lt;bind /&gt;</code> 。</li><li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li></ul><h3 id="_9-通常一个-xml-映射文件-都会写一个-mapper-接口与之对应。请问-这个-mapper-接口的工作原理是什么-mapper-接口里的方法-参数不同时-方法能重载吗" tabindex="-1"><a class="header-anchor" href="#_9-通常一个-xml-映射文件-都会写一个-mapper-接口与之对应。请问-这个-mapper-接口的工作原理是什么-mapper-接口里的方法-参数不同时-方法能重载吗" aria-hidden="true">#</a> 9.通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h3><p>Mapper 接口，对应的关系如下：</p><ul><li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li><li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li><li>接口方法内的参数，就是传递给 SQL 的参数。</li></ul><p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。</p><p>总结来说，在 Mybatis 中，每一个 <code>&lt;select /&gt;</code>、<code>&lt;insert /&gt;</code>、<code>&lt;update /&gt;</code>、<code>&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p><p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/09/pEe3NR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_10-mybatis-都有哪些-executor-执行器-它们之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#_10-mybatis-都有哪些-executor-执行器-它们之间的区别是什么" aria-hidden="true">#</a> 10.Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p><ul><li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li><li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map&lt;String, Statement&gt;</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li><li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select 操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个 Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li><li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li></ul><hr><p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。</p><p>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。</p><h3 id="_11-mybatis-如何执行批量插入" tabindex="-1"><a class="header-anchor" href="#_11-mybatis-如何执行批量插入" aria-hidden="true">#</a> 11.MyBatis 如何执行批量插入?</h3><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;String&quot;&gt; 
    INSERT INTO users(name) 
    VALUES (#{value}) 
&lt;/insert&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public interface UserMapper {
    
    void insertUser(@Param(&quot;name&quot;) String name);

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，调用该 Mapper 接口方法。代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>private static SqlSessionFactory sqlSessionFactory;

@Test
public void testBatch() {
    // 创建要插入的用户的名字的数组
    List&lt;String&gt; names = new ArrayList&lt;&gt;();
    names.add(&quot;占小狼&quot;);
    names.add(&quot;朱小厮&quot;);
    names.add(&quot;徐妈&quot;);
    names.add(&quot;飞哥&quot;);

    // 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit = false ，禁止事务自动提交
    try (SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH, false)) {
        // 获得 Mapper 对象
        UserMapper mapper = session.getMapper(UserMapper.class);
        // 循环插入
        for (String name : names) {
            mapper.insertUser(name);
        }
        // 提交批量操作
        session.commit();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码比较简单，胖友仔细看看。当然，还有另一种方式，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>INSERT INTO [表名]([列名],[列名]) 
VALUES
([列值],[列值])),
([列值],[列值])),
([列值],[列值]));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M</li></ul><h3 id="_12-mybatis-映射文件中-如果-a-标签通过-include-引用了b标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在a标签的前面" tabindex="-1"><a class="header-anchor" href="#_12-mybatis-映射文件中-如果-a-标签通过-include-引用了b标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在a标签的前面" aria-hidden="true">#</a> 12.Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p><p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p><h3 id="_13-mybatis缓存模块" tabindex="-1"><a class="header-anchor" href="#_13-mybatis缓存模块" aria-hidden="true">#</a> 13.mybatis缓存模块</h3><p>MyBatis 中提供了<strong>一级缓存和二级缓存</strong>，而这两级缓存都是依赖于基础支持层中的缓 存模块实现的。这里需要读者注意的是，MyBatis 中自带的这两级缓存与 MyBatis 以及整个应用是运行在同一个 JVM 中的，共享同一块堆内存。如果这两级缓存中的数据量较大， 则可能影响系统中其他功能的运行，所以当需要缓存大量数据时，优先考虑使用 Redis、Memcache 等缓存产品。</p><h3 id="_14-mybatis-sql执行整体过程" tabindex="-1"><a class="header-anchor" href="#_14-mybatis-sql执行整体过程" aria-hidden="true">#</a> 14.mybatis sql执行整体过程</h3><p>SQL 语句的执行涉及多个组件 ，其中比较重要的是 Executor、StatementHandler、ParameterHandler 和 ResultSetHandler 。</p><ul><li><strong>Executor</strong> 主要负责维护一级缓存和二级缓存，并提供事务管理的相关操作，它会将数据库相关操作委托给 StatementHandler完成。</li><li><strong>StatementHandler</strong> 首先通过 <strong>ParameterHandler</strong> 完成 SQL 语句的实参绑定，然后通过 <code>java.sql.Statement</code> 对象执行 SQL 语句并得到结果集，最后通过 <strong>ResultSetHandler</strong> 完成结果集的映射，得到结果对象并返回。</li></ul><p>整体过程如下图：</p><figure><img src="https://minio.pigx.top/oss/2022/09/gxAZVB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_15-mybatis连接池添加连接与获取连接" tabindex="-1"><a class="header-anchor" href="#_15-mybatis连接池添加连接与获取连接" aria-hidden="true">#</a> 15.mybatis连接池添加连接与获取连接</h3><figure><img src="https://minio.pigx.top/oss/2022/09/f4ElMj.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.top/oss/2022/09/aSHcID.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_16-什么是mybatis一级缓存、二级缓存" tabindex="-1"><a class="header-anchor" href="#_16-什么是mybatis一级缓存、二级缓存" aria-hidden="true">#</a> 16.什么是mybatis一级缓存、二级缓存</h3><p>每当我们使用 MyBatis 开启一次和数据库的会话，MyBatis 会创建出一个 SqlSession 对象表示一次数据库会话，<strong>而每个 SqlSession 都会创建一个 Executor 对象</strong>。</p><p>在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库，而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。</p><p>为了解决这一问题，减少资源的浪费，MyBatis 会在表示会话的SqlSession 对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。 <strong>注意，这个“简单的缓存”就是一级缓存，且默认开启，无法关闭</strong>。</p><p>如下图所示，MyBatis 会在一次会话的表示 —— 一个 SqlSession 对象中创建一个本地缓存( <code>localCache</code> )，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。</p><figure><img src="https://minio.pigx.top/oss/2022/09/0d6h3n.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在上文中提到的一级缓存中，<strong>其最大的共享范围就是一个 SqlSession 内部</strong>，如果多个 SqlSession 之间需要共享缓存，则需要使用到<strong>二级缓存</strong>。开启二级缓存后，会使用 CachingExecutor 装饰 Executor ，进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示。</p><figure><img src="https://minio.pigx.top/oss/2022/09/hAA7PF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_17-batchexecutor" tabindex="-1"><a class="header-anchor" href="#_17-batchexecutor" aria-hidden="true">#</a> 17.BatchExecutor</h3><p>BatchExecutor ，继承 BaseExecutor 抽象类，批量执行的 Executor 实现类。</p><p>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</p><h3 id="_18-jdbc编程步骤" tabindex="-1"><a class="header-anchor" href="#_18-jdbc编程步骤" aria-hidden="true">#</a> 18.jdbc编程步骤</h3><p>一、注册驱动</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.mysql.cj.jdbc.Driver&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//类加载注册</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>二、获取连接</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;用户名&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;密码&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>三、获取数据库操作对象</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  stat <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>四、设置传入参数</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>	stat<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>五、执行sql语句</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">&quot;select * from userinfo where user_id=?&quot;</span><span class="token punctuation">;</span>
  rs <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>六、处理查询结果集</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">while</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token class-name">String</span> name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;first_name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">String</span> money <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;salary&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">String</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">&quot;job_id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> money <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>七、释放资源</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token keyword">if</span><span class="token punctuation">(</span>rs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>stat <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>conn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://minio.pigx.top/oss/2022/09/BhYm3a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/springboot4/edit/main/src/offer/offer-started.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 2235602974@qq.com">付绪壮</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/offer/assets/app-fdefc158.js" defer></script>
  </body>
</html>
