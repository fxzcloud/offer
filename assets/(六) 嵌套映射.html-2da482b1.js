import{_ as i,V as p,W as t,$ as a}from"./framework-8edddef6.js";const e={},g=a('<h1 id="嵌套映射" tabindex="-1"><a class="header-anchor" href="#嵌套映射" aria-hidden="true">#</a> 嵌套映射</h1><p>在Mybatis中，所谓的嵌套映射，就是ResultMap中返回的bean存在其它bean的List的属性，这样就设置到了重复属性的保存，因为关系型数据返回的数据都是二维的，也就是以bean中的List为主，而bean中的属性都是重复的，如下：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/Ar3aNy.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这就涉及到了，对这些重复的属性怎么映射的问题，简单的说Mybatis中，就是使用缓存来保存这些属性的bean，发现了重复的属性（根据RowKey(id)），就不在创建bean，下面看下具体实现过程：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/aCrn2w.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所有映射流程的解析都是在DefaultResultSetHandler当中完成。主要方法如下：</p><p><strong>handleRowValuesForNestedResultMap()</strong></p><p>嵌套结果集解析入口，在这里会遍历结果集中所有行。并为每一行创建一个RowKey对象。然后调用getRowValue()获取解析结果对象。最后保存至ResultHandler中。</p><blockquote><p>注：调用getRowValue前会基于RowKey获取已解析的对象，然后作为partialObject参数发给getRowValue</p></blockquote><p>当读取第一行的时候，首先创建RowKey（默认根据id进行创建，如果没有id，就根据全部映射的result字段进行创建），之后读取缓存数据，当缓存不存在的时候，创建Blog对象同时对属性进行赋值，当存在符合属性的时候，递归操作，当创建对象后进行缓存。</p><p>读取第二行的时候，发现已经存在Blog对象，直接使用，然后填充复合属性。</p><figure><img src="https://minio.pigx.vip/oss/2022/09/cogfu6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第一次获取一定是null的：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/xeNaYT.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>getRowValue()</strong></p><p>该方法最终会基于当前行生成一个解析好对象。具体职责包括：</p><p>1.创建对象</p><p>2.填充普通属性</p><p>3.填充嵌套属性，在解析嵌套属性时会以递归的方式在调用getRowValue获取子对象</p><p>4.基于RowKey 暂存当前解析对象</p><blockquote><p>如果partialObject参数不为空 只会执行 第3步。因为1、2已经执行过了。</p></blockquote><p>所以需要创建对象，同时遍历映射属性：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/cSfKwC.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里就是需要填充复合映射的属性：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/j4H9Uq.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>applyNestedResultMappings()</strong></p><p>解析并填充嵌套结果集映射，遍历所有嵌套映射,然后获取其嵌套ResultMap。接着创建RowKey 去获取暂存区的值。然后调用getRowValue 获取属性对象。最后填充至父对象。</p><blockquote><p>如果通过RowKey能获取到属性对象，它还是会去调用getRowsValue，因为有可能属下还存在未解析的属性。</p></blockquote><p>设置复合属性的MapId:</p><figure><img src="https://minio.pigx.vip/oss/2022/09/WxbrAb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>获取列明的前缀：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/ruG7Kk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>合并子类和父类的RowKey:</p><figure><img src="https://minio.pigx.vip/oss/2022/09/1VC1Rd.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>获取到值，并且递归调用getRowValue获取复合属性对象的值：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/EH0OuW.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个时候，对应的复合属性里面，就已经有值了：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/fEVax2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当解析到第三行的时候，暂存区就存在三个值，一个是博客的值，另外一个是两个评论：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/xOBf55.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="循环引用" tabindex="-1"><a class="header-anchor" href="#循环引用" aria-hidden="true">#</a> 循环引用</h2><p>两个对象之间互相引用即循环引用，如下图就是一个例子：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/HMZ9eG.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对应ResultMap如下：</p><figure><img src="https://minio.pigx.vip/oss/2022/09/NywrrB.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这种情况会导致解析死循环吗？答案是不会。DefaultResultSetHandler 在解析复合映射之前都会在上下文中填充当前解析对象（使用resultMapId做为Key）。如果子属性又映射引用了父映射ID，就可以直接获取不需要在去解析父对象。具体流程如下：</p><p>先去把当前对象的时候，放入ancestorObjects中，当在解析复合对象的时候，就会去ancestorObjects寻找是否存在，如果存在则进行关联。</p><figure><img src="https://minio.pigx.vip/oss/2022/09/6tN1UL.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://minio.pigx.vip/oss/2022/09/YRCzeb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',49),o=[g];function n(s,l){return p(),t("div",null,o)}const c=i(e,[["render",n],["__file","(六) 嵌套映射.html.vue"]]);export{c as default};
